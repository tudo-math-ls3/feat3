<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FEAT: Frequently Asked Questions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FEAT<span id="projectnumber">&#160;3</span>
   </div>
   <div id="projectbrief">Finite Element Analysis Toolbox</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('faq_page.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Frequently Asked Questions </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#faq_generic">Generic FAQ</a><ul><li class="level2"><a href="#faq_gen_int_vs_index">Why are some arrays indexed using the &#39;int&#39; type and others using the &#39;FEAT::Index&#39; type?</a></li>
<li class="level2"><a href="#faq_gen_what_is_eickt">Some source files in the kernel subdirectories have &quot;eickt&quot; in their filename. What are these files for?</a></li>
<li class="level2"><a href="#faq_gen_use_eickt_or_not">Should I use the --eickt option for configure or not?</a></li>
</ul>
</li>
<li class="level1"><a href="#faq_lafem">LAFEM FAQ</a><ul><li class="level2"><a href="#faq_lafem_assign_op">Why can&#39;t I use the assignment operator &#39;=&#39; to copy LAFEM containers?</a></li>
<li class="level2"><a href="#faq_lafem_clone_convert_copy">What is the difference between the clone(), copy() and convert() member functions?</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="faq_generic"></a>
Generic FAQ</h1>
<h2><a class="anchor" id="faq_gen_int_vs_index"></a>
Why are some arrays indexed using the 'int' type and others using the 'FEAT::Index' type?</h2>
<p >Let us begin with the two golden rules of thumb for successfully indexing in FEAT3:</p><ul>
<li>All arrays, whose length is runtime dependent, are indexed using the '<a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1" title="Index data type.">FEAT::Index</a>' type.</li>
<li>All arrays, whose length is compile-time dependent, are indexed using the builin 'int' type.</li>
</ul>
<p >The reason for using <a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1" title="Index data type.">FEAT::Index</a>, which is typedefed to 'unsigned long' by default, this is quite simple and obvious to any experienced programmer: We want to be able to define this type to a 32-bit or 64-bit unsigned integer type depending on whatever is best for the platform that FEAT3 is currently compiled on. This desire directly rules out the use of a buildin type name like 'int' or 'unsigned long' or whatever and a typedef is the only proper way to go.</p>
<p >Now the main question is: Why don't we always use <a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1" title="Index data type.">FEAT::Index</a> for indexing?</p>
<p >The reason for this is quite pragmatic and rather technical: Entries of "small" containers like Tiny::Vector and Tiny::Matrix are very often addressed explicitly with literals ("constants") to implement various formulae, whereas entries of "large" containers like the LAFEM containers are usually only addressed using loop variables. Although it would be more consistent to use the <a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1" title="Index data type.">FEAT::Index</a> type for addressing all types of array elements, one would have to manually cast each explicit index literal to the Index type to avoid compiler warnings complaining about implicit int-to-Index casts &ndash; and this original approach turned out to be much more painful than it sounds.</p>
<p >Let's take a look at an example: Let a, b and c denote three Tiny::Vector&lt;double,3&gt;'s and we want to compute the 3D cross product c := a x b. The code for the cross product using 'int' for indexing looks like this: </p><div class="fragment"><div class="line">c(0) = a(1) * b(2) - a(2) * b(1);</div>
<div class="line">c(1) = a(2) * b(0) - a(0) * b(2);</div>
<div class="line">c(2) = a(0) * b(1) - a(1) * b(0);</div>
</div><!-- fragment --><p >If the Tiny::Vector entries were addressed using the <a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1" title="Index data type.">FEAT::Index</a> type, one would have to write the following code instead: </p><div class="fragment"><div class="line">c(Index(0)) = a(Index(1)) * b(Index(2)) - a(Index(2)) * b(Index(1));</div>
<div class="line">c(Index(1)) = a(Index(2)) * b(Index(0)) - a(Index(0)) * b(Index(2));</div>
<div class="line">c(Index(2)) = a(Index(0)) * b(Index(1)) - a(Index(1)) * b(Index(0));</div>
</div><!-- fragment --><p >Because the latter approach turned out to be difficult to read and tedious to write, the decision was made to use the int type for indexing compile-time arrays to keep the literals short and clear, thus sacrificing consistency.</p>
<h2><a class="anchor" id="faq_gen_what_is_eickt"></a>
Some source files in the kernel subdirectories have "eickt" in their filename. What are these files for?</h2>
<p >These source files are used by the build system to <em><b>e</b>xplicitly <b>i</b>nstantiate <b>c</b>ommon <b>k</b>ernel <b>t</b>emplates</em>, if the <code>--eickt</code> option has been passed to the <code>configure</code> script.</p>
<p >By design, most classes defined in the FEAT3 kernel are implemented as class templates and by design of the C++ language, class templates and &ndash; even more importantly &ndash; their member functions are only compiled if the class template is instantiated (i.e. used) in a source file. The advantage of this approach is that class templates are only compiled if they actually <b>need</b> to be compiled in an application/tutorial/unit-test source file.</p>
<p >However, there are two downsides to this:<br  />
Firstly, all class templates, that are used in an application, have to be recompiled when the application source file has changed, although the kernel class templates themselves have not changed since the last compilation. This means that you spend a lot of time recompiling kernel code over and over again, although that kernel code does not change. (Note that some modern compilers will try to reduce this recompilation time as good as they can, which may or may not work out well.)</p>
<p >Secondly, a class template, that is used by many applications/tutorials/unit-tests (think of SparseMatrixCSR as an example), has to be compiled for each for each applications separately, although the kernel class template is identical for each application. This severely increases overall compilation time if you are compiling a whole bunch of applications, which use a lot of common class templates. (The nighly regression test system is a perfect example, because it compiles all applications/unit-tests.)</p>
<p >The <em>eickt</em> mechanism reduces this recompilation overhead to some extend by pre-compiling commonly used kernel class templates in the FEAT3 kernel. For instance, the LAFEM::SparseMatrixCSR class template is often used with the <code>&lt;Mem::Main,double,Index&gt;</code> template parameter combination, so the class <code>LAFEM::SparseMatrixCSR&lt;Mem::Main,double,Index&gt;</code> is explicitly instantiated in the kernel library.</p>
<p >The primary advantage of this eickt mechanism is that recompiling an application can be significantly faster if the kernel code has not changed since the last compilation, because the precompiled class templates will not have to be recompiled. The drawback is that the (initial) compilation of the kernel will be significantly slower because the class templates have to be precompiled every time one of the relevant kernel files changes.</p>
<h2><a class="anchor" id="faq_gen_use_eickt_or_not"></a>
Should I use the --eickt option for configure or not?</h2>
<p >It depends whether you are actively working on kernel code or whether you are only writing application code without changing kernel code. In the latter case, using the eickt mechanism may speed up our overall compilation times, so it might be a good idea to use it. On the other hand, if you are actively modifying kernel code, then using eickt may significantly increase compiling times for you, if some of the eickt sources have to be re-pre-compiled due to the changes that you have made &ndash; even if you did not change any of the precompiled class templates themselves.</p>
<p >In a nutshell: If you change kernel files frequently, eickt is usually a bad idea, otherwise it is usually a good idea.</p>
<h1><a class="anchor" id="faq_lafem"></a>
LAFEM FAQ</h1>
<h2><a class="anchor" id="faq_lafem_assign_op"></a>
Why can't I use the assignment operator '=' to copy LAFEM containers?</h2>
<p >The short answer is: efficency.</p>
<p >The standard (copy) assignment operator has been deleted for LAFEM containers to force the programmer to explicitly decide, whether a container has to be</p><ul>
<li>cloned (via the clone() member function)</li>
<li>moved (via the std::move function)</li>
<li>copied (via the copy() member function)</li>
</ul>
<p >The easiest way to create a new stand-alone copy (aka 'clone') of an existing LAFEM container is to use the clone() member function:</p>
<div class="fragment"><div class="line">LAFEM::DenseVector&lt;Mem::Main, Index, double&gt; vector_src(10u); <span class="comment">// create source vector</span></div>
<div class="line">LAFEM::DenseVector&lt;Mem::Main, Index, double&gt; vector_dst;      <span class="comment">// create empty destination vector</span></div>
<div class="line">vector_src.format(1.0);                                       <span class="comment">// set all values to 1.0 (or initialize vector_src in some other manner)</span></div>
<div class="line">vector_dst = vector_src.clone();                              <span class="comment">// create clone of source vector as destination vector</span></div>
</div><!-- fragment --><p >See also <a class="el" href="faq_page.html#faq_lafem_clone_convert_copy">What is the difference between the clone(), copy() and convert() member functions?</a></p>
<h2><a class="anchor" id="faq_lafem_clone_convert_copy"></a>
What is the difference between the clone(), copy() and convert() member functions?</h2>
<p >The <b>copy()</b> member function is more or less a <code>memcpy</code> equivalent for LAFEM containers, i.e. it only performs a plain bit-wise copy of the (index and data) array element values of one LAFEM container to another. In consequence, the <b>copy()</b> member function only works between two LAFEM containers of the same class template with the same index and data types. The <b>copy()</b> member function always assumes that both the source and the destination containers are compatible upon call, i.e all index and data arrays of the source and destination containers are already allocated to the correct matching sizes. The <b>copy()</b> member function <em>never</em> allocates new arrays in the destination container and it also <em>never</em> frees the existing arrays of the destination container, so therefore it will abort program execution with a failed assertion if the source and destination container dimensions mismatch.</p>
<p >Finally, the <b>copy()</b> member function can be used to copy the array element values between different memory types, i.e. you can use it to perform a device-to-host or host-to-device copy between two instances of a LAFEM container, e.g.:</p>
<div class="fragment"><div class="line">Index n = 10u;                                               <span class="comment">// vector size</span></div>
<div class="line">LAFEM::DenseVector&lt;Mem::Main, Index, double&gt; vector_main(n); <span class="comment">// vector in main memory</span></div>
<div class="line">LAFEM::DenseVector&lt;Mem::CUDA, Index, double&gt; vector_cuda(n); <span class="comment">// vector in cuda memory</span></div>
<div class="line">vector_main.format(1.0);                                     <span class="comment">// set all values to 1.0 (or initialize vector_main in some other manner)</span></div>
<div class="line">vector_cuda.copy(vector_main);                               <span class="comment">// copy main vector to cuda vector</span></div>
</div><!-- fragment --><p >The <b>clone()</b> member function creates a <em>new</em> copy of an existing LAFEM container with the same memory, data and index type. Note that there exist two overloads of the <b>clone()</b> function: one that takes the source container (of the exact same type) as a function argument (in analogy to the copy function), e.g. </p><div class="fragment"><div class="line">LAFEM::DenseVector&lt;Mem::Main, Index, double&gt; vector_src(10u); <span class="comment">// create source vector</span></div>
<div class="line">LAFEM::DenseVector&lt;Mem::Main, Index, double&gt; vector_dst;      <span class="comment">// create empty destination vector</span></div>
<div class="line">vector_src.format(1.0);                                       <span class="comment">// set all values to 1.0 (or initialize vector_src in some other manner)</span></div>
<div class="line">vector_dst.clone(vector_src);                                 <span class="comment">// create destination vector as clone of source</span></div>
</div><!-- fragment --><p> as well as a second overload, which returns the new container as a return value, e.g. </p><div class="fragment"><div class="line">LAFEM::DenseVector&lt;Mem::Main, Index, double&gt; vector_src(10u); <span class="comment">// create source vector</span></div>
<div class="line">vector_src.format(1.0);                                       <span class="comment">// set all values to 1.0 (or initialize vector_src in some other manner)</span></div>
<div class="line"><span class="keyword">auto</span> vector_dst = vector_src.clone();                         <span class="comment">// create clone of source vector as destination vector</span></div>
</div><!-- fragment --><p> In addition to this functionality, both <b>clone()</b> overloads of some LAFEM containers support various <em>clone modes</em>, which are specified using the LAFEM::CloneMode enumeration.</p>
<p >The <b>convert()</b> member function is used to convert one LAFEM container into another (compatible) container, possibly using a different LAFEM container class template and/or different memory, index and/or data types. This member function is used in one of the following scenarios:</p><ul>
<li>A clone of a LAFEM container class template using a different memory, index or data type has to be created.</li>
<li>A LAFEM container has to be converted to a different (compatible) container class template, e.g. one wants to convert a LAFEM::SparseMatrixBanded object into a corresponding LAFEM::SparseMatrixCSR object.</li>
</ul>
<p >In both scenarios, the source and destination objects must be created, although the destination object may be uninitialized.</p>
<div class="fragment"><div class="line">LAFEM::DenseVector&lt;Mem::Main, Index, double&gt; vector_src(10u); <span class="comment">// create double-precision source vector</span></div>
<div class="line">LAFEM::DenseVector&lt;Mem::Main,   int, float &gt; vector_dst;      <span class="comment">// create empty single-precision destination vector</span></div>
<div class="line">vector_src.format(1.0);                                       <span class="comment">// set all values to 1.0 (or initialize vector_src in some other manner)</span></div>
<div class="line">vector_dst.convert(vector_src);                               <span class="comment">// create destination vector as converted source vector</span></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
