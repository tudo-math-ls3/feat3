<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FEAT: FEAT::Solver Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FEAT<span id="projectnumber">&#160;3</span>
   </div>
   <div id="projectbrief">Finite Element Analysis Toolbox</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespace_f_e_a_t_1_1_solver.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">FEAT::Solver Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="namespace_f_e_a_t_1_1_solver.html" title="Solver namespace.">Solver</a> namespace.  
<a href="namespace_f_e_a_t_1_1_solver.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_d_p_solver_base.html">ADPSolverBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base-Class for Solvers based on Algebraic-DOF-Partitioning.  <a href="class_f_e_a_t_1_1_solver_1_1_a_d_p_solver_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_d_p_solver_base_3_01_global_1_1_matrix_3_01_local_matrix___00_01_12327537b8e7a13ea5005abbbfa76845.html">ADPSolverBase&lt; Global::Matrix&lt; LocalMatrix_, Mirror_, Mirror_ &gt;, GlobalFilter_, SolverBase_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_d_p_solver_base.html" title="Base-Class for Solvers based on Algebraic-DOF-Partitioning.">ADPSolverBase</a> interface for <a class="el" href="class_f_e_a_t_1_1_global_1_1_matrix.html" title="Global Matrix wrapper class template.">Global::Matrix</a> instances.  <a href="class_f_e_a_t_1_1_solver_1_1_a_d_p_solver_base_3_01_global_1_1_matrix_3_01_local_matrix___00_01_12327537b8e7a13ea5005abbbfa76845.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_d_p_solver_base_3_01_global_1_1_p_m_d_c_d_s_c_matrix_3_01_matrix_040b7e1caa6985ce9572fb7c7833a8b9.html">ADPSolverBase&lt; Global::PMDCDSCMatrix&lt; MatrixB_, MatrixD_ &gt;, GlobalFilter_, SolverBase_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_d_p_solver_base.html" title="Base-Class for Solvers based on Algebraic-DOF-Partitioning.">ADPSolverBase</a> interface for <a class="el" href="class_f_e_a_t_1_1_global_1_1_p_m_d_c_d_s_c_matrix.html" title="Pre-Multiplied Discontinuous Diagonal Schur-Complement Matrix.">Global::PMDCDSCMatrix</a> instances.  <a href="class_f_e_a_t_1_1_solver_1_1_a_d_p_solver_base_3_01_global_1_1_p_m_d_c_d_s_c_matrix_3_01_matrix_040b7e1caa6985ce9572fb7c7833a8b9.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_l_g_l_i_b_min_c_g.html">ALGLIBMinCG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around ALGLIB's mincg implementation for minimising an functional's gradient.  <a href="class_f_e_a_t_1_1_solver_1_1_a_l_g_l_i_b_min_c_g.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_l_g_l_i_b_min_l_b_f_g_s.html">ALGLIBMinLBFGS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around ALGLIB's lBFGS implementation for minimising an functional's gradient.  <a href="class_f_e_a_t_1_1_solver_1_1_a_l_g_l_i_b_min_l_b_f_g_s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_ama_vanka.html">AmaVanka</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additive Macro-wise Matrix-based <a class="el" href="class_f_e_a_t_1_1_solver_1_1_vanka.html" title="Vanka preconditioner/smoother class template.">Vanka</a> preconditioner/smoother.  <a href="class_f_e_a_t_1_1_solver_1_1_ama_vanka.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_analytic_function_operator.html">AnalyticFunctionOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class defining an operator based on a scalar AnalyticFunction.  <a href="class_f_e_a_t_1_1_solver_1_1_analytic_function_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_approximate_hessian_precond.html">ApproximateHessianPrecond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for applying an the inverse of an operator's approximate Hessian as a preconditioner.  <a href="class_f_e_a_t_1_1_solver_1_1_approximate_hessian_precond.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab.html">BiCGStab</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Preconditioned) Bi-Conjugate Gradient Stabilized solver implementation  <a href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab_l.html">BiCGStabL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Preconditioned) BiCGStab(l) solver implementation  <a href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab_l.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_boomer_a_m_g.html">BoomerAMG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">HYPRE BoomerAMGWrapper class template.  <a href="class_f_e_a_t_1_1_solver_1_1_boomer_a_m_g.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_chebyshev.html">Chebyshev</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_chebyshev.html" title="Chebyshev Polynomial implementation.">Chebyshev</a> Polynomial implementation.  <a href="class_f_e_a_t_1_1_solver_1_1_chebyshev.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_convert_precond.html">ConvertPrecond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_f_e_a_t_1_1_solver.html" title="Solver namespace.">Solver</a> conversion module.  <a href="class_f_e_a_t_1_1_solver_1_1_convert_precond.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_convert_precond_3_01_global_1_1_vector_3_01_local_vector_outer___00120b74f43424364c71ee3ecd9deab297.html">ConvertPrecond&lt; Global::Vector&lt; LocalVectorOuter_, MirrorOuter_ &gt;, Global::Vector&lt; LocalVectorInner_, MirrorInner_ &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert preconditioner specialization for <a class="el" href="class_f_e_a_t_1_1_global_1_1_vector.html" title="Global vector wrapper class template.">Global::Vector</a>.  <a href="class_f_e_a_t_1_1_solver_1_1_convert_precond_3_01_global_1_1_vector_3_01_local_vector_outer___00120b74f43424364c71ee3ecd9deab297.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_cu_solver_l_u.html">CuSolverLU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_cu_solver_l_u.html" title="CuSolverLU solver class.">CuSolverLU</a> solver class.  <a href="class_f_e_a_t_1_1_solver_1_1_cu_solver_l_u.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_cu_solver_q_r.html">CuSolverQR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_cu_solver_q_r.html" title="CuSolverQR solver class.">CuSolverQR</a> solver class.  <a href="class_f_e_a_t_1_1_solver_1_1_cu_solver_q_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_diagonal_precond.html">DiagonalPrecond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagonal preconditioner implementation.  <a href="class_f_e_a_t_1_1_solver_1_1_diagonal_precond.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_direct_stokes_core.html">DirectStokesCore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core class for conversion of Stokes systems to CSR format for direct solvers.  <a href="class_f_e_a_t_1_1_solver_1_1_direct_stokes_core.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_direct_stokes_core_3_01_solver_d_t___00_01_solver_i_t___00_01_l_a_fba3df488bc06c314d472100c65203e90.html">DirectStokesCore&lt; SolverDT_, SolverIT_, LAFEM::SparseMatrixBCSR&lt; DT_, IT_, dim_, dim_ &gt;, LAFEM::SparseMatrixBCSR&lt; DT_, IT_, dim_, 1 &gt;, LAFEM::SparseMatrixBCSR&lt; DT_, IT_, 1, dim_ &gt;, LAFEM::SparseMatrixCSR&lt; DT_, IT_ &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core class for conversion of BCSR Stokes systems to CSR format for direct solvers.  <a href="class_f_e_a_t_1_1_solver_1_1_direct_stokes_core_3_01_solver_d_t___00_01_solver_i_t___00_01_l_a_fba3df488bc06c314d472100c65203e90.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_direct_stokes_solver.html">DirectStokesSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct Stokes solver class template.  <a href="class_f_e_a_t_1_1_solver_1_1_direct_stokes_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_direct_stokes_solver_3_01_global_1_1_matrix_3_01_local_matrix___00_12c7f8d5d38cd40f20a5510074419a06.html">DirectStokesSolver&lt; Global::Matrix&lt; LocalMatrix_, Mirror_, Mirror_ &gt;, Global::Filter&lt; LocalFilter_, Mirror_ &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct Stokes solver class for SaddlePointMatrix systems.  <a href="class_f_e_a_t_1_1_solver_1_1_direct_stokes_solver_3_01_global_1_1_matrix_3_01_local_matrix___00_12c7f8d5d38cd40f20a5510074419a06.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_direct_stokes_solver_3_01_l_a_f_e_m_1_1_saddle_point_matrix_3_01_maf2bb55a50c59e69123dfd500b5d8c62b.html">DirectStokesSolver&lt; LAFEM::SaddlePointMatrix&lt; MatrixA_, MatrixB_, MatrixD_ &gt;, LAFEM::TupleFilter&lt; FilterV_, FilterP_ &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct Stokes solver class for SaddlePointMatrix systems.  <a href="class_f_e_a_t_1_1_solver_1_1_direct_stokes_solver_3_01_l_a_f_e_m_1_1_saddle_point_matrix_3_01_maf2bb55a50c59e69123dfd500b5d8c62b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_euclid_precond.html">EuclidPrecond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">HYPRE Euclid Preconditioner Wrapper class template.  <a href="class_f_e_a_t_1_1_solver_1_1_euclid_precond.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_expression_base.html">ExpressionBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_expression_call_coarse_solver.html">ExpressionCallCoarseSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_expression_call_precond.html">ExpressionCallPrecond</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_expression_call_precond_l.html">ExpressionCallPrecondL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_expression_call_precond_r.html">ExpressionCallPrecondR</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_expression_call_smoother.html">ExpressionCallSmoother</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_expression_call_uzawa_a.html">ExpressionCallUzawaA</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_expression_call_uzawa_s.html">ExpressionCallUzawaS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_expression_defect.html">ExpressionDefect</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_expression_end_solve.html">ExpressionEndSolve</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_expression_level_timings.html">ExpressionLevelTimings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_expression_prolongation.html">ExpressionProlongation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_expression_restriction.html">ExpressionRestriction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_expression_start_solve.html">ExpressionStartSolve</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_expression_timings.html">ExpressionTimings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_f_g_m_r_e_s.html">FGMRES</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">FGMRES(k) solver implementation.  <a href="class_f_e_a_t_1_1_solver_1_1_f_g_m_r_e_s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_fixed_step_linesearch.html">FixedStepLinesearch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed step line search.  <a href="class_f_e_a_t_1_1_solver_1_1_fixed_step_linesearch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_generic_umfpack.html">GenericUmfpack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic UMFPACK solver class.  <a href="class_f_e_a_t_1_1_solver_1_1_generic_umfpack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_gropp_p_c_g.html">GroppPCG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Preconditioned) pipelined Conjugate-Gradient solver implementation from Bill Gropp  <a href="class_f_e_a_t_1_1_solver_1_1_gropp_p_c_g.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_hessian_precond.html">HessianPrecond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preconditioner that applies the inverse of an operator's Hessian.  <a href="class_f_e_a_t_1_1_solver_1_1_hessian_precond.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_hypre_solver_base.html">HypreSolverBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base-Class for solvers/preconditioners borrowed from HYPRE library.  <a href="class_f_e_a_t_1_1_solver_1_1_hypre_solver_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_i_d_r_s.html">IDRS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IDR(s) solver implementation.  <a href="class_f_e_a_t_1_1_solver_1_1_i_d_r_s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_i_l_u_precond.html">ILUPrecond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ILU(0) and ILU(p) preconditioner implementation.  <a href="class_f_e_a_t_1_1_solver_1_1_i_l_u_precond.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_i_l_u_precond_base.html">ILUPrecondBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inheritances inside <a class="el" href="ilu__precond_8hpp_source.html">ilu_precond.hpp</a>.  <a href="class_f_e_a_t_1_1_solver_1_1_i_l_u_precond_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_i_l_u_precond_with_backend.html">ILUPrecondWithBackend</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ILU(0) and ILU(p) preconditioner internal implementation.  <a href="class_f_e_a_t_1_1_solver_1_1_i_l_u_precond_with_backend.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_i_l_u_precond_with_backend_3_01_preferred_backend_1_1generic_00_01_785a361efe2523a8ba3c26ca3bd778e8.html">ILUPrecondWithBackend&lt; PreferredBackend::generic, LAFEM::SparseMatrixBCSR&lt; DT_, IT_, dim_, dim_ &gt;, Filter_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ILU(p) specialization for SparseMatrixBCSR&lt;...&gt;  <a href="class_f_e_a_t_1_1_solver_1_1_i_l_u_precond_with_backend_3_01_preferred_backend_1_1generic_00_01_785a361efe2523a8ba3c26ca3bd778e8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_i_l_u_precond_with_backend_3_01_preferred_backend_1_1generic_00_01_aed6c8770199c660f2b23c3052158c26.html">ILUPrecondWithBackend&lt; PreferredBackend::generic, LAFEM::SparseMatrixCSR&lt; DT_, IT_ &gt;, Filter_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ILU(p) specialization for SparseMatrixCSR.  <a href="class_f_e_a_t_1_1_solver_1_1_i_l_u_precond_with_backend_3_01_preferred_backend_1_1generic_00_01_aed6c8770199c660f2b23c3052158c26.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_invalid_matrix_structure_exception.html">InvalidMatrixStructureException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid Matrix structure exception.  <a href="class_f_e_a_t_1_1_solver_1_1_invalid_matrix_structure_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_iteration_stats.html">IterationStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for iteration statistics collection.  <a href="class_f_e_a_t_1_1_solver_1_1_iteration_stats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_iterative_solver.html">IterativeSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base-class for iterative solvers.  <a href="class_f_e_a_t_1_1_solver_1_1_iterative_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_jacobi_precond.html">JacobiPrecond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobi preconditioner implementation.  <a href="class_f_e_a_t_1_1_solver_1_1_jacobi_precond.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_linesearch.html">Linesearch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_linesearch.html" title="Linesearch base class.">Linesearch</a> base class.  <a href="class_f_e_a_t_1_1_solver_1_1_linesearch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_matrix_precond.html">MatrixPrecond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix preconditioner implementation.  <a href="class_f_e_a_t_1_1_solver_1_1_matrix_precond.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_m_q_c_linesearch.html">MQCLinesearch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixed quadratic-cubic line search.  <a href="class_f_e_a_t_1_1_solver_1_1_m_q_c_linesearch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_multi_grid.html">MultiGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multigrid preconditioner implementation.  <a href="class_f_e_a_t_1_1_solver_1_1_multi_grid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_multi_grid_hierarchy.html">MultiGridHierarchy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multigrid hierarchy management class template.  <a href="class_f_e_a_t_1_1_solver_1_1_multi_grid_hierarchy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_multi_grid_level_base.html">MultiGridLevelBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multigrid level base class.  <a href="class_f_e_a_t_1_1_solver_1_1_multi_grid_level_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_multi_grid_level_std.html">MultiGridLevelStd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard Multigrid level class implementation.  <a href="class_f_e_a_t_1_1_solver_1_1_multi_grid_level_std.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_newton_raphson_linesearch.html">NewtonRaphsonLinesearch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Newton Raphson linesearch.  <a href="class_f_e_a_t_1_1_solver_1_1_newton_raphson_linesearch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_c_g.html">NLCG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nonlinear Conjugate Gradient method for finding a minimum of an functional's gradient.  <a href="class_f_e_a_t_1_1_solver_1_1_n_l_c_g.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_opt_l_s.html">NLOptLS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for line search based nonlinear optimizers.  <a href="class_f_e_a_t_1_1_solver_1_1_n_l_opt_l_s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_opt_precond.html">NLOptPrecond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for preconditioners for nonlinear optimization.  <a href="class_f_e_a_t_1_1_solver_1_1_n_l_opt_precond.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_s_d.html">NLSD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nonlinear Steepest Descent method for finding a minimum of an functional's gradient.  <a href="class_f_e_a_t_1_1_solver_1_1_n_l_s_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_nonlinear_operator_precond_wrapper.html">NonlinearOperatorPrecondWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class around a (potentially nonlinear) operator.  <a href="class_f_e_a_t_1_1_solver_1_1_nonlinear_operator_precond_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_f_e_a_t_1_1_solver_1_1_optimization_test_traits.html">OptimizationTestTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class holding additional information about certain AnalyticFunction used for optimization tests.  <a href="struct_f_e_a_t_1_1_solver_1_1_optimization_test_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_para_sails_precond.html">ParaSailsPrecond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">HYPRE ParaSails Preconditioner Wrapper class template.  <a href="class_f_e_a_t_1_1_solver_1_1_para_sails_precond.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g.html">PCG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Preconditioned) Conjugate-Gradient solver implementation  <a href="class_f_e_a_t_1_1_solver_1_1_p_c_g.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g_n_r.html">PCGNR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Preconditioned) Conjugate-Gradient on Normal Equations solver implementation  <a href="class_f_e_a_t_1_1_solver_1_1_p_c_g_n_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g_n_r_i_l_u.html">PCGNRILU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ILU(p)-preconditioned Conjugate-Gradient on Normal Equations solver implementation.  <a href="class_f_e_a_t_1_1_solver_1_1_p_c_g_n_r_i_l_u.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_r.html">PCR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Preconditioned) Conjugate-Residual solver implementation  <a href="class_f_e_a_t_1_1_solver_1_1_p_c_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_pipe_p_c_g.html">PipePCG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Preconditioned) pipelined Conjugate-Gradient solver implementation from Ghysels and Vnaroose  <a href="class_f_e_a_t_1_1_solver_1_1_pipe_p_c_g.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_m_r.html">PMR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Preconditioned) Minimal-Residual-Iteration solver implementation  <a href="class_f_e_a_t_1_1_solver_1_1_p_m_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_polynomial_precond.html">PolynomialPrecond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polynomial preconditioner implementation.  <a href="class_f_e_a_t_1_1_solver_1_1_polynomial_precond.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_preconditioned_iterative_solver.html">PreconditionedIterativeSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base-class for preconditioned iterative solvers.  <a href="class_f_e_a_t_1_1_solver_1_1_preconditioned_iterative_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_precon_wrapper.html">PreconWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provisional Legacy Preconditioners Wrapper class template.  <a href="class_f_e_a_t_1_1_solver_1_1_precon_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_s_d.html">PSD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Preconditioned) Steepest-Descent solver implementation  <a href="class_f_e_a_t_1_1_solver_1_1_p_s_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_q_penalty.html">QPenalty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quadratic penalty iteration.  <a href="class_f_e_a_t_1_1_solver_1_1_q_penalty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_r_bi_c_g_stab.html">RBiCGStab</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Preconditioned) reordered <a class="el" href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab.html" title="(Preconditioned) Bi-Conjugate Gradient Stabilized solver implementation">BiCGStab</a> solver implementation  <a href="class_f_e_a_t_1_1_solver_1_1_r_bi_c_g_stab.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_r_g_c_r.html">RGCR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Preconditioned) Recycling Generalized Conjugate Residual solver implementation  <a href="class_f_e_a_t_1_1_solver_1_1_r_g_c_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_richardson.html">Richardson</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Preconditioned) <a class="el" href="class_f_e_a_t_1_1_solver_1_1_richardson.html" title="(Preconditioned) Richardson solver implementation">Richardson</a> solver implementation  <a href="class_f_e_a_t_1_1_solver_1_1_richardson.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_saddle_umfpack_mean.html">SaddleUmfpackMean</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UMFPACK Saddle-Point Mean solver class.  <a href="class_f_e_a_t_1_1_solver_1_1_saddle_umfpack_mean.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_scale_precond.html">ScalePrecond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling preconditioner class template.  <a href="class_f_e_a_t_1_1_solver_1_1_scale_precond.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_schwarz_precond.html">SchwarzPrecond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schwarz preconditioner class template declaration.  <a href="class_f_e_a_t_1_1_solver_1_1_schwarz_precond.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_schwarz_precond_3_01_global_1_1_vector_3_01_local_vector___00_01_mic9e5dece21cb7735a0bc194fb3569eb4.html">SchwarzPrecond&lt; Global::Vector&lt; LocalVector_, Mirror_ &gt;, Global::Filter&lt; LocalFilter_, Mirror_ &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schwarz preconditioner specialization for <a class="el" href="class_f_e_a_t_1_1_global_1_1_vector.html" title="Global vector wrapper class template.">Global::Vector</a>.  <a href="class_f_e_a_t_1_1_solver_1_1_schwarz_precond_3_01_global_1_1_vector_3_01_local_vector___00_01_mic9e5dece21cb7735a0bc194fb3569eb4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_secant_linesearch.html">SecantLinesearch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Secant linesearch.  <a href="class_f_e_a_t_1_1_solver_1_1_secant_linesearch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_singular_matrix_exception.html">SingularMatrixException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singular Matrix exception.  <a href="class_f_e_a_t_1_1_solver_1_1_singular_matrix_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic solver interface.  <a href="class_f_e_a_t_1_1_solver_1_1_solver_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_exception.html">SolverException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base-class for solver generated exceptions.  <a href="class_f_e_a_t_1_1_solver_1_1_solver_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_o_r_precond.html">SORPrecond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SOR preconditioner implementation.  <a href="class_f_e_a_t_1_1_solver_1_1_s_o_r_precond.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_o_r_precond_base.html">SORPrecondBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inheritances inside <a class="el" href="sor__precond_8hpp_source.html">sor_precond.hpp</a>.  <a href="class_f_e_a_t_1_1_solver_1_1_s_o_r_precond_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_o_r_precond_with_backend.html">SORPrecondWithBackend</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy class for not implemented specializations.  <a href="class_f_e_a_t_1_1_solver_1_1_s_o_r_precond_with_backend.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_o_r_precond_with_backend_3_01_preferred_backend_1_1generic_00_01_b057fb2a8d1f4c64f3e3aed2663fd10f.html">SORPrecondWithBackend&lt; PreferredBackend::generic, LAFEM::SparseMatrixBCSR&lt; DT_, IT_, BlockHeight_, BlockWidth_ &gt;, Filter_ &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_o_r_precond_with_backend_3_01_preferred_backend_1_1generic_00_01_b01c4c6795db9d1026723694e15647be.html">SORPrecondWithBackend&lt; PreferredBackend::generic, LAFEM::SparseMatrixCSR&lt; DT_, IT_ &gt;, Filter_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SOR preconditioner internal implementation.  <a href="class_f_e_a_t_1_1_solver_1_1_s_o_r_precond_with_backend_3_01_preferred_backend_1_1generic_00_01_b01c4c6795db9d1026723694e15647be.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_s_o_r_precond.html">SSORPrecond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSOR preconditioner implementation.  <a href="class_f_e_a_t_1_1_solver_1_1_s_s_o_r_precond.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_s_o_r_precond_base.html">SSORPrecondBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inheritances inside <a class="el" href="sor__precond_8hpp_source.html">sor_precond.hpp</a>.  <a href="class_f_e_a_t_1_1_solver_1_1_s_s_o_r_precond_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_s_o_r_precond_with_backend.html">SSORPrecondWithBackend</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy class for not implemented specializations.  <a href="class_f_e_a_t_1_1_solver_1_1_s_s_o_r_precond_with_backend.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_s_o_r_precond_with_backend_3_01_preferred_backend_1_1generic_00_03cc9221468c00ec17113383d091b5dfc.html">SSORPrecondWithBackend&lt; PreferredBackend::generic, LAFEM::SparseMatrixBCSR&lt; DT_, IT_, BlockHeight_, BlockWidth_ &gt;, Filter_ &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_s_o_r_precond_with_backend_3_01_preferred_backend_1_1generic_00_09cdd27baeeaa7c4869529b76c2c5d109.html">SSORPrecondWithBackend&lt; PreferredBackend::generic, LAFEM::SparseMatrixCSR&lt; DT_, IT_ &gt;, Filter_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSOR preconditioner internal implementation.  <a href="class_f_e_a_t_1_1_solver_1_1_s_s_o_r_precond_with_backend_3_01_preferred_backend_1_1generic_00_09cdd27baeeaa7c4869529b76c2c5d109.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_super_l_u.html">SuperLU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(distributed) <a class="el" href="class_f_e_a_t_1_1_solver_1_1_super_l_u.html" title="(distributed) SuperLU direct sparse solver">SuperLU</a> direct sparse solver  <a href="class_f_e_a_t_1_1_solver_1_1_super_l_u.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_umfpack.html">Umfpack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UMFPACK solver class.  <a href="class_f_e_a_t_1_1_solver_1_1_umfpack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_umfpack_mean.html">UmfpackMean</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UMFPACK Mean solver class.  <a href="class_f_e_a_t_1_1_solver_1_1_umfpack_mean.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_uzawa_precond.html">UzawaPrecond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uzawa preconditioner.  <a href="class_f_e_a_t_1_1_solver_1_1_uzawa_precond.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_uzawa_precond_3_01_global_1_1_matrix_3_01_matrix_a___00_01_mirror_v267746ef0d8b831732ecfa70b7d32300.html">UzawaPrecond&lt; Global::Matrix&lt; MatrixA_, MirrorV_, MirrorV_ &gt;, Global::Matrix&lt; MatrixB_, MirrorV_, MirrorP_ &gt;, Global::Matrix&lt; MatrixD_, MirrorP_, MirrorV_ &gt;, Global::Filter&lt; FilterV_, MirrorV_ &gt;, Global::Filter&lt; FilterP_, MirrorP_ &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_uzawa_precond.html" title="Uzawa preconditioner.">UzawaPrecond</a> specialization for <a class="el" href="namespace_f_e_a_t_1_1_global.html" title="Global linear algebra namespace.">Global</a> matrices.  <a href="class_f_e_a_t_1_1_solver_1_1_uzawa_precond_3_01_global_1_1_matrix_3_01_matrix_a___00_01_mirror_v267746ef0d8b831732ecfa70b7d32300.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_vanka.html">Vanka</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_vanka.html" title="Vanka preconditioner/smoother class template.">Vanka</a> preconditioner/smoother class template.  <a href="class_f_e_a_t_1_1_solver_1_1_vanka.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_vanka_3_01_l_a_f_e_m_1_1_saddle_point_matrix_3_01_matrix_a___00_01_9ced3bd73ff865688c51cd8e1ad52f3a.html">Vanka&lt; LAFEM::SaddlePointMatrix&lt; MatrixA_, MatrixB_, MatrixD_ &gt;, Filter_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_vanka.html" title="Vanka preconditioner/smoother class template.">Vanka</a> preconditioner/smoother class template implementation.  <a href="class_f_e_a_t_1_1_solver_1_1_vanka_3_01_l_a_f_e_m_1_1_saddle_point_matrix_3_01_matrix_a___00_01_9ced3bd73ff865688c51cd8e1ad52f3a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_vanka_factor_error.html">VankaFactorError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_vanka.html" title="Vanka preconditioner/smoother class template.">Vanka</a> Factorization Error.  <a href="class_f_e_a_t_1_1_solver_1_1_vanka_factor_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ab3701336d3327b2a233a089c5ae17ef7"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab3701336d3327b2a233a089c5ae17ef7">BiCGStabLPreconVariant</a> { <b>left</b>
, <b>right</b>
 }</td></tr>
<tr class="memdesc:ab3701336d3327b2a233a089c5ae17ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for diffent preconditioning variants for BiCGStabL.  <a href="namespace_f_e_a_t_1_1_solver.html#ab3701336d3327b2a233a089c5ae17ef7">More...</a><br /></td></tr>
<tr class="separator:ab3701336d3327b2a233a089c5ae17ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84303e5a9eeeb8bd47fb8e76c3d3694e"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a84303e5a9eeeb8bd47fb8e76c3d3694e">BiCGStabPreconVariant</a> { <b>left</b>
, <b>right</b>
 }</td></tr>
<tr class="memdesc:a84303e5a9eeeb8bd47fb8e76c3d3694e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for different preconditioning variants for BiCGStab.  <a href="namespace_f_e_a_t_1_1_solver.html#a84303e5a9eeeb8bd47fb8e76c3d3694e">More...</a><br /></td></tr>
<tr class="separator:a84303e5a9eeeb8bd47fb8e76c3d3694e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e1a0d5d6876f6d4fe16f71003b257c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#aa3e1a0d5d6876f6d4fe16f71003b257c">ExpressionType</a> { <br />
&#160;&#160;<a class="el" href="namespace_f_e_a_t_1_1_solver.html#aa3e1a0d5d6876f6d4fe16f71003b257cadbb68c86754ccad2ee2908a92f34d3e4">start_solve</a> = 0
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#aa3e1a0d5d6876f6d4fe16f71003b257ca43355c9ca3b3625921863fbb1d7a6125">end_solve</a>
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#aa3e1a0d5d6876f6d4fe16f71003b257caced4c9c427983093e246d4489b774883">call_precond</a>
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#aa3e1a0d5d6876f6d4fe16f71003b257ca4c8125346940e0b89395bbea04351a3d">call_precond_l</a>
, <br />
&#160;&#160;<a class="el" href="namespace_f_e_a_t_1_1_solver.html#aa3e1a0d5d6876f6d4fe16f71003b257cabf7f509bcd748b9cbd4199fd1b632e3d">call_precond_r</a>
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#aa3e1a0d5d6876f6d4fe16f71003b257caa3cad12e93c7ff67dd8d0e96cfe69f25">call_smoother</a>
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#aa3e1a0d5d6876f6d4fe16f71003b257ca7bd4df8d10de98c0e1a2ad102544e985">call_coarse_solver</a>
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#aa3e1a0d5d6876f6d4fe16f71003b257ca6475f0c19ab92149df68660d6be44562">defect</a>
, <br />
&#160;&#160;<a class="el" href="namespace_f_e_a_t_1_1_solver.html#aa3e1a0d5d6876f6d4fe16f71003b257ca215c68ef0f50ad9d15cedfdc1f5d2e73">timings</a>
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#aa3e1a0d5d6876f6d4fe16f71003b257cacb59b105810592a9797b58f0af69d178">level_timings</a>
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#aa3e1a0d5d6876f6d4fe16f71003b257ca39f507840263ff9a6dec828feac5e180">prol</a>
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#aa3e1a0d5d6876f6d4fe16f71003b257ca65e8800b5c6800aad896f888b2a62afc">rest</a>
, <br />
&#160;&#160;<a class="el" href="namespace_f_e_a_t_1_1_solver.html#aa3e1a0d5d6876f6d4fe16f71003b257ca763e460c228fa243e8e179114dd649bd">call_uzawa_s</a>
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#aa3e1a0d5d6876f6d4fe16f71003b257ca2ed022f43272bfb055f81b2b900b5163">call_uzawa_a</a>
<br />
 }</td></tr>
<tr class="memdesc:aa3e1a0d5d6876f6d4fe16f71003b257c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression Type enumeration.  <a href="namespace_f_e_a_t_1_1_solver.html#aa3e1a0d5d6876f6d4fe16f71003b257c">More...</a><br /></td></tr>
<tr class="separator:aa3e1a0d5d6876f6d4fe16f71003b257c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7f089c4ca7981d407aa7a7038f6e23"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a9d7f089c4ca7981d407aa7a7038f6e23">MultiGridAdaptCGC</a> { <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a9d7f089c4ca7981d407aa7a7038f6e23a4457d440870ad6d42bab9082d9bf9b61">Fixed</a>
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a9d7f089c4ca7981d407aa7a7038f6e23ae2ff515050bfd1fe926c0c1f3764dc45">MinEnergy</a>
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a9d7f089c4ca7981d407aa7a7038f6e23a4e8e2d409757b43a89e7e03a70f34b54">MinDefect</a>
 }</td></tr>
<tr class="memdesc:a9d7f089c4ca7981d407aa7a7038f6e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multigrid adaptive Coarse-Grid-Correction enumeration.  <a href="namespace_f_e_a_t_1_1_solver.html#a9d7f089c4ca7981d407aa7a7038f6e23">More...</a><br /></td></tr>
<tr class="separator:a9d7f089c4ca7981d407aa7a7038f6e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b14b494b949c5eecc622f4ad6e2d59b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a5b14b494b949c5eecc622f4ad6e2d59b">MultiGridCycle</a> { <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a5b14b494b949c5eecc622f4ad6e2d59ba5206560a306a2e085a437fd258eb57ce">V</a>
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a5b14b494b949c5eecc622f4ad6e2d59ba800618943025315f869e4e1f09471012">F</a>
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a5b14b494b949c5eecc622f4ad6e2d59ba61e9c06ea9a85a5088a499df6458d276">W</a>
 }</td></tr>
<tr class="memdesc:a5b14b494b949c5eecc622f4ad6e2d59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multigrid Cycle enumeration.  <a href="namespace_f_e_a_t_1_1_solver.html#a5b14b494b949c5eecc622f4ad6e2d59b">More...</a><br /></td></tr>
<tr class="separator:a5b14b494b949c5eecc622f4ad6e2d59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651714c882641671d73d78382d7d77ee"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a651714c882641671d73d78382d7d77ee">NLCGDirectionUpdate</a> { <br />
&#160;&#160;<b>undefined</b> = 0
, <b>DaiYuan</b>
, <b>DYHSHybrid</b>
, <b>FletcherReeves</b>
, <br />
&#160;&#160;<b>HagerZhang</b>
, <b>HestenesStiefel</b>
, <b>PolakRibiere</b>
<br />
 }</td></tr>
<tr class="memdesc:a651714c882641671d73d78382d7d77ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for NLCG search direction updates.  <a href="namespace_f_e_a_t_1_1_solver.html#a651714c882641671d73d78382d7d77ee">More...</a><br /></td></tr>
<tr class="separator:a651714c882641671d73d78382d7d77ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892c0210316c5cb1cf89035147242c36"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a892c0210316c5cb1cf89035147242c36">PlotMode</a> { <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a892c0210316c5cb1cf89035147242c36a334c4a4c42fdb79d7ebc3e73b517e6f8">none</a> = 0
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a892c0210316c5cb1cf89035147242c36a37302ccecb8ae11c64170bc6bfa44eaa">iter</a>
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a892c0210316c5cb1cf89035147242c36aa80da1282f2c775bbc5f2c92c836968b">summary</a>
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a892c0210316c5cb1cf89035147242c36aa181a603769c1f98ad927e7367c7aa51">all</a>
 }</td></tr>
<tr class="memdesc:a892c0210316c5cb1cf89035147242c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver plot modes enumeration.  <a href="namespace_f_e_a_t_1_1_solver.html#a892c0210316c5cb1cf89035147242c36">More...</a><br /></td></tr>
<tr class="separator:a892c0210316c5cb1cf89035147242c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c941bc4fb3a678ef08e84cd3fa35ed"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab1c941bc4fb3a678ef08e84cd3fa35ed">Status</a> { <br />
&#160;&#160;<a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab1c941bc4fb3a678ef08e84cd3fa35eda5e543256c480ac577d30f76f9120eb74">undefined</a> = 0
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab1c941bc4fb3a678ef08e84cd3fa35eda3c709b10a5d47ba33d85337dd9110917">progress</a>
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab1c941bc4fb3a678ef08e84cd3fa35eda260ca9dd8a4577fc00b7bd5810298076">success</a>
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab1c941bc4fb3a678ef08e84cd3fa35edadfb7069bfc6e0064a6c667626eca07b4">aborted</a>
, <br />
&#160;&#160;<a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab1c941bc4fb3a678ef08e84cd3fa35edadb5a93fff259ad3ff2017a64912fa156">diverged</a>
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab1c941bc4fb3a678ef08e84cd3fa35edaa520882cd714abbd1bf9f72d23990f0e">max_iter</a>
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab1c941bc4fb3a678ef08e84cd3fa35edaa3d1e0a7dd736bc430ba471d9dfdf3a2">stagnated</a>
<br />
 }</td></tr>
<tr class="memdesc:ab1c941bc4fb3a678ef08e84cd3fa35ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver status return codes enumeration.  <a href="namespace_f_e_a_t_1_1_solver.html#ab1c941bc4fb3a678ef08e84cd3fa35ed">More...</a><br /></td></tr>
<tr class="separator:ab1c941bc4fb3a678ef08e84cd3fa35ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9301b94ea72379786a83666a86c4ff"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a8c9301b94ea72379786a83666a86c4ff">UzawaType</a> { <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a8c9301b94ea72379786a83666a86c4ffaa0e17e2709a0404ae3d7de03b8ea9093">diagonal</a>
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a8c9301b94ea72379786a83666a86c4ffa81e073b428b50247daba38531dcf412a">lower</a>
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a8c9301b94ea72379786a83666a86c4ffa0122b4c2c01ee1c698ecc309d2b8eb5a">upper</a>
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a8c9301b94ea72379786a83666a86c4ffae9dc924f238fa6cc29465942875fe8f0">full</a>
 }</td></tr>
<tr class="memdesc:a8c9301b94ea72379786a83666a86c4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uzawa preconditioner type.  <a href="namespace_f_e_a_t_1_1_solver.html#a8c9301b94ea72379786a83666a86c4ff">More...</a><br /></td></tr>
<tr class="separator:a8c9301b94ea72379786a83666a86c4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a1737a447bf0816faf68de552c2064"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a56a1737a447bf0816faf68de552c2064">VankaType</a> { <br />
&#160;&#160;<a class="el" href="namespace_f_e_a_t_1_1_solver.html#a56a1737a447bf0816faf68de552c2064ac5727c4f02effaecdb0ff7e5356e6beb">nodal_diag_mult</a> = 0x000
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a56a1737a447bf0816faf68de552c2064a2781aeb6fbdf11b921a8f6432e669255">nodal_full_mult</a> = 0x001
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a56a1737a447bf0816faf68de552c2064ac14d2f1f2526ae3542b6c4f0f83ca91d">block_diag_mult</a> = 0x010
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a56a1737a447bf0816faf68de552c2064ac5ac3da34cdc11a0ca495ac901f9bde6">block_full_mult</a> = 0x011
, <br />
&#160;&#160;<a class="el" href="namespace_f_e_a_t_1_1_solver.html#a56a1737a447bf0816faf68de552c2064ad3ed8ab1ba34fa91bcb2988fb8a7da12">nodal_diag_add</a> = 0x100
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a56a1737a447bf0816faf68de552c2064a66880c35558978d1aee7b9bef14d1d25">nodal_full_add</a> = 0x101
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a56a1737a447bf0816faf68de552c2064a411b83f39a65b8bad2c5f914c20ebd8d">block_diag_add</a> = 0x110
, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a56a1737a447bf0816faf68de552c2064af88ce1fb8b7ece17b0f496a2eb5d712d">block_full_add</a> = 0x111
<br />
 }</td></tr>
<tr class="memdesc:a56a1737a447bf0816faf68de552c2064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vanka type enumeration.  <a href="namespace_f_e_a_t_1_1_solver.html#a56a1737a447bf0816faf68de552c2064">More...</a><br /></td></tr>
<tr class="separator:a56a1737a447bf0816faf68de552c2064"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a50bd05e5f49c4291c2e0fc0240855c68"><td class="memTemplParams" colspan="2">template&lt;typename Functional_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a50bd05e5f49c4291c2e0fc0240855c68"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_l_g_l_i_b_min_c_g.html">ALGLIBMinCG</a>&lt; Functional_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a50bd05e5f49c4291c2e0fc0240855c68">new_alglib_mincg</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, Functional_ &amp;functional_, Filter_ &amp;filter_)</td></tr>
<tr class="memdesc:a50bd05e5f49c4291c2e0fc0240855c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_l_g_l_i_b_min_c_g.html" title="Wrapper around ALGLIB&#39;s mincg implementation for minimising an functional&#39;s gradient.">ALGLIBMinCG</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#a50bd05e5f49c4291c2e0fc0240855c68">More...</a><br /></td></tr>
<tr class="separator:a50bd05e5f49c4291c2e0fc0240855c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac682c52ad4f336c00562ac658d88befa"><td class="memTemplParams" colspan="2">template&lt;typename Functional_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:ac682c52ad4f336c00562ac658d88befa"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_l_g_l_i_b_min_c_g.html">ALGLIBMinCG</a>&lt; Functional_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ac682c52ad4f336c00562ac658d88befa">new_alglib_mincg</a> (Functional_ &amp;functional_, Filter_ &amp;filter_, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a651714c882641671d73d78382d7d77ee">NLCGDirectionUpdate</a> du_=<a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_l_g_l_i_b_min_c_g.html">ALGLIBMinCG</a>&lt; Functional_, Filter_ &gt;::direction_update_default, bool keep_iterates_=false)</td></tr>
<tr class="memdesc:ac682c52ad4f336c00562ac658d88befa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_l_g_l_i_b_min_c_g.html" title="Wrapper around ALGLIB&#39;s mincg implementation for minimising an functional&#39;s gradient.">ALGLIBMinCG</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#ac682c52ad4f336c00562ac658d88befa">More...</a><br /></td></tr>
<tr class="separator:ac682c52ad4f336c00562ac658d88befa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656a192b898ddc23ffb9072b9955b2ab"><td class="memTemplParams" colspan="2">template&lt;typename Functional_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a656a192b898ddc23ffb9072b9955b2ab"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_l_g_l_i_b_min_l_b_f_g_s.html">ALGLIBMinLBFGS</a>&lt; Functional_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a656a192b898ddc23ffb9072b9955b2ab">new_alglib_minlbfgs</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, Functional_ &amp;functional_, Filter_ &amp;filter_)</td></tr>
<tr class="memdesc:a656a192b898ddc23ffb9072b9955b2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_l_g_l_i_b_min_l_b_f_g_s.html" title="Wrapper around ALGLIB&#39;s lBFGS implementation for minimising an functional&#39;s gradient.">ALGLIBMinLBFGS</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#a656a192b898ddc23ffb9072b9955b2ab">More...</a><br /></td></tr>
<tr class="separator:a656a192b898ddc23ffb9072b9955b2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab9653730c87172104d5178417d8fa1"><td class="memTemplParams" colspan="2">template&lt;typename Functional_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:adab9653730c87172104d5178417d8fa1"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_l_g_l_i_b_min_l_b_f_g_s.html">ALGLIBMinLBFGS</a>&lt; Functional_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#adab9653730c87172104d5178417d8fa1">new_alglib_minlbfgs</a> (Functional_ &amp;functional_, Filter_ &amp;filter_, alglib::ae_int_t lbfgs_dim_=alglib::ae_int_t(0), bool keep_iterates=false)</td></tr>
<tr class="memdesc:adab9653730c87172104d5178417d8fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_l_g_l_i_b_min_l_b_f_g_s.html" title="Wrapper around ALGLIB&#39;s lBFGS implementation for minimising an functional&#39;s gradient.">ALGLIBMinLBFGS</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#adab9653730c87172104d5178417d8fa1">More...</a><br /></td></tr>
<tr class="separator:adab9653730c87172104d5178417d8fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642dd4bca070c87b0531f9f57ed11069"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a642dd4bca070c87b0531f9f57ed11069"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_ama_vanka.html">AmaVanka</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a642dd4bca070c87b0531f9f57ed11069">new_amavanka</a> (const Matrix_ &amp;matrix, const Filter_ &amp;filter, typename Matrix_::DataType omega=typename Matrix_::DataType(1), <a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1">Index</a> num_steps=<a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1">Index</a>(1))</td></tr>
<tr class="memdesc:a642dd4bca070c87b0531f9f57ed11069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_ama_vanka.html" title="Additive Macro-wise Matrix-based Vanka preconditioner/smoother.">AmaVanka</a> smoother object.  <a href="namespace_f_e_a_t_1_1_solver.html#a642dd4bca070c87b0531f9f57ed11069">More...</a><br /></td></tr>
<tr class="separator:a642dd4bca070c87b0531f9f57ed11069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af040d5ae2582eca39ae5831872f44e1b"><td class="memTemplParams" colspan="2">template&lt;typename Operator_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:af040d5ae2582eca39ae5831872f44e1b"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_approximate_hessian_precond.html">ApproximateHessianPrecond</a>&lt; Operator_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#af040d5ae2582eca39ae5831872f44e1b">new_approximate_hessian_precond</a> (Operator_ &amp;op_, const Filter_ &amp;filter_)</td></tr>
<tr class="memdesc:af040d5ae2582eca39ae5831872f44e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_approximate_hessian_precond.html" title="Wrapper class for applying an the inverse of an operator&#39;s approximate Hessian as a preconditioner.">ApproximateHessianPrecond</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#af040d5ae2582eca39ae5831872f44e1b">More...</a><br /></td></tr>
<tr class="separator:af040d5ae2582eca39ae5831872f44e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f083d0e11b367f7f641ca58444b0c1"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:af9f083d0e11b367f7f641ca58444b0c1"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab.html">BiCGStab</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#af9f083d0e11b367f7f641ca58444b0c1">new_bicgstab</a> (const Matrix_ &amp;matrix, const Filter_ &amp;filter, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond=nullptr, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a84303e5a9eeeb8bd47fb8e76c3d3694e">BiCGStabPreconVariant</a> precon_variant=BiCGStabPreconVariant::left)</td></tr>
<tr class="memdesc:af9f083d0e11b367f7f641ca58444b0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab.html" title="(Preconditioned) Bi-Conjugate Gradient Stabilized solver implementation">BiCGStab</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#af9f083d0e11b367f7f641ca58444b0c1">More...</a><br /></td></tr>
<tr class="separator:af9f083d0e11b367f7f641ca58444b0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad833f82ef1acd6563102f35b88d97cca"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:ad833f82ef1acd6563102f35b88d97cca"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab.html">BiCGStab</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ad833f82ef1acd6563102f35b88d97cca">new_bicgstab</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, const Matrix_ &amp;matrix, const Filter_ &amp;filter, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:ad833f82ef1acd6563102f35b88d97cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab.html" title="(Preconditioned) Bi-Conjugate Gradient Stabilized solver implementation">BiCGStab</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#ad833f82ef1acd6563102f35b88d97cca">More...</a><br /></td></tr>
<tr class="separator:ad833f82ef1acd6563102f35b88d97cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b6a7252514b9db0b37b26ad86e69c5"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a88b6a7252514b9db0b37b26ad86e69c5"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab_l.html">BiCGStabL</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a88b6a7252514b9db0b37b26ad86e69c5">new_bicgstabl</a> (const Matrix_ &amp;matrix, const Filter_ &amp;filter, int l=2, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond=nullptr, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab3701336d3327b2a233a089c5ae17ef7">BiCGStabLPreconVariant</a> precon_variant=BiCGStabLPreconVariant::left)</td></tr>
<tr class="memdesc:a88b6a7252514b9db0b37b26ad86e69c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab_l.html" title="(Preconditioned) BiCGStab(l) solver implementation">BiCGStabL</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#a88b6a7252514b9db0b37b26ad86e69c5">More...</a><br /></td></tr>
<tr class="separator:a88b6a7252514b9db0b37b26ad86e69c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564c8ccff6d85a840fd5b031a653cf34"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a564c8ccff6d85a840fd5b031a653cf34"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab_l.html">BiCGStabL</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a564c8ccff6d85a840fd5b031a653cf34">new_bicgstabl</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, const Matrix_ &amp;matrix, const Filter_ &amp;filter, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:a564c8ccff6d85a840fd5b031a653cf34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab_l.html" title="(Preconditioned) BiCGStab(l) solver implementation">BiCGStabL</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#a564c8ccff6d85a840fd5b031a653cf34">More...</a><br /></td></tr>
<tr class="separator:a564c8ccff6d85a840fd5b031a653cf34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386da687e0d991327e251fa41064dd33"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a386da687e0d991327e251fa41064dd33"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_boomer_a_m_g.html">BoomerAMG</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a386da687e0d991327e251fa41064dd33">new_boomeramg</a> (const Matrix_ &amp;matrix, const Filter_ &amp;filter)</td></tr>
<tr class="memdesc:a386da687e0d991327e251fa41064dd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_boomer_a_m_g.html" title="HYPRE BoomerAMGWrapper class template.">BoomerAMG</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#a386da687e0d991327e251fa41064dd33">More...</a><br /></td></tr>
<tr class="separator:a386da687e0d991327e251fa41064dd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfffc0ea6d657ce58cc09e6e989f402"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:aecfffc0ea6d657ce58cc09e6e989f402"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_boomer_a_m_g.html">BoomerAMG</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#aecfffc0ea6d657ce58cc09e6e989f402">new_boomeramg</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, const Matrix_ &amp;matrix, const Filter_ &amp;filter)</td></tr>
<tr class="memdesc:aecfffc0ea6d657ce58cc09e6e989f402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_boomer_a_m_g.html" title="HYPRE BoomerAMGWrapper class template.">BoomerAMG</a> solver object based on a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#aecfffc0ea6d657ce58cc09e6e989f402">More...</a><br /></td></tr>
<tr class="separator:aecfffc0ea6d657ce58cc09e6e989f402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0bace005bd07bdb36846a5237b665e"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a9c0bace005bd07bdb36846a5237b665e"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_chebyshev.html">Chebyshev</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a9c0bace005bd07bdb36846a5237b665e">new_chebyshev</a> (const Matrix_ &amp;matrix, const Filter_ &amp;filter, const typename Matrix_::DataType fraction_min_ev=typename Matrix_::DataType(0.03), const typename Matrix_::DataType fraction_max_ev=typename Matrix_::DataType(1.1))</td></tr>
<tr class="memdesc:a9c0bace005bd07bdb36846a5237b665e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_chebyshev.html" title="Chebyshev Polynomial implementation.">Chebyshev</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#a9c0bace005bd07bdb36846a5237b665e">More...</a><br /></td></tr>
<tr class="separator:a9c0bace005bd07bdb36846a5237b665e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7434b5f21c02503d0309f97f54c9112"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:ac7434b5f21c02503d0309f97f54c9112"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_chebyshev.html">Chebyshev</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ac7434b5f21c02503d0309f97f54c9112">new_chebyshev</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, const Matrix_ &amp;matrix, const Filter_ &amp;filter)</td></tr>
<tr class="memdesc:ac7434b5f21c02503d0309f97f54c9112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_chebyshev.html" title="Chebyshev Polynomial implementation.">Chebyshev</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#ac7434b5f21c02503d0309f97f54c9112">More...</a><br /></td></tr>
<tr class="separator:ac7434b5f21c02503d0309f97f54c9112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0226c89d9b7912c73ec8ed13450c18"><td class="memTemplParams" colspan="2">template&lt;typename LocalVectorOuter_ , typename LocalVectorInner_ , typename MirrorOuter_ , typename MirrorInner_ &gt; </td></tr>
<tr class="memitem:aac0226c89d9b7912c73ec8ed13450c18"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_convert_precond.html">ConvertPrecond</a>&lt; <a class="el" href="class_f_e_a_t_1_1_global_1_1_vector.html">Global::Vector</a>&lt; LocalVectorOuter_, MirrorOuter_ &gt;, <a class="el" href="class_f_e_a_t_1_1_global_1_1_vector.html">Global::Vector</a>&lt; LocalVectorInner_, MirrorInner_ &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#aac0226c89d9b7912c73ec8ed13450c18">new_convert_precond</a> (std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; <a class="el" href="class_f_e_a_t_1_1_global_1_1_vector.html">Global::Vector</a>&lt; LocalVectorInner_, MirrorInner_ &gt; &gt; &gt; inner_solver)</td></tr>
<tr class="memdesc:aac0226c89d9b7912c73ec8ed13450c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_convert_precond.html" title="Solver conversion module.">ConvertPrecond</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#aac0226c89d9b7912c73ec8ed13450c18">More...</a><br /></td></tr>
<tr class="separator:aac0226c89d9b7912c73ec8ed13450c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e33f7df9dd68f704b6186ca69e39b5"><td class="memTemplParams" colspan="2">template&lt;typename VectorOuter_ , typename VectorInner_ &gt; </td></tr>
<tr class="memitem:a52e33f7df9dd68f704b6186ca69e39b5"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_convert_precond.html">ConvertPrecond</a>&lt; VectorOuter_, VectorInner_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a52e33f7df9dd68f704b6186ca69e39b5">new_convert_precond</a> (std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; VectorInner_ &gt; &gt; inner_solver)</td></tr>
<tr class="memdesc:a52e33f7df9dd68f704b6186ca69e39b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_convert_precond.html" title="Solver conversion module.">ConvertPrecond</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#a52e33f7df9dd68f704b6186ca69e39b5">More...</a><br /></td></tr>
<tr class="separator:a52e33f7df9dd68f704b6186ca69e39b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59dbf0d9ce0d9135831f99f54ee6fd53"><td class="memTemplParams" colspan="2">template&lt;typename Vector_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a59dbf0d9ce0d9135831f99f54ee6fd53"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_diagonal_precond.html">DiagonalPrecond</a>&lt; Vector_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a59dbf0d9ce0d9135831f99f54ee6fd53">new_diagonal_precond</a> (const Vector_ &amp;diag, const Filter_ &amp;filter)</td></tr>
<tr class="memdesc:a59dbf0d9ce0d9135831f99f54ee6fd53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_diagonal_precond.html" title="Diagonal preconditioner implementation.">DiagonalPrecond</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#a59dbf0d9ce0d9135831f99f54ee6fd53">More...</a><br /></td></tr>
<tr class="separator:a59dbf0d9ce0d9135831f99f54ee6fd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1710fb7ef4e77aa3d2407b1b2c118d2e"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a1710fb7ef4e77aa3d2407b1b2c118d2e"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_direct_stokes_solver.html">DirectStokesSolver</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a1710fb7ef4e77aa3d2407b1b2c118d2e">new_direct_stokes_solver</a> (const Matrix_ &amp;matrix, const Filter_ &amp;filter)</td></tr>
<tr class="memdesc:a1710fb7ef4e77aa3d2407b1b2c118d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_direct_stokes_solver.html" title="Direct Stokes solver class template.">DirectStokesSolver</a> object.  <a href="namespace_f_e_a_t_1_1_solver.html#a1710fb7ef4e77aa3d2407b1b2c118d2e">More...</a><br /></td></tr>
<tr class="separator:a1710fb7ef4e77aa3d2407b1b2c118d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed20d38330cb0b55f3a02ac3163002f"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a0ed20d38330cb0b55f3a02ac3163002f"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_euclid_precond.html">EuclidPrecond</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a0ed20d38330cb0b55f3a02ac3163002f">new_euclid_precond</a> (const Matrix_ &amp;matrix, const Filter_ &amp;filter)</td></tr>
<tr class="memdesc:a0ed20d38330cb0b55f3a02ac3163002f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_euclid_precond.html" title="HYPRE Euclid Preconditioner Wrapper class template.">EuclidPrecond</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#a0ed20d38330cb0b55f3a02ac3163002f">More...</a><br /></td></tr>
<tr class="separator:a0ed20d38330cb0b55f3a02ac3163002f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e0c5a93d63bfa65939ba63207d6f96"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:aa2e0c5a93d63bfa65939ba63207d6f96"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_euclid_precond.html">EuclidPrecond</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#aa2e0c5a93d63bfa65939ba63207d6f96">new_euclid_precond</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, const Matrix_ &amp;matrix, const Filter_ &amp;filter)</td></tr>
<tr class="memdesc:aa2e0c5a93d63bfa65939ba63207d6f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_euclid_precond.html" title="HYPRE Euclid Preconditioner Wrapper class template.">EuclidPrecond</a> solver object based on a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#aa2e0c5a93d63bfa65939ba63207d6f96">More...</a><br /></td></tr>
<tr class="separator:aa2e0c5a93d63bfa65939ba63207d6f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843ed4e3dfe8f61203e8e99704f51e89"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a843ed4e3dfe8f61203e8e99704f51e89"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_f_g_m_r_e_s.html">FGMRES</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a843ed4e3dfe8f61203e8e99704f51e89">new_fgmres</a> (const Matrix_ &amp;matrix, const Filter_ &amp;filter, <a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1">Index</a> krylov_dim, typename Matrix_::DataType inner_res_scale=typename Matrix_::DataType(0), std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:a843ed4e3dfe8f61203e8e99704f51e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_f_g_m_r_e_s.html" title="FGMRES(k) solver implementation.">FGMRES</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#a843ed4e3dfe8f61203e8e99704f51e89">More...</a><br /></td></tr>
<tr class="separator:a843ed4e3dfe8f61203e8e99704f51e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6299391b80470e4556a349ae3459c0"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:ade6299391b80470e4556a349ae3459c0"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_f_g_m_r_e_s.html">FGMRES</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ade6299391b80470e4556a349ae3459c0">new_fgmres</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, const Matrix_ &amp;matrix, const Filter_ &amp;filter, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:ade6299391b80470e4556a349ae3459c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_f_g_m_r_e_s.html" title="FGMRES(k) solver implementation.">FGMRES</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#ade6299391b80470e4556a349ae3459c0">More...</a><br /></td></tr>
<tr class="separator:ade6299391b80470e4556a349ae3459c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac02e6292a2187cc2ff867856e3d2e2"><td class="memTemplParams" colspan="2">template&lt;typename Functional_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a2ac02e6292a2187cc2ff867856e3d2e2"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_fixed_step_linesearch.html">FixedStepLinesearch</a>&lt; Functional_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a2ac02e6292a2187cc2ff867856e3d2e2">new_fixed_step_linesearch</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, Functional_ &amp;functional, Filter_ &amp;filter)</td></tr>
<tr class="memdesc:a2ac02e6292a2187cc2ff867856e3d2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_fixed_step_linesearch.html" title="Fixed step line search.">FixedStepLinesearch</a> object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#a2ac02e6292a2187cc2ff867856e3d2e2">More...</a><br /></td></tr>
<tr class="separator:a2ac02e6292a2187cc2ff867856e3d2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788f4cc3fe220df0a7093f1f02fb58e7"><td class="memTemplParams" colspan="2">template&lt;typename Functional_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a788f4cc3fe220df0a7093f1f02fb58e7"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_fixed_step_linesearch.html">FixedStepLinesearch</a>&lt; Functional_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a788f4cc3fe220df0a7093f1f02fb58e7">new_fixed_step_linesearch</a> (Functional_ &amp;functional, Filter_ &amp;filter, typename Functional_::DataType step_length, bool keep_iterates=false)</td></tr>
<tr class="memdesc:a788f4cc3fe220df0a7093f1f02fb58e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_fixed_step_linesearch.html" title="Fixed step line search.">FixedStepLinesearch</a> object.  <a href="namespace_f_e_a_t_1_1_solver.html#a788f4cc3fe220df0a7093f1f02fb58e7">More...</a><br /></td></tr>
<tr class="separator:a788f4cc3fe220df0a7093f1f02fb58e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac261a767b52c9326b2ed02d10fe4aec"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ &gt; </td></tr>
<tr class="memitem:aac261a767b52c9326b2ed02d10fe4aec"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_generic_umfpack.html">GenericUmfpack</a>&lt; Matrix_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#aac261a767b52c9326b2ed02d10fe4aec">new_generic_umfpack</a> (const Matrix_ &amp;matrix)</td></tr>
<tr class="memdesc:aac261a767b52c9326b2ed02d10fe4aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_generic_umfpack.html" title="Generic UMFPACK solver class.">GenericUmfpack</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#aac261a767b52c9326b2ed02d10fe4aec">More...</a><br /></td></tr>
<tr class="separator:aac261a767b52c9326b2ed02d10fe4aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0af5b9e827d08f7d923528cc679609c"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:ae0af5b9e827d08f7d923528cc679609c"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_gropp_p_c_g.html">GroppPCG</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ae0af5b9e827d08f7d923528cc679609c">new_gropppcg</a> (const Matrix_ &amp;matrix, const Filter_ &amp;filter, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:ae0af5b9e827d08f7d923528cc679609c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_gropp_p_c_g.html" title="(Preconditioned) pipelined Conjugate-Gradient solver implementation from Bill Gropp">GroppPCG</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#ae0af5b9e827d08f7d923528cc679609c">More...</a><br /></td></tr>
<tr class="separator:ae0af5b9e827d08f7d923528cc679609c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804d6b5613261d71731864141c1d2ab5"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a804d6b5613261d71731864141c1d2ab5"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_gropp_p_c_g.html">GroppPCG</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a804d6b5613261d71731864141c1d2ab5">new_gropppcg</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, const Matrix_ &amp;matrix, const Filter_ &amp;filter, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:a804d6b5613261d71731864141c1d2ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_gropp_p_c_g.html" title="(Preconditioned) pipelined Conjugate-Gradient solver implementation from Bill Gropp">GroppPCG</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#a804d6b5613261d71731864141c1d2ab5">More...</a><br /></td></tr>
<tr class="separator:a804d6b5613261d71731864141c1d2ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565c81560e5e44586e29878f6e31ba6a"><td class="memTemplParams" colspan="2">template&lt;typename Operator_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a565c81560e5e44586e29878f6e31ba6a"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_hessian_precond.html">HessianPrecond</a>&lt; Operator_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a565c81560e5e44586e29878f6e31ba6a">new_hessian_precond</a> (Operator_ &amp;op_, const Filter_ &amp;filter_)</td></tr>
<tr class="memdesc:a565c81560e5e44586e29878f6e31ba6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_hessian_precond.html" title="Preconditioner that applies the inverse of an operator&#39;s Hessian.">HessianPrecond</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#a565c81560e5e44586e29878f6e31ba6a">More...</a><br /></td></tr>
<tr class="separator:a565c81560e5e44586e29878f6e31ba6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e182a2b77cb054dea748799147f44b"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:ae2e182a2b77cb054dea748799147f44b"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_i_d_r_s.html">IDRS</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ae2e182a2b77cb054dea748799147f44b">new_idrs</a> (const Matrix_ &amp;matrix, const Filter_ &amp;filter, <a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1">Index</a> krylov_dim, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:ae2e182a2b77cb054dea748799147f44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new IDR(s) solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#ae2e182a2b77cb054dea748799147f44b">More...</a><br /></td></tr>
<tr class="separator:ae2e182a2b77cb054dea748799147f44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ed901c6634352c3f97e7d9336f274b"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a29ed901c6634352c3f97e7d9336f274b"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_i_d_r_s.html">IDRS</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a29ed901c6634352c3f97e7d9336f274b">new_idrs</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, const Matrix_ &amp;matrix, const Filter_ &amp;filter, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:a29ed901c6634352c3f97e7d9336f274b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new IDR(s) solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#a29ed901c6634352c3f97e7d9336f274b">More...</a><br /></td></tr>
<tr class="separator:a29ed901c6634352c3f97e7d9336f274b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aecfff253544d2e53895de0cfb4f1b6"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a7aecfff253544d2e53895de0cfb4f1b6"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_i_l_u_precond.html">ILUPrecond</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a7aecfff253544d2e53895de0cfb4f1b6">new_ilu_precond</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, <a class="el" href="namespace_f_e_a_t.html#a050b7378896da037a96211e8db059029">PreferredBackend</a> backend, const Matrix_ &amp;matrix, const Filter_ &amp;filter)</td></tr>
<tr class="memdesc:a7aecfff253544d2e53895de0cfb4f1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_i_l_u_precond.html" title="ILU(0) and ILU(p) preconditioner implementation.">ILUPrecond</a> solver object based on a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#a7aecfff253544d2e53895de0cfb4f1b6">More...</a><br /></td></tr>
<tr class="separator:a7aecfff253544d2e53895de0cfb4f1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6855772185a20ab674478b0ad4fedd4"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:ae6855772185a20ab674478b0ad4fedd4"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_i_l_u_precond.html">ILUPrecond</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ae6855772185a20ab674478b0ad4fedd4">new_ilu_precond</a> (<a class="el" href="namespace_f_e_a_t.html#a050b7378896da037a96211e8db059029">PreferredBackend</a> backend, const Matrix_ &amp;matrix, const Filter_ &amp;filter, const int p=0)</td></tr>
<tr class="memdesc:ae6855772185a20ab674478b0ad4fedd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_i_l_u_precond.html" title="ILU(0) and ILU(p) preconditioner implementation.">ILUPrecond</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#ae6855772185a20ab674478b0ad4fedd4">More...</a><br /></td></tr>
<tr class="separator:ae6855772185a20ab674478b0ad4fedd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac68b706343d7aba2bc3769070dd926"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:adac68b706343d7aba2bc3769070dd926"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_jacobi_precond.html">JacobiPrecond</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#adac68b706343d7aba2bc3769070dd926">new_jacobi_precond</a> (const Matrix_ &amp;matrix, const Filter_ &amp;filter, const typename Matrix_::DataType omega=typename Matrix_::DataType(1))</td></tr>
<tr class="memdesc:adac68b706343d7aba2bc3769070dd926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_jacobi_precond.html" title="Jacobi preconditioner implementation.">JacobiPrecond</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#adac68b706343d7aba2bc3769070dd926">More...</a><br /></td></tr>
<tr class="separator:adac68b706343d7aba2bc3769070dd926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7547597be99467fcfd8f934d4b32d4e9"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a7547597be99467fcfd8f934d4b32d4e9"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_jacobi_precond.html">JacobiPrecond</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a7547597be99467fcfd8f934d4b32d4e9">new_jacobi_precond</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, const Matrix_ &amp;matrix, const Filter_ &amp;filter)</td></tr>
<tr class="memdesc:a7547597be99467fcfd8f934d4b32d4e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_jacobi_precond.html" title="Jacobi preconditioner implementation.">JacobiPrecond</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#a7547597be99467fcfd8f934d4b32d4e9">More...</a><br /></td></tr>
<tr class="separator:a7547597be99467fcfd8f934d4b32d4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9911e7960f1440707040ce3e6edb4e53"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a9911e7960f1440707040ce3e6edb4e53"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_matrix_precond.html">MatrixPrecond</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a9911e7960f1440707040ce3e6edb4e53">new_matrix_precond</a> (const Matrix_ &amp;matrix, const Filter_ &amp;filter)</td></tr>
<tr class="memdesc:a9911e7960f1440707040ce3e6edb4e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_matrix_precond.html" title="Matrix preconditioner implementation.">MatrixPrecond</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#a9911e7960f1440707040ce3e6edb4e53">More...</a><br /></td></tr>
<tr class="separator:a9911e7960f1440707040ce3e6edb4e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f21dbcd6bf8a8e7b5541fd6d3bed119"><td class="memTemplParams" colspan="2">template&lt;typename Functional_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a3f21dbcd6bf8a8e7b5541fd6d3bed119"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_m_q_c_linesearch.html">MQCLinesearch</a>&lt; Functional_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a3f21dbcd6bf8a8e7b5541fd6d3bed119">new_mqc_linesearch</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, Functional_ &amp;functional, Filter_ &amp;filter)</td></tr>
<tr class="memdesc:a3f21dbcd6bf8a8e7b5541fd6d3bed119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_m_q_c_linesearch.html" title="Mixed quadratic-cubic line search.">MQCLinesearch</a> object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#a3f21dbcd6bf8a8e7b5541fd6d3bed119">More...</a><br /></td></tr>
<tr class="separator:a3f21dbcd6bf8a8e7b5541fd6d3bed119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11a88375825f798d11e58403c40379f"><td class="memTemplParams" colspan="2">template&lt;typename Functional_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:ac11a88375825f798d11e58403c40379f"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_m_q_c_linesearch.html">MQCLinesearch</a>&lt; Functional_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ac11a88375825f798d11e58403c40379f">new_mqc_linesearch</a> (Functional_ &amp;functional, Filter_ &amp;filter, bool keep_iterates=false)</td></tr>
<tr class="memdesc:ac11a88375825f798d11e58403c40379f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_m_q_c_linesearch.html" title="Mixed quadratic-cubic line search.">MQCLinesearch</a> object.  <a href="namespace_f_e_a_t_1_1_solver.html#ac11a88375825f798d11e58403c40379f">More...</a><br /></td></tr>
<tr class="separator:ac11a88375825f798d11e58403c40379f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4940f8c4ee8be921a6d6dca8b918887a"><td class="memTemplParams" colspan="2">template&lt;typename SystemMatrix_ , typename SystemFilter_ , typename TransferOperator_ &gt; </td></tr>
<tr class="memitem:a4940f8c4ee8be921a6d6dca8b918887a"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_multi_grid.html">MultiGrid</a>&lt; SystemMatrix_, SystemFilter_, TransferOperator_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a4940f8c4ee8be921a6d6dca8b918887a">new_multigrid</a> (std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_multi_grid_hierarchy.html">MultiGridHierarchy</a>&lt; SystemMatrix_, SystemFilter_, TransferOperator_ &gt; &gt; hierarchy, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a5b14b494b949c5eecc622f4ad6e2d59b">MultiGridCycle</a> cycle=<a class="el" href="namespace_f_e_a_t_1_1_solver.html#a5b14b494b949c5eecc622f4ad6e2d59ba5206560a306a2e085a437fd258eb57ce">MultiGridCycle::V</a>, int top_level=0, int crs_level=-1)</td></tr>
<tr class="memdesc:a4940f8c4ee8be921a6d6dca8b918887a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Multigrid preconditioner object.  <a href="namespace_f_e_a_t_1_1_solver.html#a4940f8c4ee8be921a6d6dca8b918887a">More...</a><br /></td></tr>
<tr class="separator:a4940f8c4ee8be921a6d6dca8b918887a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae388aa993a6ef664944ce3d90125057e"><td class="memTemplParams" colspan="2">template&lt;typename Functional_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:ae388aa993a6ef664944ce3d90125057e"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_newton_raphson_linesearch.html">NewtonRaphsonLinesearch</a>&lt; Functional_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ae388aa993a6ef664944ce3d90125057e">new_newton_raphson_linesearch</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, Functional_ &amp;functional, Filter_ &amp;filter)</td></tr>
<tr class="memdesc:ae388aa993a6ef664944ce3d90125057e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_newton_raphson_linesearch.html" title="Newton Raphson linesearch.">NewtonRaphsonLinesearch</a> object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#ae388aa993a6ef664944ce3d90125057e">More...</a><br /></td></tr>
<tr class="separator:ae388aa993a6ef664944ce3d90125057e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5986f726755329cf6107b63294902fb3"><td class="memTemplParams" colspan="2">template&lt;typename Functional_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a5986f726755329cf6107b63294902fb3"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_newton_raphson_linesearch.html">NewtonRaphsonLinesearch</a>&lt; Functional_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a5986f726755329cf6107b63294902fb3">new_newton_raphson_linesearch</a> (Functional_ &amp;functional, Filter_ &amp;filter, bool keep_iterates=false)</td></tr>
<tr class="memdesc:a5986f726755329cf6107b63294902fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_newton_raphson_linesearch.html" title="Newton Raphson linesearch.">NewtonRaphsonLinesearch</a> object.  <a href="namespace_f_e_a_t_1_1_solver.html#a5986f726755329cf6107b63294902fb3">More...</a><br /></td></tr>
<tr class="separator:a5986f726755329cf6107b63294902fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfcfc78f5ca522827fe000c7425d387"><td class="memTemplParams" colspan="2">template&lt;typename Functional_ , typename Filter_ , typename Linesearch_ &gt; </td></tr>
<tr class="memitem:aedfcfc78f5ca522827fe000c7425d387"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_c_g.html">NLCG</a>&lt; Functional_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#aedfcfc78f5ca522827fe000c7425d387">new_nlcg</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, Functional_ &amp;functional, Filter_ &amp;filter, Linesearch_ &amp;linesearch, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_opt_precond.html">NLOptPrecond</a>&lt; typename Functional_::VectorTypeL, Filter_ &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:aedfcfc78f5ca522827fe000c7425d387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_c_g.html" title="Nonlinear Conjugate Gradient method for finding a minimum of an functional&#39;s gradient.">NLCG</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#aedfcfc78f5ca522827fe000c7425d387">More...</a><br /></td></tr>
<tr class="separator:aedfcfc78f5ca522827fe000c7425d387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98e2d07903f6688add105a6457f7e2c"><td class="memTemplParams" colspan="2">template&lt;typename Functional_ , typename Filter_ , typename Linesearch_ &gt; </td></tr>
<tr class="memitem:ae98e2d07903f6688add105a6457f7e2c"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_c_g.html">NLCG</a>&lt; Functional_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ae98e2d07903f6688add105a6457f7e2c">new_nlcg</a> (Functional_ &amp;functional, Filter_ &amp;filter, Linesearch_ &amp;linesearch, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a651714c882641671d73d78382d7d77ee">NLCGDirectionUpdate</a> direction_update=<a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_c_g.html">NLCG</a>&lt; Functional_, Filter_ &gt;::direction_update_default, bool keep_iterates=false, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_opt_precond.html">NLOptPrecond</a>&lt; typename Functional_::VectorTypeL, Filter_ &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:ae98e2d07903f6688add105a6457f7e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_c_g.html" title="Nonlinear Conjugate Gradient method for finding a minimum of an functional&#39;s gradient.">NLCG</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#ae98e2d07903f6688add105a6457f7e2c">More...</a><br /></td></tr>
<tr class="separator:ae98e2d07903f6688add105a6457f7e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c92b6bd48450a3f505b1132ac6ed89"><td class="memTemplParams" colspan="2">template&lt;typename Functional_ , typename Filter_ , typename Linesearch_ &gt; </td></tr>
<tr class="memitem:ab8c92b6bd48450a3f505b1132ac6ed89"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_s_d.html">NLSD</a>&lt; Functional_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab8c92b6bd48450a3f505b1132ac6ed89">new_nlsd</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, Functional_ &amp;functional, Filter_ &amp;filter, Linesearch_ &amp;linesearch, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_opt_precond.html">NLOptPrecond</a>&lt; typename Functional_::VectorTypeL, Filter_ &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:ab8c92b6bd48450a3f505b1132ac6ed89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_s_d.html" title="Nonlinear Steepest Descent method for finding a minimum of an functional&#39;s gradient.">NLSD</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#ab8c92b6bd48450a3f505b1132ac6ed89">More...</a><br /></td></tr>
<tr class="separator:ab8c92b6bd48450a3f505b1132ac6ed89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6701c5190efb1e0f1085853ef4bf3582"><td class="memTemplParams" colspan="2">template&lt;typename Functional_ , typename Filter_ , typename Linesearch_ &gt; </td></tr>
<tr class="memitem:a6701c5190efb1e0f1085853ef4bf3582"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_s_d.html">NLSD</a>&lt; Functional_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a6701c5190efb1e0f1085853ef4bf3582">new_nlsd</a> (Functional_ &amp;functional, Filter_ &amp;filter, Linesearch_ &amp;linesearch, bool keep_iterates=false, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_opt_precond.html">NLOptPrecond</a>&lt; typename Functional_::VectorTypeL, Filter_ &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:a6701c5190efb1e0f1085853ef4bf3582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_s_d.html" title="Nonlinear Steepest Descent method for finding a minimum of an functional&#39;s gradient.">NLSD</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#a6701c5190efb1e0f1085853ef4bf3582">More...</a><br /></td></tr>
<tr class="separator:a6701c5190efb1e0f1085853ef4bf3582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25100c25aa3685c8392ae3cce25f9618"><td class="memTemplParams" colspan="2">template&lt;typename NonlinearOperator_ , typename... Args_&gt; </td></tr>
<tr class="memitem:a25100c25aa3685c8392ae3cce25f9618"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_nonlinear_operator_precond_wrapper.html">NonlinearOperatorPrecondWrapper</a>&lt; NonlinearOperator_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a25100c25aa3685c8392ae3cce25f9618">new_nonlinear_operator_precond_wrapper</a> (Args_ &amp;&amp;... args)</td></tr>
<tr class="memdesc:a25100c25aa3685c8392ae3cce25f9618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_nonlinear_operator_precond_wrapper.html" title="Wrapper class around a (potentially nonlinear) operator.">NonlinearOperatorPrecondWrapper</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#a25100c25aa3685c8392ae3cce25f9618">More...</a><br /></td></tr>
<tr class="separator:a25100c25aa3685c8392ae3cce25f9618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622b5d745d268a0942f75afd6905103f"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a622b5d745d268a0942f75afd6905103f"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_para_sails_precond.html">ParaSailsPrecond</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a622b5d745d268a0942f75afd6905103f">new_parasails_precond</a> (const Matrix_ &amp;matrix, const Filter_ &amp;filter)</td></tr>
<tr class="memdesc:a622b5d745d268a0942f75afd6905103f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_para_sails_precond.html" title="HYPRE ParaSails Preconditioner Wrapper class template.">ParaSailsPrecond</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#a622b5d745d268a0942f75afd6905103f">More...</a><br /></td></tr>
<tr class="separator:a622b5d745d268a0942f75afd6905103f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b68934316380fc5fa14f27851fcfdf0"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a4b68934316380fc5fa14f27851fcfdf0"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_para_sails_precond.html">ParaSailsPrecond</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a4b68934316380fc5fa14f27851fcfdf0">new_parasails_precond</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, const Matrix_ &amp;matrix, const Filter_ &amp;filter)</td></tr>
<tr class="memdesc:a4b68934316380fc5fa14f27851fcfdf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_para_sails_precond.html" title="HYPRE ParaSails Preconditioner Wrapper class template.">ParaSailsPrecond</a> solver object based on a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#a4b68934316380fc5fa14f27851fcfdf0">More...</a><br /></td></tr>
<tr class="separator:a4b68934316380fc5fa14f27851fcfdf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85895fa0a94ac2681b1445f5456874d4"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a85895fa0a94ac2681b1445f5456874d4"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g.html">PCG</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a85895fa0a94ac2681b1445f5456874d4">new_pcg</a> (const Matrix_ &amp;matrix, const Filter_ &amp;filter, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:a85895fa0a94ac2681b1445f5456874d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g.html" title="(Preconditioned) Conjugate-Gradient solver implementation">PCG</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#a85895fa0a94ac2681b1445f5456874d4">More...</a><br /></td></tr>
<tr class="separator:a85895fa0a94ac2681b1445f5456874d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1614b6614a365b380d25e5012047c50"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:ac1614b6614a365b380d25e5012047c50"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g.html">PCG</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ac1614b6614a365b380d25e5012047c50">new_pcg</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, const Matrix_ &amp;matrix, const Filter_ &amp;filter, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:ac1614b6614a365b380d25e5012047c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g.html" title="(Preconditioned) Conjugate-Gradient solver implementation">PCG</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#ac1614b6614a365b380d25e5012047c50">More...</a><br /></td></tr>
<tr class="separator:ac1614b6614a365b380d25e5012047c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911026db26857a46df6a675d2b53258b"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a911026db26857a46df6a675d2b53258b"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g_n_r.html">PCGNR</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a911026db26857a46df6a675d2b53258b">new_pcgnr</a> (const Matrix_ &amp;matrix, const Filter_ &amp;filter, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond_l=nullptr, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond_r=nullptr)</td></tr>
<tr class="memdesc:a911026db26857a46df6a675d2b53258b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g_n_r.html" title="(Preconditioned) Conjugate-Gradient on Normal Equations solver implementation">PCGNR</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#a911026db26857a46df6a675d2b53258b">More...</a><br /></td></tr>
<tr class="separator:a911026db26857a46df6a675d2b53258b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b48d7ab95134f757e5f7cdf79a30e1d"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a0b48d7ab95134f757e5f7cdf79a30e1d"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g_n_r.html">PCGNR</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a0b48d7ab95134f757e5f7cdf79a30e1d">new_pcgnr</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, const Matrix_ &amp;matrix, const Filter_ &amp;filter, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond_l=nullptr, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond_r=nullptr)</td></tr>
<tr class="memdesc:a0b48d7ab95134f757e5f7cdf79a30e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g_n_r.html" title="(Preconditioned) Conjugate-Gradient on Normal Equations solver implementation">PCGNR</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#a0b48d7ab95134f757e5f7cdf79a30e1d">More...</a><br /></td></tr>
<tr class="separator:a0b48d7ab95134f757e5f7cdf79a30e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57cd73a467ceca33324492b02898e68"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:ab57cd73a467ceca33324492b02898e68"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g_n_r_i_l_u.html">PCGNRILU</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab57cd73a467ceca33324492b02898e68">new_pcgnrilu</a> (const Matrix_ &amp;matrix, const Filter_ &amp;filter, int ilu_p=-1)</td></tr>
<tr class="memdesc:ab57cd73a467ceca33324492b02898e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g_n_r_i_l_u.html" title="ILU(p)-preconditioned Conjugate-Gradient on Normal Equations solver implementation.">PCGNRILU</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#ab57cd73a467ceca33324492b02898e68">More...</a><br /></td></tr>
<tr class="separator:ab57cd73a467ceca33324492b02898e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657dede58deaaa0d48a5dae5673c270b"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a657dede58deaaa0d48a5dae5673c270b"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g_n_r_i_l_u.html">PCGNRILU</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a657dede58deaaa0d48a5dae5673c270b">new_pcgnrilu</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, const Matrix_ &amp;matrix, const Filter_ &amp;filter)</td></tr>
<tr class="memdesc:a657dede58deaaa0d48a5dae5673c270b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g_n_r_i_l_u.html" title="ILU(p)-preconditioned Conjugate-Gradient on Normal Equations solver implementation.">PCGNRILU</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#a657dede58deaaa0d48a5dae5673c270b">More...</a><br /></td></tr>
<tr class="separator:a657dede58deaaa0d48a5dae5673c270b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33ab411b2c94368a1dfebe969503387"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:ae33ab411b2c94368a1dfebe969503387"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_r.html">PCR</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ae33ab411b2c94368a1dfebe969503387">new_pcr</a> (const Matrix_ &amp;matrix, const Filter_ &amp;filter, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:ae33ab411b2c94368a1dfebe969503387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_r.html" title="(Preconditioned) Conjugate-Residual solver implementation">PCR</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#ae33ab411b2c94368a1dfebe969503387">More...</a><br /></td></tr>
<tr class="separator:ae33ab411b2c94368a1dfebe969503387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea26b9a47c2c5b3503743ad71f083c8"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a2ea26b9a47c2c5b3503743ad71f083c8"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_r.html">PCR</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a2ea26b9a47c2c5b3503743ad71f083c8">new_pcr</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, const Matrix_ &amp;matrix, const Filter_ &amp;filter, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:a2ea26b9a47c2c5b3503743ad71f083c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_r.html" title="(Preconditioned) Conjugate-Residual solver implementation">PCR</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#a2ea26b9a47c2c5b3503743ad71f083c8">More...</a><br /></td></tr>
<tr class="separator:a2ea26b9a47c2c5b3503743ad71f083c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5a6866b18ce17013639fb9f4647c80"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:afd5a6866b18ce17013639fb9f4647c80"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_pipe_p_c_g.html">PipePCG</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#afd5a6866b18ce17013639fb9f4647c80">new_pipepcg</a> (const Matrix_ &amp;matrix, const Filter_ &amp;filter, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:afd5a6866b18ce17013639fb9f4647c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_pipe_p_c_g.html" title="(Preconditioned) pipelined Conjugate-Gradient solver implementation from Ghysels and Vnaroose">PipePCG</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#afd5a6866b18ce17013639fb9f4647c80">More...</a><br /></td></tr>
<tr class="separator:afd5a6866b18ce17013639fb9f4647c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efb59a44612597a86e127427644f4ab"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a5efb59a44612597a86e127427644f4ab"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_pipe_p_c_g.html">PipePCG</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a5efb59a44612597a86e127427644f4ab">new_pipepcg</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, const Matrix_ &amp;matrix, const Filter_ &amp;filter, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:a5efb59a44612597a86e127427644f4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_pipe_p_c_g.html" title="(Preconditioned) pipelined Conjugate-Gradient solver implementation from Ghysels and Vnaroose">PipePCG</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#a5efb59a44612597a86e127427644f4ab">More...</a><br /></td></tr>
<tr class="separator:a5efb59a44612597a86e127427644f4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940b86c64e3f0422ea0c7c573bcda71a"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a940b86c64e3f0422ea0c7c573bcda71a"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_m_r.html">PMR</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a940b86c64e3f0422ea0c7c573bcda71a">new_pmr</a> (const Matrix_ &amp;matrix, const Filter_ &amp;filter, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:a940b86c64e3f0422ea0c7c573bcda71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_m_r.html" title="(Preconditioned) Minimal-Residual-Iteration solver implementation">PMR</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#a940b86c64e3f0422ea0c7c573bcda71a">More...</a><br /></td></tr>
<tr class="separator:a940b86c64e3f0422ea0c7c573bcda71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fdbca4c863c6705484e2d4d34ecf64"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:ad8fdbca4c863c6705484e2d4d34ecf64"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_m_r.html">PMR</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ad8fdbca4c863c6705484e2d4d34ecf64">new_pmr</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, const Matrix_ &amp;matrix, const Filter_ &amp;filter, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:ad8fdbca4c863c6705484e2d4d34ecf64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_m_r.html" title="(Preconditioned) Minimal-Residual-Iteration solver implementation">PMR</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#ad8fdbca4c863c6705484e2d4d34ecf64">More...</a><br /></td></tr>
<tr class="separator:ad8fdbca4c863c6705484e2d4d34ecf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8bd0716ea4730474e9b391d97819c0"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:aca8bd0716ea4730474e9b391d97819c0"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_polynomial_precond.html">PolynomialPrecond</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#aca8bd0716ea4730474e9b391d97819c0">new_polynomial_precond</a> (const Matrix_ &amp;matrix, const Filter_ &amp;filter, const <a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1">Index</a> m, const typename Matrix_::DataType omega=typename Matrix_::DataType(1))</td></tr>
<tr class="memdesc:aca8bd0716ea4730474e9b391d97819c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new PoynomialPrecond solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#aca8bd0716ea4730474e9b391d97819c0">More...</a><br /></td></tr>
<tr class="separator:aca8bd0716ea4730474e9b391d97819c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0d224e33f8ddbde5a0b02ead13f68f"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a8f0d224e33f8ddbde5a0b02ead13f68f"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_polynomial_precond.html">PolynomialPrecond</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a8f0d224e33f8ddbde5a0b02ead13f68f">new_polynomial_precond</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, const Matrix_ &amp;matrix, const Filter_ &amp;filter)</td></tr>
<tr class="memdesc:a8f0d224e33f8ddbde5a0b02ead13f68f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_polynomial_precond.html" title="Polynomial preconditioner implementation.">PolynomialPrecond</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#a8f0d224e33f8ddbde5a0b02ead13f68f">More...</a><br /></td></tr>
<tr class="separator:a8f0d224e33f8ddbde5a0b02ead13f68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a1659b386401b23df34866c47bb406"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:ac6a1659b386401b23df34866c47bb406"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_s_d.html">PSD</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ac6a1659b386401b23df34866c47bb406">new_psd</a> (const Matrix_ &amp;matrix, const Filter_ &amp;filter, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:ac6a1659b386401b23df34866c47bb406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_s_d.html" title="(Preconditioned) Steepest-Descent solver implementation">PSD</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#ac6a1659b386401b23df34866c47bb406">More...</a><br /></td></tr>
<tr class="separator:ac6a1659b386401b23df34866c47bb406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5ed5890cd42fc9234f198327a99f3d"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a8e5ed5890cd42fc9234f198327a99f3d"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_s_d.html">PSD</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a8e5ed5890cd42fc9234f198327a99f3d">new_psd</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, const Matrix_ &amp;matrix, const Filter_ &amp;filter, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:a8e5ed5890cd42fc9234f198327a99f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_s_d.html" title="(Preconditioned) Steepest-Descent solver implementation">PSD</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#a8e5ed5890cd42fc9234f198327a99f3d">More...</a><br /></td></tr>
<tr class="separator:a8e5ed5890cd42fc9234f198327a99f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d281041763d4c4de818a91d7fdf412"><td class="memTemplParams" colspan="2">template&lt;typename Functional_ &gt; </td></tr>
<tr class="memitem:a02d281041763d4c4de818a91d7fdf412"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_q_penalty.html">QPenalty</a>&lt; Functional_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a02d281041763d4c4de818a91d7fdf412">new_qpenalty</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, Functional_ &amp;functional, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_iterative_solver.html">IterativeSolver</a>&lt; typename Functional_::VectorTypeR &gt; &gt; inner_solver)</td></tr>
<tr class="memdesc:a02d281041763d4c4de818a91d7fdf412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_q_penalty.html" title="Quadratic penalty iteration.">QPenalty</a> object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#a02d281041763d4c4de818a91d7fdf412">More...</a><br /></td></tr>
<tr class="separator:a02d281041763d4c4de818a91d7fdf412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3f570b9eaa19a46246d64ce281ccde"><td class="memTemplParams" colspan="2">template&lt;typename Functional_ &gt; </td></tr>
<tr class="memitem:aac3f570b9eaa19a46246d64ce281ccde"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_q_penalty.html">QPenalty</a>&lt; Functional_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#aac3f570b9eaa19a46246d64ce281ccde">new_qpenalty</a> (Functional_ &amp;functional, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_iterative_solver.html">IterativeSolver</a>&lt; typename Functional_::VectorTypeR &gt; &gt; inner_solver, typename Functional_::VectorTypeR::DataType initial_penalty_param=typename Functional_::VectorTypeR::DataType(1))</td></tr>
<tr class="memdesc:aac3f570b9eaa19a46246d64ce281ccde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_q_penalty.html" title="Quadratic penalty iteration.">QPenalty</a> object.  <a href="namespace_f_e_a_t_1_1_solver.html#aac3f570b9eaa19a46246d64ce281ccde">More...</a><br /></td></tr>
<tr class="separator:aac3f570b9eaa19a46246d64ce281ccde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f4ae780a90a2bc1625273739d48334"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a80f4ae780a90a2bc1625273739d48334"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_r_bi_c_g_stab.html">RBiCGStab</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a80f4ae780a90a2bc1625273739d48334">new_rbicgstab</a> (const Matrix_ &amp;matrix, const Filter_ &amp;filter, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:a80f4ae780a90a2bc1625273739d48334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_r_bi_c_g_stab.html" title="(Preconditioned) reordered BiCGStab solver implementation">RBiCGStab</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#a80f4ae780a90a2bc1625273739d48334">More...</a><br /></td></tr>
<tr class="separator:a80f4ae780a90a2bc1625273739d48334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeeccd126d8070a5e02655f8d7aae30d"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:abeeccd126d8070a5e02655f8d7aae30d"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_r_bi_c_g_stab.html">RBiCGStab</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#abeeccd126d8070a5e02655f8d7aae30d">new_rbicgstab</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, const Matrix_ &amp;matrix, const Filter_ &amp;filter, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:abeeccd126d8070a5e02655f8d7aae30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_r_bi_c_g_stab.html" title="(Preconditioned) reordered BiCGStab solver implementation">RBiCGStab</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#abeeccd126d8070a5e02655f8d7aae30d">More...</a><br /></td></tr>
<tr class="separator:abeeccd126d8070a5e02655f8d7aae30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4deeeb38f10e01f5a98d1c7ab69ade53"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a4deeeb38f10e01f5a98d1c7ab69ade53"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_r_g_c_r.html">RGCR</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a4deeeb38f10e01f5a98d1c7ab69ade53">new_rgcr</a> (const Matrix_ &amp;matrix, const Filter_ &amp;filter, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:a4deeeb38f10e01f5a98d1c7ab69ade53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_r_g_c_r.html" title="(Preconditioned) Recycling Generalized Conjugate Residual solver implementation">RGCR</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#a4deeeb38f10e01f5a98d1c7ab69ade53">More...</a><br /></td></tr>
<tr class="separator:a4deeeb38f10e01f5a98d1c7ab69ade53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd239092529b6d23b1d983b5c16751e"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:afdd239092529b6d23b1d983b5c16751e"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_r_g_c_r.html">RGCR</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#afdd239092529b6d23b1d983b5c16751e">new_rgcr</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, const Matrix_ &amp;matrix, const Filter_ &amp;filter, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:afdd239092529b6d23b1d983b5c16751e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_r_g_c_r.html" title="(Preconditioned) Recycling Generalized Conjugate Residual solver implementation">RGCR</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#afdd239092529b6d23b1d983b5c16751e">More...</a><br /></td></tr>
<tr class="separator:afdd239092529b6d23b1d983b5c16751e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949a4a927b774626fd9dd5313d7afc9c"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a949a4a927b774626fd9dd5313d7afc9c"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_richardson.html">Richardson</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a949a4a927b774626fd9dd5313d7afc9c">new_richardson</a> (const Matrix_ &amp;matrix, const Filter_ &amp;filter, typename Matrix_::DataType omega=typename Matrix_::DataType(1), std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:a949a4a927b774626fd9dd5313d7afc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_richardson.html" title="(Preconditioned) Richardson solver implementation">Richardson</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#a949a4a927b774626fd9dd5313d7afc9c">More...</a><br /></td></tr>
<tr class="separator:a949a4a927b774626fd9dd5313d7afc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a84a5de15933f3bd77b8260dae38798"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a3a84a5de15933f3bd77b8260dae38798"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_richardson.html">Richardson</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a3a84a5de15933f3bd77b8260dae38798">new_richardson</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, const Matrix_ &amp;matrix, const Filter_ &amp;filter, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt; precond=nullptr)</td></tr>
<tr class="memdesc:a3a84a5de15933f3bd77b8260dae38798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_richardson.html" title="(Preconditioned) Richardson solver implementation">Richardson</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#a3a84a5de15933f3bd77b8260dae38798">More...</a><br /></td></tr>
<tr class="separator:a3a84a5de15933f3bd77b8260dae38798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e61383fb1073b657cf006e1ab09abd"><td class="memTemplParams" colspan="2">template&lt;typename DT_ , typename IT_ , int dim_&gt; </td></tr>
<tr class="memitem:aa9e61383fb1073b657cf006e1ab09abd"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_saddle_umfpack_mean.html">SaddleUmfpackMean</a>&lt; DT_, IT_, dim_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#aa9e61383fb1073b657cf006e1ab09abd">new_saddle_umfpack_mean</a> (const <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_saddle_point_matrix.html">LAFEM::SaddlePointMatrix</a>&lt; <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_sparse_matrix_b_c_s_r.html">LAFEM::SparseMatrixBCSR</a>&lt; DT_, IT_, dim_, dim_ &gt;, <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_sparse_matrix_b_c_s_r.html">LAFEM::SparseMatrixBCSR</a>&lt; DT_, IT_, dim_, 1 &gt;, <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_sparse_matrix_b_c_s_r.html">LAFEM::SparseMatrixBCSR</a>&lt; DT_, IT_, 1, dim_ &gt; &gt; &amp;matrix, const <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_dense_vector.html">LAFEM::DenseVector</a>&lt; DT_, IT_ &gt; &amp;weight_vector)</td></tr>
<tr class="memdesc:aa9e61383fb1073b657cf006e1ab09abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_umfpack_mean.html" title="UMFPACK Mean solver class.">UmfpackMean</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#aa9e61383fb1073b657cf006e1ab09abd">More...</a><br /></td></tr>
<tr class="separator:aa9e61383fb1073b657cf006e1ab09abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee97d79e9e16ab8e1a6b5aae8cfd14a"><td class="memTemplParams" colspan="2">template&lt;typename DT_ , typename IT_ , int dim_&gt; </td></tr>
<tr class="memitem:aaee97d79e9e16ab8e1a6b5aae8cfd14a"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_saddle_umfpack_mean.html">SaddleUmfpackMean</a>&lt; DT_, IT_, dim_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#aaee97d79e9e16ab8e1a6b5aae8cfd14a">new_saddle_umfpack_mean</a> (const <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_saddle_point_matrix.html">LAFEM::SaddlePointMatrix</a>&lt; <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_sparse_matrix_b_c_s_r.html">LAFEM::SparseMatrixBCSR</a>&lt; DT_, IT_, dim_, dim_ &gt;, <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_sparse_matrix_b_c_s_r.html">LAFEM::SparseMatrixBCSR</a>&lt; DT_, IT_, dim_, 1 &gt;, <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_sparse_matrix_b_c_s_r.html">LAFEM::SparseMatrixBCSR</a>&lt; DT_, IT_, 1, dim_ &gt; &gt; &amp;matrix, const <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_mean_filter.html">LAFEM::MeanFilter</a>&lt; DT_, IT_ &gt; &amp;filter)</td></tr>
<tr class="memdesc:aaee97d79e9e16ab8e1a6b5aae8cfd14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_umfpack_mean.html" title="UMFPACK Mean solver class.">UmfpackMean</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#aaee97d79e9e16ab8e1a6b5aae8cfd14a">More...</a><br /></td></tr>
<tr class="separator:aaee97d79e9e16ab8e1a6b5aae8cfd14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22dceb57a3ddbe2a357db7bf197e3747"><td class="memTemplParams" colspan="2">template&lt;typename Filter_ , typename DataType_ &gt; </td></tr>
<tr class="memitem:a22dceb57a3ddbe2a357db7bf197e3747"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_scale_precond.html">ScalePrecond</a>&lt; typename Filter_::VectorType, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a22dceb57a3ddbe2a357db7bf197e3747">new_scale_precond</a> (const Filter_ &amp;filter, DataType_ omega)</td></tr>
<tr class="memdesc:a22dceb57a3ddbe2a357db7bf197e3747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_scale_precond.html" title="Scaling preconditioner class template.">ScalePrecond</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#a22dceb57a3ddbe2a357db7bf197e3747">More...</a><br /></td></tr>
<tr class="separator:a22dceb57a3ddbe2a357db7bf197e3747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4a46c17802ad01d5aa3a257c73255a"><td class="memTemplParams" colspan="2">template&lt;typename Filter_ &gt; </td></tr>
<tr class="memitem:a2d4a46c17802ad01d5aa3a257c73255a"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_scale_precond.html">ScalePrecond</a>&lt; typename Filter_::VectorType, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a2d4a46c17802ad01d5aa3a257c73255a">new_scale_precond</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, const Filter_ &amp;filter)</td></tr>
<tr class="memdesc:a2d4a46c17802ad01d5aa3a257c73255a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_scale_precond.html" title="Scaling preconditioner class template.">ScalePrecond</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#a2d4a46c17802ad01d5aa3a257c73255a">More...</a><br /></td></tr>
<tr class="separator:a2d4a46c17802ad01d5aa3a257c73255a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43a39577b0cf19d470f15bc48393954"><td class="memTemplParams" colspan="2">template&lt;typename LocalFilter_ , typename Mirror_ &gt; </td></tr>
<tr class="memitem:ae43a39577b0cf19d470f15bc48393954"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_schwarz_precond.html">SchwarzPrecond</a>&lt; <a class="el" href="class_f_e_a_t_1_1_global_1_1_vector.html">Global::Vector</a>&lt; typename LocalFilter_::VectorType, Mirror_ &gt;, <a class="el" href="class_f_e_a_t_1_1_global_1_1_filter.html">Global::Filter</a>&lt; LocalFilter_, Mirror_ &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ae43a39577b0cf19d470f15bc48393954">new_schwarz_precond</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename LocalFilter_::VectorType &gt; &gt; local_solver, const <a class="el" href="class_f_e_a_t_1_1_global_1_1_filter.html">Global::Filter</a>&lt; LocalFilter_, Mirror_ &gt; &amp;filter)</td></tr>
<tr class="memdesc:ae43a39577b0cf19d470f15bc48393954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_schwarz_precond.html" title="Schwarz preconditioner class template declaration.">SchwarzPrecond</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#ae43a39577b0cf19d470f15bc48393954">More...</a><br /></td></tr>
<tr class="separator:ae43a39577b0cf19d470f15bc48393954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec39e5544cf879ec05d525baa29c3d2e"><td class="memTemplParams" colspan="2">template&lt;typename LocalFilter_ , typename Mirror_ &gt; </td></tr>
<tr class="memitem:aec39e5544cf879ec05d525baa29c3d2e"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_schwarz_precond.html">SchwarzPrecond</a>&lt; <a class="el" href="class_f_e_a_t_1_1_global_1_1_vector.html">Global::Vector</a>&lt; typename LocalFilter_::VectorType, Mirror_ &gt;, <a class="el" href="class_f_e_a_t_1_1_global_1_1_filter.html">Global::Filter</a>&lt; LocalFilter_, Mirror_ &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#aec39e5544cf879ec05d525baa29c3d2e">new_schwarz_precond</a> (std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename LocalFilter_::VectorType &gt; &gt; local_solver, const <a class="el" href="class_f_e_a_t_1_1_global_1_1_filter.html">Global::Filter</a>&lt; LocalFilter_, Mirror_ &gt; &amp;filter)</td></tr>
<tr class="memdesc:aec39e5544cf879ec05d525baa29c3d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_schwarz_precond.html" title="Schwarz preconditioner class template declaration.">SchwarzPrecond</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#aec39e5544cf879ec05d525baa29c3d2e">More...</a><br /></td></tr>
<tr class="separator:aec39e5544cf879ec05d525baa29c3d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1c4d327721b5ac5842ab97e39a4caf"><td class="memTemplParams" colspan="2">template&lt;typename Functional_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a0b1c4d327721b5ac5842ab97e39a4caf"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_secant_linesearch.html">SecantLinesearch</a>&lt; Functional_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a0b1c4d327721b5ac5842ab97e39a4caf">new_secant_linesearch</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, Functional_ &amp;functional, Filter_ &amp;filter)</td></tr>
<tr class="memdesc:a0b1c4d327721b5ac5842ab97e39a4caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_secant_linesearch.html" title="Secant linesearch.">SecantLinesearch</a> object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#a0b1c4d327721b5ac5842ab97e39a4caf">More...</a><br /></td></tr>
<tr class="separator:a0b1c4d327721b5ac5842ab97e39a4caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f2926c35bfaded84ec7bd8aa30c4cd"><td class="memTemplParams" colspan="2">template&lt;typename Functional_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a57f2926c35bfaded84ec7bd8aa30c4cd"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_secant_linesearch.html">SecantLinesearch</a>&lt; Functional_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a57f2926c35bfaded84ec7bd8aa30c4cd">new_secant_linesearch</a> (Functional_ &amp;functional, Filter_ &amp;filter, typename Functional_::DataType secant_step=<a class="el" href="class_f_e_a_t_1_1_solver_1_1_secant_linesearch.html">SecantLinesearch</a>&lt; Functional_, Filter_ &gt;::secant_step_default, bool keep_iterates=false)</td></tr>
<tr class="memdesc:a57f2926c35bfaded84ec7bd8aa30c4cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_secant_linesearch.html" title="Secant linesearch.">SecantLinesearch</a> object.  <a href="namespace_f_e_a_t_1_1_solver.html#a57f2926c35bfaded84ec7bd8aa30c4cd">More...</a><br /></td></tr>
<tr class="separator:a57f2926c35bfaded84ec7bd8aa30c4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dc55f7293235eaed4281f8168361af"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a82dc55f7293235eaed4281f8168361af"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_o_r_precond.html">SORPrecond</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a82dc55f7293235eaed4281f8168361af">new_sor_precond</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, <a class="el" href="namespace_f_e_a_t.html#a050b7378896da037a96211e8db059029">PreferredBackend</a> backend, const Matrix_ &amp;matrix, const Filter_ &amp;filter)</td></tr>
<tr class="memdesc:a82dc55f7293235eaed4281f8168361af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_o_r_precond.html" title="SOR preconditioner implementation.">SORPrecond</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#a82dc55f7293235eaed4281f8168361af">More...</a><br /></td></tr>
<tr class="separator:a82dc55f7293235eaed4281f8168361af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10946359e692cbc960308376ef8badd"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:af10946359e692cbc960308376ef8badd"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_o_r_precond.html">SORPrecond</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#af10946359e692cbc960308376ef8badd">new_sor_precond</a> (<a class="el" href="namespace_f_e_a_t.html#a050b7378896da037a96211e8db059029">PreferredBackend</a> backend, const Matrix_ &amp;matrix, const Filter_ &amp;filter, const typename Matrix_::DataType omega=typename Matrix_::DataType(1))</td></tr>
<tr class="memdesc:af10946359e692cbc960308376ef8badd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_o_r_precond.html" title="SOR preconditioner implementation.">SORPrecond</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#af10946359e692cbc960308376ef8badd">More...</a><br /></td></tr>
<tr class="separator:af10946359e692cbc960308376ef8badd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df4054f8fde42d2a87893cf9ef1c865"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a6df4054f8fde42d2a87893cf9ef1c865"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_s_o_r_precond.html">SSORPrecond</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a6df4054f8fde42d2a87893cf9ef1c865">new_ssor_precond</a> (const <a class="el" href="namespace_f_e_a_t.html#a050b7378896da037a96211e8db059029">PreferredBackend</a> backend, const Matrix_ &amp;matrix, const Filter_ &amp;filter, const typename Matrix_::DataType omega=typename Matrix_::DataType(1))</td></tr>
<tr class="memdesc:a6df4054f8fde42d2a87893cf9ef1c865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_s_o_r_precond.html" title="SSOR preconditioner implementation.">SSORPrecond</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#a6df4054f8fde42d2a87893cf9ef1c865">More...</a><br /></td></tr>
<tr class="separator:a6df4054f8fde42d2a87893cf9ef1c865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace7dd0b283bfeac3bba4392e013ed09"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:aace7dd0b283bfeac3bba4392e013ed09"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_s_o_r_precond.html">SSORPrecond</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#aace7dd0b283bfeac3bba4392e013ed09">new_ssor_precond</a> (const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;section_name, <a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *section, <a class="el" href="namespace_f_e_a_t.html#a050b7378896da037a96211e8db059029">PreferredBackend</a> backend, const Matrix_ &amp;matrix, const Filter_ &amp;filter)</td></tr>
<tr class="memdesc:aace7dd0b283bfeac3bba4392e013ed09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_s_o_r_precond.html" title="SSOR preconditioner implementation.">SSORPrecond</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>.  <a href="namespace_f_e_a_t_1_1_solver.html#aace7dd0b283bfeac3bba4392e013ed09">More...</a><br /></td></tr>
<tr class="separator:aace7dd0b283bfeac3bba4392e013ed09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46fd1bc80db37277acac65c223799ad"><td class="memTemplParams" colspan="2">template&lt;typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:ae46fd1bc80db37277acac65c223799ad"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_super_l_u.html">SuperLU</a>&lt; Matrix_, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ae46fd1bc80db37277acac65c223799ad">new_superlu</a> (const Matrix_ &amp;matrix, const Filter_ &amp;filter)</td></tr>
<tr class="memdesc:ae46fd1bc80db37277acac65c223799ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_super_l_u.html" title="(distributed) SuperLU direct sparse solver">SuperLU</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#ae46fd1bc80db37277acac65c223799ad">More...</a><br /></td></tr>
<tr class="separator:ae46fd1bc80db37277acac65c223799ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad814c30df2abc2e0151dfa9792eabc75"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_umfpack.html">Umfpack</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ad814c30df2abc2e0151dfa9792eabc75">new_umfpack</a> (const <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_sparse_matrix_c_s_r.html">LAFEM::SparseMatrixCSR</a>&lt; double, <a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1">Index</a> &gt; &amp;matrix)</td></tr>
<tr class="memdesc:ad814c30df2abc2e0151dfa9792eabc75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_umfpack.html" title="UMFPACK solver class.">Umfpack</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#ad814c30df2abc2e0151dfa9792eabc75">More...</a><br /></td></tr>
<tr class="separator:ad814c30df2abc2e0151dfa9792eabc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764bfc8e9007d466dea48527b04a8b4d"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_umfpack_mean.html">UmfpackMean</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a764bfc8e9007d466dea48527b04a8b4d">new_umfpack_mean</a> (const <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_sparse_matrix_c_s_r.html">LAFEM::SparseMatrixCSR</a>&lt; double, <a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1">Index</a> &gt; &amp;matrix, const <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_dense_vector.html">LAFEM::DenseVector</a>&lt; double, <a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1">Index</a> &gt; &amp;weight_vector)</td></tr>
<tr class="memdesc:a764bfc8e9007d466dea48527b04a8b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_umfpack_mean.html" title="UMFPACK Mean solver class.">UmfpackMean</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#a764bfc8e9007d466dea48527b04a8b4d">More...</a><br /></td></tr>
<tr class="separator:a764bfc8e9007d466dea48527b04a8b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa452c9e3a871162b9d112beaa4bcfb09"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_umfpack_mean.html">UmfpackMean</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#aa452c9e3a871162b9d112beaa4bcfb09">new_umfpack_mean</a> (const <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_sparse_matrix_c_s_r.html">LAFEM::SparseMatrixCSR</a>&lt; double, <a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1">Index</a> &gt; &amp;matrix, const <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_mean_filter.html">LAFEM::MeanFilter</a>&lt; double, <a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1">Index</a> &gt; &amp;filter)</td></tr>
<tr class="memdesc:aa452c9e3a871162b9d112beaa4bcfb09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_umfpack_mean.html" title="UMFPACK Mean solver class.">UmfpackMean</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#aa452c9e3a871162b9d112beaa4bcfb09">More...</a><br /></td></tr>
<tr class="separator:aa452c9e3a871162b9d112beaa4bcfb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2958bd09bea2573890967fceb38cb8ae"><td class="memTemplParams" colspan="2">template&lt;typename MatrixA_ , typename MatrixB_ , typename MatrixD_ , typename FilterV_ , typename FilterP_ &gt; </td></tr>
<tr class="memitem:a2958bd09bea2573890967fceb38cb8ae"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_uzawa_precond.html">UzawaPrecond</a>&lt; MatrixA_, MatrixB_, MatrixD_, FilterV_, FilterP_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a2958bd09bea2573890967fceb38cb8ae">new_uzawa_precond</a> (const MatrixA_ &amp;matrix_a, const MatrixB_ &amp;matrix_b, const MatrixD_ &amp;matrix_d, const FilterV_ &amp;filter_v, const FilterP_ &amp;filter_p, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename MatrixB_::VectorTypeL &gt; &gt; solver_a, std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename MatrixD_::VectorTypeL &gt; &gt; solver_s, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a8c9301b94ea72379786a83666a86c4ff">UzawaType</a> type=<a class="el" href="namespace_f_e_a_t_1_1_solver.html#a8c9301b94ea72379786a83666a86c4ffaa0e17e2709a0404ae3d7de03b8ea9093">UzawaType::diagonal</a>, bool auto_init_s=true)</td></tr>
<tr class="memdesc:a2958bd09bea2573890967fceb38cb8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_uzawa_precond.html" title="Uzawa preconditioner.">UzawaPrecond</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#a2958bd09bea2573890967fceb38cb8ae">More...</a><br /></td></tr>
<tr class="separator:a2958bd09bea2573890967fceb38cb8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d16cb5da09d09a13d1680c576ccf22"><td class="memTemplParams" colspan="2">template&lt;typename MatrixA_ , typename MatrixB_ , typename MatrixD_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:ab0d16cb5da09d09a13d1680c576ccf22"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_vanka.html">Vanka</a>&lt; <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_saddle_point_matrix.html">LAFEM::SaddlePointMatrix</a>&lt; MatrixA_, MatrixB_, MatrixD_ &gt;, Filter_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab0d16cb5da09d09a13d1680c576ccf22">new_vanka</a> (const <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_saddle_point_matrix.html">LAFEM::SaddlePointMatrix</a>&lt; MatrixA_, MatrixB_, MatrixD_ &gt; &amp;matrix, const Filter_ &amp;filter, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a56a1737a447bf0816faf68de552c2064">VankaType</a> type, typename MatrixA_::DataType omega=typename MatrixA_::DataType(1), <a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1">Index</a> num_iter=<a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1">Index</a>(1))</td></tr>
<tr class="memdesc:ab0d16cb5da09d09a13d1680c576ccf22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_vanka.html" title="Vanka preconditioner/smoother class template.">Vanka</a> solver object.  <a href="namespace_f_e_a_t_1_1_solver.html#ab0d16cb5da09d09a13d1680c576ccf22">More...</a><br /></td></tr>
<tr class="separator:ab0d16cb5da09d09a13d1680c576ccf22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6b79b11fc66593e4336d1259a158b7"><td class="memTemplParams" colspan="2">template&lt;typename Vector_ , typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:a8e6b79b11fc66593e4336d1259a158b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab1c941bc4fb3a678ef08e84cd3fa35ed">Status</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a8e6b79b11fc66593e4336d1259a158b7">solve</a> (<a class="el" href="class_f_e_a_t_1_1_solver_1_1_iterative_solver.html">IterativeSolver</a>&lt; Vector_ &gt; &amp;solver, Vector_ &amp;vec_sol, const Vector_ &amp;vec_rhs, const Matrix_ &amp;matrix, const Filter_ &amp;filter)</td></tr>
<tr class="memdesc:a8e6b79b11fc66593e4336d1259a158b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of <a class="el" href="namespace_f_e_a_t_1_1_solver.html#afaf7fb5797216195651b6d22eaadc8d2" title="Solve linear system with initial solution guess.">solve()</a> for <a class="el" href="class_f_e_a_t_1_1_solver_1_1_iterative_solver.html" title="Abstract base-class for iterative solvers.">IterativeSolver</a> solvers.  <a href="namespace_f_e_a_t_1_1_solver.html#a8e6b79b11fc66593e4336d1259a158b7">More...</a><br /></td></tr>
<tr class="separator:a8e6b79b11fc66593e4336d1259a158b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf7fb5797216195651b6d22eaadc8d2"><td class="memTemplParams" colspan="2">template&lt;typename Vector_ , typename Matrix_ , typename Filter_ &gt; </td></tr>
<tr class="memitem:afaf7fb5797216195651b6d22eaadc8d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab1c941bc4fb3a678ef08e84cd3fa35ed">Status</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#afaf7fb5797216195651b6d22eaadc8d2">solve</a> (<a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; Vector_ &gt; &amp;solver, Vector_ &amp;vec_sol, const Vector_ &amp;vec_rhs, const Matrix_ &amp;matrix, const Filter_ &amp;filter)</td></tr>
<tr class="memdesc:afaf7fb5797216195651b6d22eaadc8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve linear system with initial solution guess.  <a href="namespace_f_e_a_t_1_1_solver.html#afaf7fb5797216195651b6d22eaadc8d2">More...</a><br /></td></tr>
<tr class="separator:afaf7fb5797216195651b6d22eaadc8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d657f3235d3857164ec176b6958d87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a06d657f3235d3857164ec176b6958d87">status_success</a> (<a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab1c941bc4fb3a678ef08e84cd3fa35ed">Status</a> status)</td></tr>
<tr class="memdesc:a06d657f3235d3857164ec176b6958d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status success check function.  <a href="namespace_f_e_a_t_1_1_solver.html#a06d657f3235d3857164ec176b6958d87">More...</a><br /></td></tr>
<tr class="separator:a06d657f3235d3857164ec176b6958d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p ><a class="el" href="namespace_f_e_a_t_1_1_solver.html" title="Solver namespace.">Solver</a> namespace. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ab3701336d3327b2a233a089c5ae17ef7" name="ab3701336d3327b2a233a089c5ae17ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3701336d3327b2a233a089c5ae17ef7">&#9670;&#160;</a></span>BiCGStabLPreconVariant</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab3701336d3327b2a233a089c5ae17ef7">FEAT::Solver::BiCGStabLPreconVariant</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum for diffent preconditioning variants for <a class="el" href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab_l.html" title="(Preconditioned) BiCGStab(l) solver implementation">BiCGStabL</a>. </p>

<p class="definition">Definition at line <a class="el" href="bicgstabl_8hpp_source.html#l00022">22</a> of file <a class="el" href="bicgstabl_8hpp_source.html">bicgstabl.hpp</a>.</p>

</div>
</div>
<a id="a84303e5a9eeeb8bd47fb8e76c3d3694e" name="a84303e5a9eeeb8bd47fb8e76c3d3694e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84303e5a9eeeb8bd47fb8e76c3d3694e">&#9670;&#160;</a></span>BiCGStabPreconVariant</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a84303e5a9eeeb8bd47fb8e76c3d3694e">FEAT::Solver::BiCGStabPreconVariant</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum for different preconditioning variants for <a class="el" href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab.html" title="(Preconditioned) Bi-Conjugate Gradient Stabilized solver implementation">BiCGStab</a>. </p>

<p class="definition">Definition at line <a class="el" href="bicgstab_8hpp_source.html#l00021">21</a> of file <a class="el" href="bicgstab_8hpp_source.html">bicgstab.hpp</a>.</p>

</div>
</div>
<a id="aa3e1a0d5d6876f6d4fe16f71003b257c" name="aa3e1a0d5d6876f6d4fe16f71003b257c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e1a0d5d6876f6d4fe16f71003b257c">&#9670;&#160;</a></span>ExpressionType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespace_f_e_a_t_1_1_solver.html#aa3e1a0d5d6876f6d4fe16f71003b257c">FEAT::Solver::ExpressionType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expression <a class="el" href="namespace_f_e_a_t_1_1_type.html" title="Type namespace.">Type</a> enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa3e1a0d5d6876f6d4fe16f71003b257cadbb68c86754ccad2ee2908a92f34d3e4" name="aa3e1a0d5d6876f6d4fe16f71003b257cadbb68c86754ccad2ee2908a92f34d3e4"></a>start_solve&#160;</td><td class="fielddoc"><p >start new solve process </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3e1a0d5d6876f6d4fe16f71003b257ca43355c9ca3b3625921863fbb1d7a6125" name="aa3e1a0d5d6876f6d4fe16f71003b257ca43355c9ca3b3625921863fbb1d7a6125"></a>end_solve&#160;</td><td class="fielddoc"><p >end last solve process </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3e1a0d5d6876f6d4fe16f71003b257caced4c9c427983093e246d4489b774883" name="aa3e1a0d5d6876f6d4fe16f71003b257caced4c9c427983093e246d4489b774883"></a>call_precond&#160;</td><td class="fielddoc"><p >call preconditioner </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3e1a0d5d6876f6d4fe16f71003b257ca4c8125346940e0b89395bbea04351a3d" name="aa3e1a0d5d6876f6d4fe16f71003b257ca4c8125346940e0b89395bbea04351a3d"></a>call_precond_l&#160;</td><td class="fielddoc"><p >call L preconditioner </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3e1a0d5d6876f6d4fe16f71003b257cabf7f509bcd748b9cbd4199fd1b632e3d" name="aa3e1a0d5d6876f6d4fe16f71003b257cabf7f509bcd748b9cbd4199fd1b632e3d"></a>call_precond_r&#160;</td><td class="fielddoc"><p >call R preconditioner </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3e1a0d5d6876f6d4fe16f71003b257caa3cad12e93c7ff67dd8d0e96cfe69f25" name="aa3e1a0d5d6876f6d4fe16f71003b257caa3cad12e93c7ff67dd8d0e96cfe69f25"></a>call_smoother&#160;</td><td class="fielddoc"><p >call smoother </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3e1a0d5d6876f6d4fe16f71003b257ca7bd4df8d10de98c0e1a2ad102544e985" name="aa3e1a0d5d6876f6d4fe16f71003b257ca7bd4df8d10de98c0e1a2ad102544e985"></a>call_coarse_solver&#160;</td><td class="fielddoc"><p >call coarse grid solver </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3e1a0d5d6876f6d4fe16f71003b257ca6475f0c19ab92149df68660d6be44562" name="aa3e1a0d5d6876f6d4fe16f71003b257ca6475f0c19ab92149df68660d6be44562"></a>defect&#160;</td><td class="fielddoc"><p >annotate iterations defect </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3e1a0d5d6876f6d4fe16f71003b257ca215c68ef0f50ad9d15cedfdc1f5d2e73" name="aa3e1a0d5d6876f6d4fe16f71003b257ca215c68ef0f50ad9d15cedfdc1f5d2e73"></a>timings&#160;</td><td class="fielddoc"><p >annotate iterations timings </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3e1a0d5d6876f6d4fe16f71003b257cacb59b105810592a9797b58f0af69d178" name="aa3e1a0d5d6876f6d4fe16f71003b257cacb59b105810592a9797b58f0af69d178"></a>level_timings&#160;</td><td class="fielddoc"><p >annotate level timings </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3e1a0d5d6876f6d4fe16f71003b257ca39f507840263ff9a6dec828feac5e180" name="aa3e1a0d5d6876f6d4fe16f71003b257ca39f507840263ff9a6dec828feac5e180"></a>prol&#160;</td><td class="fielddoc"><p >prolonation (multigrid) </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3e1a0d5d6876f6d4fe16f71003b257ca65e8800b5c6800aad896f888b2a62afc" name="aa3e1a0d5d6876f6d4fe16f71003b257ca65e8800b5c6800aad896f888b2a62afc"></a>rest&#160;</td><td class="fielddoc"><p >restriction (multigrid) </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3e1a0d5d6876f6d4fe16f71003b257ca763e460c228fa243e8e179114dd649bd" name="aa3e1a0d5d6876f6d4fe16f71003b257ca763e460c228fa243e8e179114dd649bd"></a>call_uzawa_s&#160;</td><td class="fielddoc"><p >call S matrix solver (uzawa complement) </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3e1a0d5d6876f6d4fe16f71003b257ca2ed022f43272bfb055f81b2b900b5163" name="aa3e1a0d5d6876f6d4fe16f71003b257ca2ed022f43272bfb055f81b2b900b5163"></a>call_uzawa_a&#160;</td><td class="fielddoc"><p >call A matrix solver (uzawa complement) </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="expression_8hpp_source.html#l00023">23</a> of file <a class="el" href="expression_8hpp_source.html">expression.hpp</a>.</p>

</div>
</div>
<a id="a9d7f089c4ca7981d407aa7a7038f6e23" name="a9d7f089c4ca7981d407aa7a7038f6e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7f089c4ca7981d407aa7a7038f6e23">&#9670;&#160;</a></span>MultiGridAdaptCGC</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a9d7f089c4ca7981d407aa7a7038f6e23">FEAT::Solver::MultiGridAdaptCGC</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multigrid adaptive Coarse-Grid-Correction enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9d7f089c4ca7981d407aa7a7038f6e23a4457d440870ad6d42bab9082d9bf9b61" name="a9d7f089c4ca7981d407aa7a7038f6e23a4457d440870ad6d42bab9082d9bf9b61"></a>Fixed&#160;</td><td class="fielddoc"><p >fixed coarse grid correction damping </p>
</td></tr>
<tr><td class="fieldname"><a id="a9d7f089c4ca7981d407aa7a7038f6e23ae2ff515050bfd1fe926c0c1f3764dc45" name="a9d7f089c4ca7981d407aa7a7038f6e23ae2ff515050bfd1fe926c0c1f3764dc45"></a>MinEnergy&#160;</td><td class="fielddoc"><p >Energy-Minimization. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9d7f089c4ca7981d407aa7a7038f6e23a4e8e2d409757b43a89e7e03a70f34b54" name="a9d7f089c4ca7981d407aa7a7038f6e23a4e8e2d409757b43a89e7e03a70f34b54"></a>MinDefect&#160;</td><td class="fielddoc"><p >Defect-Minimization. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="multigrid_8hpp_source.html#l00039">39</a> of file <a class="el" href="multigrid_8hpp_source.html">multigrid.hpp</a>.</p>

</div>
</div>
<a id="a5b14b494b949c5eecc622f4ad6e2d59b" name="a5b14b494b949c5eecc622f4ad6e2d59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b14b494b949c5eecc622f4ad6e2d59b">&#9670;&#160;</a></span>MultiGridCycle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a5b14b494b949c5eecc622f4ad6e2d59b">FEAT::Solver::MultiGridCycle</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multigrid Cycle enumeration. </p>
<p >This enumeration specifies the various cycles supported by the <a class="el" href="class_f_e_a_t_1_1_solver_1_1_multi_grid.html" title="Multigrid preconditioner implementation.">MultiGrid</a> solver. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5b14b494b949c5eecc622f4ad6e2d59ba5206560a306a2e085a437fd258eb57ce" name="a5b14b494b949c5eecc622f4ad6e2d59ba5206560a306a2e085a437fd258eb57ce"></a>V&#160;</td><td class="fielddoc"><p >Multigrid V-Cycle. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5b14b494b949c5eecc622f4ad6e2d59ba800618943025315f869e4e1f09471012" name="a5b14b494b949c5eecc622f4ad6e2d59ba800618943025315f869e4e1f09471012"></a>F&#160;</td><td class="fielddoc"><p >Multigrid F-Cycle. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5b14b494b949c5eecc622f4ad6e2d59ba61e9c06ea9a85a5088a499df6458d276" name="a5b14b494b949c5eecc622f4ad6e2d59ba61e9c06ea9a85a5088a499df6458d276"></a>W&#160;</td><td class="fielddoc"><p >Multigrid W-Cycle. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="multigrid_8hpp_source.html#l00026">26</a> of file <a class="el" href="multigrid_8hpp_source.html">multigrid.hpp</a>.</p>

</div>
</div>
<a id="a651714c882641671d73d78382d7d77ee" name="a651714c882641671d73d78382d7d77ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a651714c882641671d73d78382d7d77ee">&#9670;&#160;</a></span>NLCGDirectionUpdate</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a651714c882641671d73d78382d7d77ee">FEAT::Solver::NLCGDirectionUpdate</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum for <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_c_g.html" title="Nonlinear Conjugate Gradient method for finding a minimum of an functional&#39;s gradient.">NLCG</a> search direction updates. </p>

<p class="definition">Definition at line <a class="el" href="nlcg_8hpp_source.html#l00024">24</a> of file <a class="el" href="nlcg_8hpp_source.html">nlcg.hpp</a>.</p>

</div>
</div>
<a id="a892c0210316c5cb1cf89035147242c36" name="a892c0210316c5cb1cf89035147242c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892c0210316c5cb1cf89035147242c36">&#9670;&#160;</a></span>PlotMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a892c0210316c5cb1cf89035147242c36">FEAT::Solver::PlotMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_f_e_a_t_1_1_solver.html" title="Solver namespace.">Solver</a> plot modes enumeration. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a892c0210316c5cb1cf89035147242c36a334c4a4c42fdb79d7ebc3e73b517e6f8" name="a892c0210316c5cb1cf89035147242c36a334c4a4c42fdb79d7ebc3e73b517e6f8"></a>none&#160;</td><td class="fielddoc"><p >No plotting whatsoever. </p>
</td></tr>
<tr><td class="fieldname"><a id="a892c0210316c5cb1cf89035147242c36a37302ccecb8ae11c64170bc6bfa44eaa" name="a892c0210316c5cb1cf89035147242c36a37302ccecb8ae11c64170bc6bfa44eaa"></a>iter&#160;</td><td class="fielddoc"><p >Plot every iteration (if applicable) </p>
</td></tr>
<tr><td class="fieldname"><a id="a892c0210316c5cb1cf89035147242c36aa80da1282f2c775bbc5f2c92c836968b" name="a892c0210316c5cb1cf89035147242c36aa80da1282f2c775bbc5f2c92c836968b"></a>summary&#160;</td><td class="fielddoc"><p >Plot a summary after each solver run. </p>
</td></tr>
<tr><td class="fieldname"><a id="a892c0210316c5cb1cf89035147242c36aa181a603769c1f98ad927e7367c7aa51" name="a892c0210316c5cb1cf89035147242c36aa181a603769c1f98ad927e7367c7aa51"></a>all&#160;</td><td class="fielddoc"><p >Plot every iteration (if applicable) and a summary. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="iterative_8hpp_source.html#l00055">55</a> of file <a class="el" href="iterative_8hpp_source.html">iterative.hpp</a>.</p>

</div>
</div>
<a id="ab1c941bc4fb3a678ef08e84cd3fa35ed" name="ab1c941bc4fb3a678ef08e84cd3fa35ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c941bc4fb3a678ef08e84cd3fa35ed">&#9670;&#160;</a></span>Status</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab1c941bc4fb3a678ef08e84cd3fa35ed">FEAT::Solver::Status</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_f_e_a_t_1_1_solver.html" title="Solver namespace.">Solver</a> status return codes enumeration. </p>
<p >This enumeration defined the solver status return codes, which specify whether the solver application was successful or failed due to some reason. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab1c941bc4fb3a678ef08e84cd3fa35eda5e543256c480ac577d30f76f9120eb74" name="ab1c941bc4fb3a678ef08e84cd3fa35eda5e543256c480ac577d30f76f9120eb74"></a>undefined&#160;</td><td class="fielddoc"><p >undefined status </p>
</td></tr>
<tr><td class="fieldname"><a id="ab1c941bc4fb3a678ef08e84cd3fa35eda3c709b10a5d47ba33d85337dd9110917" name="ab1c941bc4fb3a678ef08e84cd3fa35eda3c709b10a5d47ba33d85337dd9110917"></a>progress&#160;</td><td class="fielddoc"><p >continue iteration (internal use only) </p>
</td></tr>
<tr><td class="fieldname"><a id="ab1c941bc4fb3a678ef08e84cd3fa35eda260ca9dd8a4577fc00b7bd5810298076" name="ab1c941bc4fb3a678ef08e84cd3fa35eda260ca9dd8a4577fc00b7bd5810298076"></a>success&#160;</td><td class="fielddoc"><p >solving successful (convergence criterion fulfilled) </p>
</td></tr>
<tr><td class="fieldname"><a id="ab1c941bc4fb3a678ef08e84cd3fa35edadfb7069bfc6e0064a6c667626eca07b4" name="ab1c941bc4fb3a678ef08e84cd3fa35edadfb7069bfc6e0064a6c667626eca07b4"></a>aborted&#160;</td><td class="fielddoc"><p >premature abort (solver aborted due to internal errors or preconditioner failure) </p>
</td></tr>
<tr><td class="fieldname"><a id="ab1c941bc4fb3a678ef08e84cd3fa35edadb5a93fff259ad3ff2017a64912fa156" name="ab1c941bc4fb3a678ef08e84cd3fa35edadb5a93fff259ad3ff2017a64912fa156"></a>diverged&#160;</td><td class="fielddoc"><p >solver diverged (divergence criterion fulfilled) </p>
</td></tr>
<tr><td class="fieldname"><a id="ab1c941bc4fb3a678ef08e84cd3fa35edaa520882cd714abbd1bf9f72d23990f0e" name="ab1c941bc4fb3a678ef08e84cd3fa35edaa520882cd714abbd1bf9f72d23990f0e"></a>max_iter&#160;</td><td class="fielddoc"><p >solver reached maximum iterations </p>
</td></tr>
<tr><td class="fieldname"><a id="ab1c941bc4fb3a678ef08e84cd3fa35edaa3d1e0a7dd736bc430ba471d9dfdf3a2" name="ab1c941bc4fb3a678ef08e84cd3fa35edaa3d1e0a7dd736bc430ba471d9dfdf3a2"></a>stagnated&#160;</td><td class="fielddoc"><p >solver stagnated (stagnation criterion fulfilled) </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="kernel_2solver_2base_8hpp_source.html#l00048">48</a> of file <a class="el" href="kernel_2solver_2base_8hpp_source.html">base.hpp</a>.</p>

</div>
</div>
<a id="a8c9301b94ea72379786a83666a86c4ff" name="a8c9301b94ea72379786a83666a86c4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9301b94ea72379786a83666a86c4ff">&#9670;&#160;</a></span>UzawaType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a8c9301b94ea72379786a83666a86c4ff">FEAT::Solver::UzawaType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uzawa preconditioner type. </p>
<p >This enumeration specifies the various preconditioner types implemented in the <a class="el" href="class_f_e_a_t_1_1_solver_1_1_uzawa_precond.html" title="Uzawa preconditioner.">UzawaPrecond</a> class template. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8c9301b94ea72379786a83666a86c4ffaa0e17e2709a0404ae3d7de03b8ea9093" name="a8c9301b94ea72379786a83666a86c4ffaa0e17e2709a0404ae3d7de03b8ea9093"></a>diagonal&#160;</td><td class="fielddoc"><p >diagonal Uzawa preconditioner </p>
</td></tr>
<tr><td class="fieldname"><a id="a8c9301b94ea72379786a83666a86c4ffa81e073b428b50247daba38531dcf412a" name="a8c9301b94ea72379786a83666a86c4ffa81e073b428b50247daba38531dcf412a"></a>lower&#160;</td><td class="fielddoc"><p >lower-diagonal Uzawa preconditioner </p>
</td></tr>
<tr><td class="fieldname"><a id="a8c9301b94ea72379786a83666a86c4ffa0122b4c2c01ee1c698ecc309d2b8eb5a" name="a8c9301b94ea72379786a83666a86c4ffa0122b4c2c01ee1c698ecc309d2b8eb5a"></a>upper&#160;</td><td class="fielddoc"><p >upper-diagonal Uzawa preconditioner </p>
</td></tr>
<tr><td class="fieldname"><a id="a8c9301b94ea72379786a83666a86c4ffae9dc924f238fa6cc29465942875fe8f0" name="a8c9301b94ea72379786a83666a86c4ffae9dc924f238fa6cc29465942875fe8f0"></a>full&#160;</td><td class="fielddoc"><p >full Uzawa preconditioner </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="uzawa__precond_8hpp_source.html#l00030">30</a> of file <a class="el" href="uzawa__precond_8hpp_source.html">uzawa_precond.hpp</a>.</p>

</div>
</div>
<a id="a56a1737a447bf0816faf68de552c2064" name="a56a1737a447bf0816faf68de552c2064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a1737a447bf0816faf68de552c2064">&#9670;&#160;</a></span>VankaType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespace_f_e_a_t_1_1_solver.html#a56a1737a447bf0816faf68de552c2064">FEAT::Solver::VankaType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_f_e_a_t_1_1_solver_1_1_vanka.html" title="Vanka preconditioner/smoother class template.">Vanka</a> type enumeration. </p>
<p >This enumeration specifies the various types of supported <a class="el" href="class_f_e_a_t_1_1_solver_1_1_vanka.html" title="Vanka preconditioner/smoother class template.">Vanka</a> variants. See the documentation of the <a class="el" href="class_f_e_a_t_1_1_solver_1_1_vanka.html" title="Vanka preconditioner/smoother class template.">Vanka</a> solver class template for details. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a56a1737a447bf0816faf68de552c2064ac5727c4f02effaecdb0ff7e5356e6beb" name="a56a1737a447bf0816faf68de552c2064ac5727c4f02effaecdb0ff7e5356e6beb"></a>nodal_diag_mult&#160;</td><td class="fielddoc"><p >Nodal diagonal <a class="el" href="class_f_e_a_t_1_1_solver_1_1_vanka.html" title="Vanka preconditioner/smoother class template.">Vanka</a> type (multiplicative) </p>
</td></tr>
<tr><td class="fieldname"><a id="a56a1737a447bf0816faf68de552c2064a2781aeb6fbdf11b921a8f6432e669255" name="a56a1737a447bf0816faf68de552c2064a2781aeb6fbdf11b921a8f6432e669255"></a>nodal_full_mult&#160;</td><td class="fielddoc"><p >Nodal full <a class="el" href="class_f_e_a_t_1_1_solver_1_1_vanka.html" title="Vanka preconditioner/smoother class template.">Vanka</a> type (multiplicative) </p>
</td></tr>
<tr><td class="fieldname"><a id="a56a1737a447bf0816faf68de552c2064ac14d2f1f2526ae3542b6c4f0f83ca91d" name="a56a1737a447bf0816faf68de552c2064ac14d2f1f2526ae3542b6c4f0f83ca91d"></a>block_diag_mult&#160;</td><td class="fielddoc"><p >Blocked diagonal <a class="el" href="class_f_e_a_t_1_1_solver_1_1_vanka.html" title="Vanka preconditioner/smoother class template.">Vanka</a> type (multiplicative) </p>
</td></tr>
<tr><td class="fieldname"><a id="a56a1737a447bf0816faf68de552c2064ac5ac3da34cdc11a0ca495ac901f9bde6" name="a56a1737a447bf0816faf68de552c2064ac5ac3da34cdc11a0ca495ac901f9bde6"></a>block_full_mult&#160;</td><td class="fielddoc"><p >Blocked full <a class="el" href="class_f_e_a_t_1_1_solver_1_1_vanka.html" title="Vanka preconditioner/smoother class template.">Vanka</a> type (multiplicative) </p>
</td></tr>
<tr><td class="fieldname"><a id="a56a1737a447bf0816faf68de552c2064ad3ed8ab1ba34fa91bcb2988fb8a7da12" name="a56a1737a447bf0816faf68de552c2064ad3ed8ab1ba34fa91bcb2988fb8a7da12"></a>nodal_diag_add&#160;</td><td class="fielddoc"><p >Nodal diagonal <a class="el" href="class_f_e_a_t_1_1_solver_1_1_vanka.html" title="Vanka preconditioner/smoother class template.">Vanka</a> type (additive) </p>
</td></tr>
<tr><td class="fieldname"><a id="a56a1737a447bf0816faf68de552c2064a66880c35558978d1aee7b9bef14d1d25" name="a56a1737a447bf0816faf68de552c2064a66880c35558978d1aee7b9bef14d1d25"></a>nodal_full_add&#160;</td><td class="fielddoc"><p >Nodal full <a class="el" href="class_f_e_a_t_1_1_solver_1_1_vanka.html" title="Vanka preconditioner/smoother class template.">Vanka</a> type (additive) </p>
</td></tr>
<tr><td class="fieldname"><a id="a56a1737a447bf0816faf68de552c2064a411b83f39a65b8bad2c5f914c20ebd8d" name="a56a1737a447bf0816faf68de552c2064a411b83f39a65b8bad2c5f914c20ebd8d"></a>block_diag_add&#160;</td><td class="fielddoc"><p >Blocked diagonal <a class="el" href="class_f_e_a_t_1_1_solver_1_1_vanka.html" title="Vanka preconditioner/smoother class template.">Vanka</a> type (additive) </p>
</td></tr>
<tr><td class="fieldname"><a id="a56a1737a447bf0816faf68de552c2064af88ce1fb8b7ece17b0f496a2eb5d712d" name="a56a1737a447bf0816faf68de552c2064af88ce1fb8b7ece17b0f496a2eb5d712d"></a>block_full_add&#160;</td><td class="fielddoc"><p >Blocked full <a class="el" href="class_f_e_a_t_1_1_solver_1_1_vanka.html" title="Vanka preconditioner/smoother class template.">Vanka</a> type (additive) </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="vanka_8hpp_source.html#l00893">893</a> of file <a class="el" href="vanka_8hpp_source.html">vanka.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a50bd05e5f49c4291c2e0fc0240855c68" name="a50bd05e5f49c4291c2e0fc0240855c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50bd05e5f49c4291c2e0fc0240855c68">&#9670;&#160;</a></span>new_alglib_mincg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functional_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_l_g_l_i_b_min_c_g.html">ALGLIBMinCG</a>&lt; Functional_, Filter_ &gt; &gt; FEAT::Solver::new_alglib_mincg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functional_ &amp;&#160;</td>
          <td class="paramname"><em>functional_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_l_g_l_i_b_min_c_g.html" title="Wrapper around ALGLIB&#39;s mincg implementation for minimising an functional&#39;s gradient.">ALGLIBMinCG</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">functional_</td><td>The functional</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_</td><td>The system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_l_g_l_i_b_min_c_g.html" title="Wrapper around ALGLIB&#39;s mincg implementation for minimising an functional&#39;s gradient.">ALGLIBMinCG</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000006">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="alglib__wrapper_8hpp_source.html#l01093">1093</a> of file <a class="el" href="alglib__wrapper_8hpp_source.html">alglib_wrapper.hpp</a>.</p>

</div>
</div>
<a id="ac682c52ad4f336c00562ac658d88befa" name="ac682c52ad4f336c00562ac658d88befa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac682c52ad4f336c00562ac658d88befa">&#9670;&#160;</a></span>new_alglib_mincg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functional_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_l_g_l_i_b_min_c_g.html">ALGLIBMinCG</a>&lt; Functional_, Filter_ &gt; &gt; FEAT::Solver::new_alglib_mincg </td>
          <td>(</td>
          <td class="paramtype">Functional_ &amp;&#160;</td>
          <td class="paramname"><em>functional_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a651714c882641671d73d78382d7d77ee">NLCGDirectionUpdate</a>&#160;</td>
          <td class="paramname"><em>du_</em> = <code><a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_l_g_l_i_b_min_c_g.html">ALGLIBMinCG</a>&lt;Functional_,&#160;Filter_&gt;::direction_update_default</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keep_iterates_</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_l_g_l_i_b_min_c_g.html" title="Wrapper around ALGLIB&#39;s mincg implementation for minimising an functional&#39;s gradient.">ALGLIBMinCG</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">functional_</td><td>The functional</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep_iterates_</td><td>Flag for keeping the iterates, defaults to false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_l_g_l_i_b_min_c_g.html" title="Wrapper around ALGLIB&#39;s mincg implementation for minimising an functional&#39;s gradient.">ALGLIBMinCG</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000005">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="alglib__wrapper_8hpp_source.html#l01065">1065</a> of file <a class="el" href="alglib__wrapper_8hpp_source.html">alglib_wrapper.hpp</a>.</p>

</div>
</div>
<a id="a656a192b898ddc23ffb9072b9955b2ab" name="a656a192b898ddc23ffb9072b9955b2ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656a192b898ddc23ffb9072b9955b2ab">&#9670;&#160;</a></span>new_alglib_minlbfgs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functional_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_l_g_l_i_b_min_l_b_f_g_s.html">ALGLIBMinLBFGS</a>&lt; Functional_, Filter_ &gt; &gt; FEAT::Solver::new_alglib_minlbfgs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functional_ &amp;&#160;</td>
          <td class="paramname"><em>functional_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_l_g_l_i_b_min_l_b_f_g_s.html" title="Wrapper around ALGLIB&#39;s lBFGS implementation for minimising an functional&#39;s gradient.">ALGLIBMinLBFGS</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">functional_</td><td>The functional</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_</td><td>The system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_l_g_l_i_b_min_l_b_f_g_s.html" title="Wrapper around ALGLIB&#39;s lBFGS implementation for minimising an functional&#39;s gradient.">ALGLIBMinLBFGS</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000004">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="alglib__wrapper_8hpp_source.html#l00565">565</a> of file <a class="el" href="alglib__wrapper_8hpp_source.html">alglib_wrapper.hpp</a>.</p>

</div>
</div>
<a id="adab9653730c87172104d5178417d8fa1" name="adab9653730c87172104d5178417d8fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab9653730c87172104d5178417d8fa1">&#9670;&#160;</a></span>new_alglib_minlbfgs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functional_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_l_g_l_i_b_min_l_b_f_g_s.html">ALGLIBMinLBFGS</a>&lt; Functional_, Filter_ &gt; &gt; FEAT::Solver::new_alglib_minlbfgs </td>
          <td>(</td>
          <td class="paramtype">Functional_ &amp;&#160;</td>
          <td class="paramname"><em>functional_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">alglib::ae_int_t&#160;</td>
          <td class="paramname"><em>lbfgs_dim_</em> = <code>alglib::ae_int_t(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keep_iterates</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_l_g_l_i_b_min_l_b_f_g_s.html" title="Wrapper around ALGLIB&#39;s lBFGS implementation for minimising an functional&#39;s gradient.">ALGLIBMinLBFGS</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">functional_</td><td>The functional</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lbfgs_dim_</td><td>How many vectors to keep for the lBFGS hessian update. Defaults to min(7, functional_.columns()).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep_iterates</td><td>Keep all iterates in a std::deque. Defaults to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_a_l_g_l_i_b_min_l_b_f_g_s.html" title="Wrapper around ALGLIB&#39;s lBFGS implementation for minimising an functional&#39;s gradient.">ALGLIBMinLBFGS</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000003">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="alglib__wrapper_8hpp_source.html#l00538">538</a> of file <a class="el" href="alglib__wrapper_8hpp_source.html">alglib_wrapper.hpp</a>.</p>

</div>
</div>
<a id="a642dd4bca070c87b0531f9f57ed11069" name="a642dd4bca070c87b0531f9f57ed11069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642dd4bca070c87b0531f9f57ed11069">&#9670;&#160;</a></span>new_amavanka()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_ama_vanka.html">AmaVanka</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_amavanka </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Matrix_::DataType&#160;</td>
          <td class="paramname"><em>omega</em> = <code>typename&#160;Matrix_::DataType(1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1">Index</a>&#160;</td>
          <td class="paramname"><em>num_steps</em> = <code><a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1">Index</a>(1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_ama_vanka.html" title="Additive Macro-wise Matrix-based Vanka preconditioner/smoother.">AmaVanka</a> smoother object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">omega</td><td>The damping parameter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_steps</td><td>The number of <a class="el" href="class_f_e_a_t_1_1_solver_1_1_vanka.html" title="Vanka preconditioner/smoother class template.">Vanka</a> iterations to be performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_ama_vanka.html" title="Additive Macro-wise Matrix-based Vanka preconditioner/smoother.">AmaVanka</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="amavanka_8hpp_source.html#l01613">1613</a> of file <a class="el" href="amavanka_8hpp_source.html">amavanka.hpp</a>.</p>

</div>
</div>
<a id="af040d5ae2582eca39ae5831872f44e1b" name="af040d5ae2582eca39ae5831872f44e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af040d5ae2582eca39ae5831872f44e1b">&#9670;&#160;</a></span>new_approximate_hessian_precond()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Operator_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_approximate_hessian_precond.html">ApproximateHessianPrecond</a>&lt; Operator_, Filter_ &gt; &gt; FEAT::Solver::new_approximate_hessian_precond </td>
          <td>(</td>
          <td class="paramtype">Operator_ &amp;&#160;</td>
          <td class="paramname"><em>op_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_approximate_hessian_precond.html" title="Wrapper class for applying an the inverse of an operator&#39;s approximate Hessian as a preconditioner.">ApproximateHessianPrecond</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Operator_</td><td>The operator's type.</td></tr>
    <tr><td class="paramname">Filter_</td><td>The type of the filte for the preconditioner.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op_</td><td>The (nonlinear) operator.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_</td><td>The system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_hessian_precond.html" title="Preconditioner that applies the inverse of an operator&#39;s Hessian.">HessianPrecond</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hessian__precond_8hpp_source.html#l00329">329</a> of file <a class="el" href="hessian__precond_8hpp_source.html">hessian_precond.hpp</a>.</p>

</div>
</div>
<a id="af9f083d0e11b367f7f641ca58444b0c1" name="af9f083d0e11b367f7f641ca58444b0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f083d0e11b367f7f641ca58444b0c1">&#9670;&#160;</a></span>new_bicgstab() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab.html">BiCGStab</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_bicgstab </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a84303e5a9eeeb8bd47fb8e76c3d3694e">BiCGStabPreconVariant</a>&#160;</td>
          <td class="paramname"><em>precon_variant</em> = <code>BiCGStabPreconVariant::left</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab.html" title="(Preconditioned) Bi-Conjugate Gradient Stabilized solver implementation">BiCGStab</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precon_variant</td><td>Which preconditioning variant to use, defaults to left</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab.html" title="(Preconditioned) Bi-Conjugate Gradient Stabilized solver implementation">BiCGStab</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000007">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="bicgstab_8hpp_source.html#l00602">602</a> of file <a class="el" href="bicgstab_8hpp_source.html">bicgstab.hpp</a>.</p>

</div>
</div>
<a id="ad833f82ef1acd6563102f35b88d97cca" name="ad833f82ef1acd6563102f35b88d97cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad833f82ef1acd6563102f35b88d97cca">&#9670;&#160;</a></span>new_bicgstab() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab.html">BiCGStab</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_bicgstab </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab.html" title="(Preconditioned) Bi-Conjugate Gradient Stabilized solver implementation">BiCGStab</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab.html" title="(Preconditioned) Bi-Conjugate Gradient Stabilized solver implementation">BiCGStab</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000008">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="bicgstab_8hpp_source.html#l00652">652</a> of file <a class="el" href="bicgstab_8hpp_source.html">bicgstab.hpp</a>.</p>

</div>
</div>
<a id="a88b6a7252514b9db0b37b26ad86e69c5" name="a88b6a7252514b9db0b37b26ad86e69c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b6a7252514b9db0b37b26ad86e69c5">&#9670;&#160;</a></span>new_bicgstabl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab_l.html">BiCGStabL</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_bicgstabl </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab3701336d3327b2a233a089c5ae17ef7">BiCGStabLPreconVariant</a>&#160;</td>
          <td class="paramname"><em>precon_variant</em> = <code>BiCGStabLPreconVariant::left</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab_l.html" title="(Preconditioned) BiCGStab(l) solver implementation">BiCGStabL</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>A parameter for the solver configuration</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precon_variant</td><td>Which preconditioning variant to use, defaults to left</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab_l.html" title="(Preconditioned) BiCGStab(l) solver implementation">BiCGStabL</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000009">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="bicgstabl_8hpp_source.html#l00558">558</a> of file <a class="el" href="bicgstabl_8hpp_source.html">bicgstabl.hpp</a>.</p>

</div>
</div>
<a id="a564c8ccff6d85a840fd5b031a653cf34" name="a564c8ccff6d85a840fd5b031a653cf34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564c8ccff6d85a840fd5b031a653cf34">&#9670;&#160;</a></span>new_bicgstabl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab_l.html">BiCGStabL</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_bicgstabl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab_l.html" title="(Preconditioned) BiCGStab(l) solver implementation">BiCGStabL</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_bi_c_g_stab_l.html" title="(Preconditioned) BiCGStab(l) solver implementation">BiCGStabL</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000010">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="bicgstabl_8hpp_source.html#l00610">610</a> of file <a class="el" href="bicgstabl_8hpp_source.html">bicgstabl.hpp</a>.</p>

</div>
</div>
<a id="a386da687e0d991327e251fa41064dd33" name="a386da687e0d991327e251fa41064dd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386da687e0d991327e251fa41064dd33">&#9670;&#160;</a></span>new_boomeramg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_boomer_a_m_g.html">BoomerAMG</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_boomeramg </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_boomer_a_m_g.html" title="HYPRE BoomerAMGWrapper class template.">BoomerAMG</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The global system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The global system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_boomer_a_m_g.html" title="HYPRE BoomerAMGWrapper class template.">BoomerAMG</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hypre_8hpp_source.html#l00621">621</a> of file <a class="el" href="hypre_8hpp_source.html">hypre.hpp</a>.</p>

</div>
</div>
<a id="aecfffc0ea6d657ce58cc09e6e989f402" name="aecfffc0ea6d657ce58cc09e6e989f402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecfffc0ea6d657ce58cc09e6e989f402">&#9670;&#160;</a></span>new_boomeramg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_boomer_a_m_g.html">BoomerAMG</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_boomeramg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_boomer_a_m_g.html" title="HYPRE BoomerAMGWrapper class template.">BoomerAMG</a> solver object based on a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_boomer_a_m_g.html" title="HYPRE BoomerAMGWrapper class template.">BoomerAMG</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hypre_8hpp_source.html#l00646">646</a> of file <a class="el" href="hypre_8hpp_source.html">hypre.hpp</a>.</p>

</div>
</div>
<a id="a9c0bace005bd07bdb36846a5237b665e" name="a9c0bace005bd07bdb36846a5237b665e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0bace005bd07bdb36846a5237b665e">&#9670;&#160;</a></span>new_chebyshev() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_chebyshev.html">Chebyshev</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_chebyshev </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Matrix_::DataType&#160;</td>
          <td class="paramname"><em>fraction_min_ev</em> = <code>typename&#160;Matrix_::DataType(0.03)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Matrix_::DataType&#160;</td>
          <td class="paramname"><em>fraction_max_ev</em> = <code>typename&#160;Matrix_::DataType(1.1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_chebyshev.html" title="Chebyshev Polynomial implementation.">Chebyshev</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_chebyshev.html" title="Chebyshev Polynomial implementation.">Chebyshev</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="chebyshev_8hpp_source.html#l00301">301</a> of file <a class="el" href="chebyshev_8hpp_source.html">chebyshev.hpp</a>.</p>

</div>
</div>
<a id="ac7434b5f21c02503d0309f97f54c9112" name="ac7434b5f21c02503d0309f97f54c9112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7434b5f21c02503d0309f97f54c9112">&#9670;&#160;</a></span>new_chebyshev() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_chebyshev.html">Chebyshev</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_chebyshev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_chebyshev.html" title="Chebyshev Polynomial implementation.">Chebyshev</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_chebyshev.html" title="Chebyshev Polynomial implementation.">Chebyshev</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="chebyshev_8hpp_source.html#l00328">328</a> of file <a class="el" href="chebyshev_8hpp_source.html">chebyshev.hpp</a>.</p>

</div>
</div>
<a id="aac0226c89d9b7912c73ec8ed13450c18" name="aac0226c89d9b7912c73ec8ed13450c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0226c89d9b7912c73ec8ed13450c18">&#9670;&#160;</a></span>new_convert_precond() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LocalVectorOuter_ , typename LocalVectorInner_ , typename MirrorOuter_ , typename MirrorInner_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_convert_precond.html">ConvertPrecond</a>&lt; <a class="el" href="class_f_e_a_t_1_1_global_1_1_vector.html">Global::Vector</a>&lt; LocalVectorOuter_, MirrorOuter_ &gt;, <a class="el" href="class_f_e_a_t_1_1_global_1_1_vector.html">Global::Vector</a>&lt; LocalVectorInner_, MirrorInner_ &gt; &gt; &gt; FEAT::Solver::new_convert_precond </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; <a class="el" href="class_f_e_a_t_1_1_global_1_1_vector.html">Global::Vector</a>&lt; LocalVectorInner_, MirrorInner_ &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>inner_solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_convert_precond.html" title="Solver conversion module.">ConvertPrecond</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inner_solver</td><td>The actual solver, which shall be executed with converted rhs/sol vectors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_convert_precond.html" title="Solver conversion module.">ConvertPrecond</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="convert__precond_8hpp_source.html#l00237">237</a> of file <a class="el" href="convert__precond_8hpp_source.html">convert_precond.hpp</a>.</p>

</div>
</div>
<a id="a52e33f7df9dd68f704b6186ca69e39b5" name="a52e33f7df9dd68f704b6186ca69e39b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e33f7df9dd68f704b6186ca69e39b5">&#9670;&#160;</a></span>new_convert_precond() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorOuter_ , typename VectorInner_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_convert_precond.html">ConvertPrecond</a>&lt; VectorOuter_, VectorInner_ &gt; &gt; FEAT::Solver::new_convert_precond </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; VectorInner_ &gt; &gt;&#160;</td>
          <td class="paramname"><em>inner_solver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_convert_precond.html" title="Solver conversion module.">ConvertPrecond</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inner_solver</td><td>The actual solver, which shall be executed with converted rhs/sol vectors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_convert_precond.html" title="Solver conversion module.">ConvertPrecond</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="convert__precond_8hpp_source.html#l00132">132</a> of file <a class="el" href="convert__precond_8hpp_source.html">convert_precond.hpp</a>.</p>

</div>
</div>
<a id="a59dbf0d9ce0d9135831f99f54ee6fd53" name="a59dbf0d9ce0d9135831f99f54ee6fd53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59dbf0d9ce0d9135831f99f54ee6fd53">&#9670;&#160;</a></span>new_diagonal_precond()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_diagonal_precond.html">DiagonalPrecond</a>&lt; Vector_, Filter_ &gt; &gt; FEAT::Solver::new_diagonal_precond </td>
          <td>(</td>
          <td class="paramtype">const Vector_ &amp;&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_diagonal_precond.html" title="Diagonal preconditioner implementation.">DiagonalPrecond</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">diag</td><td>The vector representing the diagonal matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_diagonal_precond.html" title="Diagonal preconditioner implementation.">DiagonalPrecond</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="diagonal__precond_8hpp_source.html#l00088">88</a> of file <a class="el" href="diagonal__precond_8hpp_source.html">diagonal_precond.hpp</a>.</p>

</div>
</div>
<a id="a1710fb7ef4e77aa3d2407b1b2c118d2e" name="a1710fb7ef4e77aa3d2407b1b2c118d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1710fb7ef4e77aa3d2407b1b2c118d2e">&#9670;&#160;</a></span>new_direct_stokes_solver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_direct_stokes_solver.html">DirectStokesSolver</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_direct_stokes_solver </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_direct_stokes_solver.html" title="Direct Stokes solver class template.">DirectStokesSolver</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>A <a class="el" href="resident_vs_transient.html#res_vs_tran_resident">resident</a> reference to the system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>A <a class="el" href="resident_vs_transient.html#res_vs_tran_resident">resident</a> reference to the system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_direct_stokes_solver.html" title="Direct Stokes solver class template.">DirectStokesSolver</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="direct__stokes__solver_8hpp_source.html#l01253">1253</a> of file <a class="el" href="direct__stokes__solver_8hpp_source.html">direct_stokes_solver.hpp</a>.</p>

</div>
</div>
<a id="a0ed20d38330cb0b55f3a02ac3163002f" name="a0ed20d38330cb0b55f3a02ac3163002f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed20d38330cb0b55f3a02ac3163002f">&#9670;&#160;</a></span>new_euclid_precond() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_euclid_precond.html">EuclidPrecond</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_euclid_precond </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_euclid_precond.html" title="HYPRE Euclid Preconditioner Wrapper class template.">EuclidPrecond</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The global system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The global system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_euclid_precond.html" title="HYPRE Euclid Preconditioner Wrapper class template.">EuclidPrecond</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hypre_8hpp_source.html#l00487">487</a> of file <a class="el" href="hypre_8hpp_source.html">hypre.hpp</a>.</p>

</div>
</div>
<a id="aa2e0c5a93d63bfa65939ba63207d6f96" name="aa2e0c5a93d63bfa65939ba63207d6f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e0c5a93d63bfa65939ba63207d6f96">&#9670;&#160;</a></span>new_euclid_precond() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_euclid_precond.html">EuclidPrecond</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_euclid_precond </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_euclid_precond.html" title="HYPRE Euclid Preconditioner Wrapper class template.">EuclidPrecond</a> solver object based on a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_euclid_precond.html" title="HYPRE Euclid Preconditioner Wrapper class template.">EuclidPrecond</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hypre_8hpp_source.html#l00512">512</a> of file <a class="el" href="hypre_8hpp_source.html">hypre.hpp</a>.</p>

</div>
</div>
<a id="a843ed4e3dfe8f61203e8e99704f51e89" name="a843ed4e3dfe8f61203e8e99704f51e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843ed4e3dfe8f61203e8e99704f51e89">&#9670;&#160;</a></span>new_fgmres() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_f_g_m_r_e_s.html">FGMRES</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_fgmres </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1">Index</a>&#160;</td>
          <td class="paramname"><em>krylov_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Matrix_::DataType&#160;</td>
          <td class="paramname"><em>inner_res_scale</em> = <code>typename&#160;Matrix_::DataType(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_f_g_m_r_e_s.html" title="FGMRES(k) solver implementation.">FGMRES</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">krylov_dim</td><td>The maximum Krylov subspace dimension. Must be &gt; 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inner_res_scale</td><td>The scaling factor for the inner GMRES loop residual. Set this to zero unless you know what you are doing.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_f_g_m_r_e_s.html" title="FGMRES(k) solver implementation.">FGMRES</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000011">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="fgmres_8hpp_source.html#l00427">427</a> of file <a class="el" href="fgmres_8hpp_source.html">fgmres.hpp</a>.</p>

</div>
</div>
<a id="ade6299391b80470e4556a349ae3459c0" name="ade6299391b80470e4556a349ae3459c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6299391b80470e4556a349ae3459c0">&#9670;&#160;</a></span>new_fgmres() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_f_g_m_r_e_s.html">FGMRES</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_fgmres </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_f_g_m_r_e_s.html" title="FGMRES(k) solver implementation.">FGMRES</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_f_g_m_r_e_s.html" title="FGMRES(k) solver implementation.">FGMRES</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000012">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="fgmres_8hpp_source.html#l00476">476</a> of file <a class="el" href="fgmres_8hpp_source.html">fgmres.hpp</a>.</p>

</div>
</div>
<a id="a2ac02e6292a2187cc2ff867856e3d2e2" name="a2ac02e6292a2187cc2ff867856e3d2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac02e6292a2187cc2ff867856e3d2e2">&#9670;&#160;</a></span>new_fixed_step_linesearch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functional_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_fixed_step_linesearch.html">FixedStepLinesearch</a>&lt; Functional_, Filter_ &gt; &gt; FEAT::Solver::new_fixed_step_linesearch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functional_ &amp;&#160;</td>
          <td class="paramname"><em>functional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_fixed_step_linesearch.html" title="Fixed step line search.">FixedStepLinesearch</a> object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">functional</td><td>The functional.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_fixed_step_linesearch.html" title="Fixed step line search.">FixedStepLinesearch</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fixed__step__linesearch_8hpp_source.html#l00223">223</a> of file <a class="el" href="fixed__step__linesearch_8hpp_source.html">fixed_step_linesearch.hpp</a>.</p>

</div>
</div>
<a id="a788f4cc3fe220df0a7093f1f02fb58e7" name="a788f4cc3fe220df0a7093f1f02fb58e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788f4cc3fe220df0a7093f1f02fb58e7">&#9670;&#160;</a></span>new_fixed_step_linesearch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functional_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_fixed_step_linesearch.html">FixedStepLinesearch</a>&lt; Functional_, Filter_ &gt; &gt; FEAT::Solver::new_fixed_step_linesearch </td>
          <td>(</td>
          <td class="paramtype">Functional_ &amp;&#160;</td>
          <td class="paramname"><em>functional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Functional_::DataType&#160;</td>
          <td class="paramname"><em>step_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keep_iterates</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_fixed_step_linesearch.html" title="Fixed step line search.">FixedStepLinesearch</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">functional</td><td>The functional.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step_length</td><td>The step length the "line search" is to take.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep_iterates</td><td>Flag for keeping the iterates, defaults to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_fixed_step_linesearch.html" title="Fixed step line search.">FixedStepLinesearch</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fixed__step__linesearch_8hpp_source.html#l00197">197</a> of file <a class="el" href="fixed__step__linesearch_8hpp_source.html">fixed_step_linesearch.hpp</a>.</p>

</div>
</div>
<a id="aac261a767b52c9326b2ed02d10fe4aec" name="aac261a767b52c9326b2ed02d10fe4aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac261a767b52c9326b2ed02d10fe4aec">&#9670;&#160;</a></span>new_generic_umfpack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_generic_umfpack.html">GenericUmfpack</a>&lt; Matrix_ &gt; &gt; FEAT::Solver::new_generic_umfpack </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_generic_umfpack.html" title="Generic UMFPACK solver class.">GenericUmfpack</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_generic_umfpack.html" title="Generic UMFPACK solver class.">GenericUmfpack</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="umfpack_8hpp_source.html#l00844">844</a> of file <a class="el" href="umfpack_8hpp_source.html">umfpack.hpp</a>.</p>

</div>
</div>
<a id="ae0af5b9e827d08f7d923528cc679609c" name="ae0af5b9e827d08f7d923528cc679609c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0af5b9e827d08f7d923528cc679609c">&#9670;&#160;</a></span>new_gropppcg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_gropp_p_c_g.html">GroppPCG</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_gropppcg </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_gropp_p_c_g.html" title="(Preconditioned) pipelined Conjugate-Gradient solver implementation from Bill Gropp">GroppPCG</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_gropp_p_c_g.html" title="(Preconditioned) pipelined Conjugate-Gradient solver implementation from Bill Gropp">GroppPCG</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000013">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="gropppcg_8hpp_source.html#l00299">299</a> of file <a class="el" href="gropppcg_8hpp_source.html">gropppcg.hpp</a>.</p>

</div>
</div>
<a id="a804d6b5613261d71731864141c1d2ab5" name="a804d6b5613261d71731864141c1d2ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a804d6b5613261d71731864141c1d2ab5">&#9670;&#160;</a></span>new_gropppcg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_gropp_p_c_g.html">GroppPCG</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_gropppcg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_gropp_p_c_g.html" title="(Preconditioned) pipelined Conjugate-Gradient solver implementation from Bill Gropp">GroppPCG</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_gropp_p_c_g.html" title="(Preconditioned) pipelined Conjugate-Gradient solver implementation from Bill Gropp">GroppPCG</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000014">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="gropppcg_8hpp_source.html#l00347">347</a> of file <a class="el" href="gropppcg_8hpp_source.html">gropppcg.hpp</a>.</p>

</div>
</div>
<a id="a565c81560e5e44586e29878f6e31ba6a" name="a565c81560e5e44586e29878f6e31ba6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a565c81560e5e44586e29878f6e31ba6a">&#9670;&#160;</a></span>new_hessian_precond()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Operator_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_hessian_precond.html">HessianPrecond</a>&lt; Operator_, Filter_ &gt; &gt; FEAT::Solver::new_hessian_precond </td>
          <td>(</td>
          <td class="paramtype">Operator_ &amp;&#160;</td>
          <td class="paramname"><em>op_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_hessian_precond.html" title="Preconditioner that applies the inverse of an operator&#39;s Hessian.">HessianPrecond</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Operator_</td><td>The operator's type.</td></tr>
    <tr><td class="paramname">Filter_</td><td>The type of the filte for the preconditioner.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op_</td><td>The (nonlinear) operator.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_</td><td>The system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_hessian_precond.html" title="Preconditioner that applies the inverse of an operator&#39;s Hessian.">HessianPrecond</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hessian__precond_8hpp_source.html#l00159">159</a> of file <a class="el" href="hessian__precond_8hpp_source.html">hessian_precond.hpp</a>.</p>

</div>
</div>
<a id="ae2e182a2b77cb054dea748799147f44b" name="ae2e182a2b77cb054dea748799147f44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e182a2b77cb054dea748799147f44b">&#9670;&#160;</a></span>new_idrs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_i_d_r_s.html">IDRS</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_idrs </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1">Index</a>&#160;</td>
          <td class="paramname"><em>krylov_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new IDR(s) solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">krylov_dim</td><td>The maximum Krylov subspace dimension. Must be &gt; 0.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_i_d_r_s.html" title="IDR(s) solver implementation.">IDRS</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000015">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="idrs_8hpp_source.html#l00470">470</a> of file <a class="el" href="idrs_8hpp_source.html">idrs.hpp</a>.</p>

</div>
</div>
<a id="a29ed901c6634352c3f97e7d9336f274b" name="a29ed901c6634352c3f97e7d9336f274b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ed901c6634352c3f97e7d9336f274b">&#9670;&#160;</a></span>new_idrs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_i_d_r_s.html">IDRS</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_idrs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new IDR(s) solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_i_d_r_s.html" title="IDR(s) solver implementation.">IDRS</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000016">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="idrs_8hpp_source.html#l00518">518</a> of file <a class="el" href="idrs_8hpp_source.html">idrs.hpp</a>.</p>

</div>
</div>
<a id="a7aecfff253544d2e53895de0cfb4f1b6" name="a7aecfff253544d2e53895de0cfb4f1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aecfff253544d2e53895de0cfb4f1b6">&#9670;&#160;</a></span>new_ilu_precond() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_i_l_u_precond.html">ILUPrecond</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_ilu_precond </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_e_a_t.html#a050b7378896da037a96211e8db059029">PreferredBackend</a>&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_i_l_u_precond.html" title="ILU(0) and ILU(p) preconditioner implementation.">ILUPrecond</a> solver object based on a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">backend</td><td>The backend to be preferred. This implementation works with generic and cuda.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_i_l_u_precond.html" title="ILU(0) and ILU(p) preconditioner implementation.">ILUPrecond</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ilu__precond_8hpp_source.html#l01847">1847</a> of file <a class="el" href="ilu__precond_8hpp_source.html">ilu_precond.hpp</a>.</p>

</div>
</div>
<a id="ae6855772185a20ab674478b0ad4fedd4" name="ae6855772185a20ab674478b0ad4fedd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6855772185a20ab674478b0ad4fedd4">&#9670;&#160;</a></span>new_ilu_precond() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_i_l_u_precond.html">ILUPrecond</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_ilu_precond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_f_e_a_t.html#a050b7378896da037a96211e8db059029">PreferredBackend</a>&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>p</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_i_l_u_precond.html" title="ILU(0) and ILU(p) preconditioner implementation.">ILUPrecond</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">backend</td><td>The backend to be preferred. This implementation works with generic and cuda.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Maximum level of fill-in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_i_l_u_precond.html" title="ILU(0) and ILU(p) preconditioner implementation.">ILUPrecond</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ilu__precond_8hpp_source.html#l01819">1819</a> of file <a class="el" href="ilu__precond_8hpp_source.html">ilu_precond.hpp</a>.</p>

</div>
</div>
<a id="adac68b706343d7aba2bc3769070dd926" name="adac68b706343d7aba2bc3769070dd926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac68b706343d7aba2bc3769070dd926">&#9670;&#160;</a></span>new_jacobi_precond() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_jacobi_precond.html">JacobiPrecond</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_jacobi_precond </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Matrix_::DataType&#160;</td>
          <td class="paramname"><em>omega</em> = <code>typename&#160;Matrix_::DataType(1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_jacobi_precond.html" title="Jacobi preconditioner implementation.">JacobiPrecond</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">omega</td><td>The damping parameter for Jacobi.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_jacobi_precond.html" title="Jacobi preconditioner implementation.">JacobiPrecond</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="jacobi__precond_8hpp_source.html#l00183">183</a> of file <a class="el" href="jacobi__precond_8hpp_source.html">jacobi_precond.hpp</a>.</p>

</div>
</div>
<a id="a7547597be99467fcfd8f934d4b32d4e9" name="a7547597be99467fcfd8f934d4b32d4e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7547597be99467fcfd8f934d4b32d4e9">&#9670;&#160;</a></span>new_jacobi_precond() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_jacobi_precond.html">JacobiPrecond</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_jacobi_precond </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_jacobi_precond.html" title="Jacobi preconditioner implementation.">JacobiPrecond</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_jacobi_precond.html" title="Jacobi preconditioner implementation.">JacobiPrecond</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="jacobi__precond_8hpp_source.html#l00206">206</a> of file <a class="el" href="jacobi__precond_8hpp_source.html">jacobi_precond.hpp</a>.</p>

</div>
</div>
<a id="a9911e7960f1440707040ce3e6edb4e53" name="a9911e7960f1440707040ce3e6edb4e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9911e7960f1440707040ce3e6edb4e53">&#9670;&#160;</a></span>new_matrix_precond()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_matrix_precond.html">MatrixPrecond</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_matrix_precond </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_matrix_precond.html" title="Matrix preconditioner implementation.">MatrixPrecond</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_jacobi_precond.html" title="Jacobi preconditioner implementation.">JacobiPrecond</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrix__precond_8hpp_source.html#l00093">93</a> of file <a class="el" href="matrix__precond_8hpp_source.html">matrix_precond.hpp</a>.</p>

</div>
</div>
<a id="a3f21dbcd6bf8a8e7b5541fd6d3bed119" name="a3f21dbcd6bf8a8e7b5541fd6d3bed119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f21dbcd6bf8a8e7b5541fd6d3bed119">&#9670;&#160;</a></span>new_mqc_linesearch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functional_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_m_q_c_linesearch.html">MQCLinesearch</a>&lt; Functional_, Filter_ &gt; &gt; FEAT::Solver::new_mqc_linesearch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functional_ &amp;&#160;</td>
          <td class="paramname"><em>functional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_m_q_c_linesearch.html" title="Mixed quadratic-cubic line search.">MQCLinesearch</a> object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">functional</td><td>The functional.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_m_q_c_linesearch.html" title="Mixed quadratic-cubic line search.">MQCLinesearch</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mqc__linesearch_8hpp_source.html#l00840">840</a> of file <a class="el" href="mqc__linesearch_8hpp_source.html">mqc_linesearch.hpp</a>.</p>

</div>
</div>
<a id="ac11a88375825f798d11e58403c40379f" name="ac11a88375825f798d11e58403c40379f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11a88375825f798d11e58403c40379f">&#9670;&#160;</a></span>new_mqc_linesearch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functional_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_m_q_c_linesearch.html">MQCLinesearch</a>&lt; Functional_, Filter_ &gt; &gt; FEAT::Solver::new_mqc_linesearch </td>
          <td>(</td>
          <td class="paramtype">Functional_ &amp;&#160;</td>
          <td class="paramname"><em>functional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keep_iterates</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_m_q_c_linesearch.html" title="Mixed quadratic-cubic line search.">MQCLinesearch</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">functional</td><td>The functional.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep_iterates</td><td>Flag for keeping the iterates, defaults to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_m_q_c_linesearch.html" title="Mixed quadratic-cubic line search.">MQCLinesearch</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mqc__linesearch_8hpp_source.html#l00815">815</a> of file <a class="el" href="mqc__linesearch_8hpp_source.html">mqc_linesearch.hpp</a>.</p>

</div>
</div>
<a id="a4940f8c4ee8be921a6d6dca8b918887a" name="a4940f8c4ee8be921a6d6dca8b918887a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4940f8c4ee8be921a6d6dca8b918887a">&#9670;&#160;</a></span>new_multigrid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SystemMatrix_ , typename SystemFilter_ , typename TransferOperator_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_multi_grid.html">MultiGrid</a>&lt; SystemMatrix_, SystemFilter_, TransferOperator_ &gt; &gt; FEAT::Solver::new_multigrid </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_multi_grid_hierarchy.html">MultiGridHierarchy</a>&lt; SystemMatrix_, SystemFilter_, TransferOperator_ &gt; &gt;&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a5b14b494b949c5eecc622f4ad6e2d59b">MultiGridCycle</a>&#160;</td>
          <td class="paramname"><em>cycle</em> = <code><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a5b14b494b949c5eecc622f4ad6e2d59ba5206560a306a2e085a437fd258eb57ce">MultiGridCycle::V</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>top_level</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>crs_level</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new Multigrid preconditioner object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hierarchy</td><td>A pointer to the multigrid hierarchy object.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cycle</td><td>The desired multigrid cycle.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top_level</td><td>The desired top-level for this multigrid solver.<br  />
Set to 0 to use the finest level in the multigrid hierarchy.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">crs_level</td><td>The desired coarse-level for this multigrid solver.<br  />
Set to -1 to use the coarsest level in the multigrid hierarchy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_multi_grid.html" title="Multigrid preconditioner implementation.">MultiGrid</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="multigrid_8hpp_source.html#l02029">2029</a> of file <a class="el" href="multigrid_8hpp_source.html">multigrid.hpp</a>.</p>

</div>
</div>
<a id="ae388aa993a6ef664944ce3d90125057e" name="ae388aa993a6ef664944ce3d90125057e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae388aa993a6ef664944ce3d90125057e">&#9670;&#160;</a></span>new_newton_raphson_linesearch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functional_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_newton_raphson_linesearch.html">NewtonRaphsonLinesearch</a>&lt; Functional_, Filter_ &gt; &gt; FEAT::Solver::new_newton_raphson_linesearch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functional_ &amp;&#160;</td>
          <td class="paramname"><em>functional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_newton_raphson_linesearch.html" title="Newton Raphson linesearch.">NewtonRaphsonLinesearch</a> object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">functional</td><td>The functional</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_newton_raphson_linesearch.html" title="Newton Raphson linesearch.">NewtonRaphsonLinesearch</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="newton__raphson__linesearch_8hpp_source.html#l00282">282</a> of file <a class="el" href="newton__raphson__linesearch_8hpp_source.html">newton_raphson_linesearch.hpp</a>.</p>

</div>
</div>
<a id="a5986f726755329cf6107b63294902fb3" name="a5986f726755329cf6107b63294902fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5986f726755329cf6107b63294902fb3">&#9670;&#160;</a></span>new_newton_raphson_linesearch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functional_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_newton_raphson_linesearch.html">NewtonRaphsonLinesearch</a>&lt; Functional_, Filter_ &gt; &gt; FEAT::Solver::new_newton_raphson_linesearch </td>
          <td>(</td>
          <td class="paramtype">Functional_ &amp;&#160;</td>
          <td class="paramname"><em>functional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keep_iterates</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_newton_raphson_linesearch.html" title="Newton Raphson linesearch.">NewtonRaphsonLinesearch</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">functional</td><td>The functional.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep_iterates</td><td>Flag for keeping the iterates, defaults to false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_newton_raphson_linesearch.html" title="Newton Raphson linesearch.">NewtonRaphsonLinesearch</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="newton__raphson__linesearch_8hpp_source.html#l00257">257</a> of file <a class="el" href="newton__raphson__linesearch_8hpp_source.html">newton_raphson_linesearch.hpp</a>.</p>

</div>
</div>
<a id="aedfcfc78f5ca522827fe000c7425d387" name="aedfcfc78f5ca522827fe000c7425d387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedfcfc78f5ca522827fe000c7425d387">&#9670;&#160;</a></span>new_nlcg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functional_ , typename Filter_ , typename Linesearch_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_c_g.html">NLCG</a>&lt; Functional_, Filter_ &gt; &gt; FEAT::Solver::new_nlcg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functional_ &amp;&#160;</td>
          <td class="paramname"><em>functional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Linesearch_ &amp;&#160;</td>
          <td class="paramname"><em>linesearch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_opt_precond.html">NLOptPrecond</a>&lt; typename Functional_::VectorTypeL, Filter_ &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_c_g.html" title="Nonlinear Conjugate Gradient method for finding a minimum of an functional&#39;s gradient.">NLCG</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">functional</td><td>The functional.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">linesearch</td><td>The linesearch to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_c_g.html" title="Nonlinear Conjugate Gradient method for finding a minimum of an functional&#39;s gradient.">NLCG</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000018">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="nlcg_8hpp_source.html#l00988">988</a> of file <a class="el" href="nlcg_8hpp_source.html">nlcg.hpp</a>.</p>

</div>
</div>
<a id="ae98e2d07903f6688add105a6457f7e2c" name="ae98e2d07903f6688add105a6457f7e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae98e2d07903f6688add105a6457f7e2c">&#9670;&#160;</a></span>new_nlcg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functional_ , typename Filter_ , typename Linesearch_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_c_g.html">NLCG</a>&lt; Functional_, Filter_ &gt; &gt; FEAT::Solver::new_nlcg </td>
          <td>(</td>
          <td class="paramtype">Functional_ &amp;&#160;</td>
          <td class="paramname"><em>functional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Linesearch_ &amp;&#160;</td>
          <td class="paramname"><em>linesearch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a651714c882641671d73d78382d7d77ee">NLCGDirectionUpdate</a>&#160;</td>
          <td class="paramname"><em>direction_update</em> = <code><a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_c_g.html">NLCG</a>&lt;Functional_,&#160;Filter_&gt;::direction_update_default</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keep_iterates</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_opt_precond.html">NLOptPrecond</a>&lt; typename Functional_::VectorTypeL, Filter_ &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_c_g.html" title="Nonlinear Conjugate Gradient method for finding a minimum of an functional&#39;s gradient.">NLCG</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">functional</td><td>The functional.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">linesearch</td><td>The linesearch to use.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction_update</td><td>The direction update to use, defaults to Polak-Ribiere.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep_iterates</td><td>Flag for keeping the iterates, defaults to false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_c_g.html" title="Nonlinear Conjugate Gradient method for finding a minimum of an functional&#39;s gradient.">NLCG</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000017">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="nlcg_8hpp_source.html#l00933">933</a> of file <a class="el" href="nlcg_8hpp_source.html">nlcg.hpp</a>.</p>

</div>
</div>
<a id="ab8c92b6bd48450a3f505b1132ac6ed89" name="ab8c92b6bd48450a3f505b1132ac6ed89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c92b6bd48450a3f505b1132ac6ed89">&#9670;&#160;</a></span>new_nlsd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functional_ , typename Filter_ , typename Linesearch_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_s_d.html">NLSD</a>&lt; Functional_, Filter_ &gt; &gt; FEAT::Solver::new_nlsd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functional_ &amp;&#160;</td>
          <td class="paramname"><em>functional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Linesearch_ &amp;&#160;</td>
          <td class="paramname"><em>linesearch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_opt_precond.html">NLOptPrecond</a>&lt; typename Functional_::VectorTypeL, Filter_ &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_s_d.html" title="Nonlinear Steepest Descent method for finding a minimum of an functional&#39;s gradient.">NLSD</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">functional</td><td>The nonlinear functional.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">linesearch</td><td>The linesearch to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_s_d.html" title="Nonlinear Steepest Descent method for finding a minimum of an functional&#39;s gradient.">NLSD</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000020">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="nlsd_8hpp_source.html#l00470">470</a> of file <a class="el" href="nlsd_8hpp_source.html">nlsd.hpp</a>.</p>

</div>
</div>
<a id="a6701c5190efb1e0f1085853ef4bf3582" name="a6701c5190efb1e0f1085853ef4bf3582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6701c5190efb1e0f1085853ef4bf3582">&#9670;&#160;</a></span>new_nlsd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functional_ , typename Filter_ , typename Linesearch_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_s_d.html">NLSD</a>&lt; Functional_, Filter_ &gt; &gt; FEAT::Solver::new_nlsd </td>
          <td>(</td>
          <td class="paramtype">Functional_ &amp;&#160;</td>
          <td class="paramname"><em>functional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Linesearch_ &amp;&#160;</td>
          <td class="paramname"><em>linesearch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keep_iterates</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_opt_precond.html">NLOptPrecond</a>&lt; typename Functional_::VectorTypeL, Filter_ &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_s_d.html" title="Nonlinear Steepest Descent method for finding a minimum of an functional&#39;s gradient.">NLSD</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">functional</td><td>The nonlinear functional.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">linesearch</td><td>The linesearch to use.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep_iterates</td><td>Flag for keeping the iterates, defaults to false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_n_l_s_d.html" title="Nonlinear Steepest Descent method for finding a minimum of an functional&#39;s gradient.">NLSD</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000019">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="nlsd_8hpp_source.html#l00415">415</a> of file <a class="el" href="nlsd_8hpp_source.html">nlsd.hpp</a>.</p>

</div>
</div>
<a id="a25100c25aa3685c8392ae3cce25f9618" name="a25100c25aa3685c8392ae3cce25f9618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25100c25aa3685c8392ae3cce25f9618">&#9670;&#160;</a></span>new_nonlinear_operator_precond_wrapper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NonlinearOperator_ , typename... Args_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_nonlinear_operator_precond_wrapper.html">NonlinearOperatorPrecondWrapper</a>&lt; NonlinearOperator_ &gt; &gt; FEAT::Solver::new_nonlinear_operator_precond_wrapper </td>
          <td>(</td>
          <td class="paramtype">Args_ &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_nonlinear_operator_precond_wrapper.html" title="Wrapper class around a (potentially nonlinear) operator.">NonlinearOperatorPrecondWrapper</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NonlinearOperator_</td><td>The operator to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Arguments passed to the NonlinearOperator's constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared_ptr to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_nonlinear_operator_precond_wrapper.html" title="Wrapper class around a (potentially nonlinear) operator.">NonlinearOperatorPrecondWrapper</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="nlopt__precond_8hpp_source.html#l00201">201</a> of file <a class="el" href="nlopt__precond_8hpp_source.html">nlopt_precond.hpp</a>.</p>

</div>
</div>
<a id="a622b5d745d268a0942f75afd6905103f" name="a622b5d745d268a0942f75afd6905103f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622b5d745d268a0942f75afd6905103f">&#9670;&#160;</a></span>new_parasails_precond() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_para_sails_precond.html">ParaSailsPrecond</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_parasails_precond </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_para_sails_precond.html" title="HYPRE ParaSails Preconditioner Wrapper class template.">ParaSailsPrecond</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The global system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The global system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_para_sails_precond.html" title="HYPRE ParaSails Preconditioner Wrapper class template.">ParaSailsPrecond</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hypre_8hpp_source.html#l00347">347</a> of file <a class="el" href="hypre_8hpp_source.html">hypre.hpp</a>.</p>

</div>
</div>
<a id="a4b68934316380fc5fa14f27851fcfdf0" name="a4b68934316380fc5fa14f27851fcfdf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b68934316380fc5fa14f27851fcfdf0">&#9670;&#160;</a></span>new_parasails_precond() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_para_sails_precond.html">ParaSailsPrecond</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_parasails_precond </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_para_sails_precond.html" title="HYPRE ParaSails Preconditioner Wrapper class template.">ParaSailsPrecond</a> solver object based on a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_para_sails_precond.html" title="HYPRE ParaSails Preconditioner Wrapper class template.">ParaSailsPrecond</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hypre_8hpp_source.html#l00372">372</a> of file <a class="el" href="hypre_8hpp_source.html">hypre.hpp</a>.</p>

</div>
</div>
<a id="a85895fa0a94ac2681b1445f5456874d4" name="a85895fa0a94ac2681b1445f5456874d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85895fa0a94ac2681b1445f5456874d4">&#9670;&#160;</a></span>new_pcg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g.html">PCG</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_pcg </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g.html" title="(Preconditioned) Conjugate-Gradient solver implementation">PCG</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g.html" title="(Preconditioned) Conjugate-Gradient solver implementation">PCG</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000021">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="pcg_8hpp_source.html#l00323">323</a> of file <a class="el" href="pcg_8hpp_source.html">pcg.hpp</a>.</p>

</div>
</div>
<a id="ac1614b6614a365b380d25e5012047c50" name="ac1614b6614a365b380d25e5012047c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1614b6614a365b380d25e5012047c50">&#9670;&#160;</a></span>new_pcg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g.html">PCG</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_pcg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g.html" title="(Preconditioned) Conjugate-Gradient solver implementation">PCG</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g.html" title="(Preconditioned) Conjugate-Gradient solver implementation">PCG</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000022">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="pcg_8hpp_source.html#l00371">371</a> of file <a class="el" href="pcg_8hpp_source.html">pcg.hpp</a>.</p>

</div>
</div>
<a id="a911026db26857a46df6a675d2b53258b" name="a911026db26857a46df6a675d2b53258b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911026db26857a46df6a675d2b53258b">&#9670;&#160;</a></span>new_pcgnr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g_n_r.html">PCGNR</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_pcgnr </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond_l</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond_r</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g_n_r.html" title="(Preconditioned) Conjugate-Gradient on Normal Equations solver implementation">PCGNR</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond_l</td><td>The left preconditioner. May be <code>nullptr</code>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond_r</td><td>The right preconditioner. May be <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g_n_r.html" title="(Preconditioned) Conjugate-Gradient on Normal Equations solver implementation">PCGNR</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000023">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="pcgnr_8hpp_source.html#l00419">419</a> of file <a class="el" href="pcgnr_8hpp_source.html">pcgnr.hpp</a>.</p>

</div>
</div>
<a id="a0b48d7ab95134f757e5f7cdf79a30e1d" name="a0b48d7ab95134f757e5f7cdf79a30e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b48d7ab95134f757e5f7cdf79a30e1d">&#9670;&#160;</a></span>new_pcgnr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g_n_r.html">PCGNR</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_pcgnr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond_l</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond_r</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g_n_r.html" title="(Preconditioned) Conjugate-Gradient on Normal Equations solver implementation">PCGNR</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond_l</td><td>The left preconditioner. May be <code>nullptr</code>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond_r</td><td>The right preconditioner. May be <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g_n_r.html" title="(Preconditioned) Conjugate-Gradient on Normal Equations solver implementation">PCGNR</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000024">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="pcgnr_8hpp_source.html#l00473">473</a> of file <a class="el" href="pcgnr_8hpp_source.html">pcgnr.hpp</a>.</p>

</div>
</div>
<a id="ab57cd73a467ceca33324492b02898e68" name="ab57cd73a467ceca33324492b02898e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57cd73a467ceca33324492b02898e68">&#9670;&#160;</a></span>new_pcgnrilu() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g_n_r_i_l_u.html">PCGNRILU</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_pcgnrilu </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ilu_p</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g_n_r_i_l_u.html" title="ILU(p)-preconditioned Conjugate-Gradient on Normal Equations solver implementation.">PCGNRILU</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ilu_p</td><td>Maximum allowed fill-in for ILU preconditioner. Set to -1 to disable preconditioning.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g_n_r_i_l_u.html" title="ILU(p)-preconditioned Conjugate-Gradient on Normal Equations solver implementation.">PCGNRILU</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="pcgnrilu_8hpp_source.html#l00374">374</a> of file <a class="el" href="pcgnrilu_8hpp_source.html">pcgnrilu.hpp</a>.</p>

</div>
</div>
<a id="a657dede58deaaa0d48a5dae5673c270b" name="a657dede58deaaa0d48a5dae5673c270b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657dede58deaaa0d48a5dae5673c270b">&#9670;&#160;</a></span>new_pcgnrilu() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g_n_r_i_l_u.html">PCGNRILU</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_pcgnrilu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g_n_r_i_l_u.html" title="ILU(p)-preconditioned Conjugate-Gradient on Normal Equations solver implementation.">PCGNRILU</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_g_n_r_i_l_u.html" title="ILU(p)-preconditioned Conjugate-Gradient on Normal Equations solver implementation.">PCGNRILU</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="pcgnrilu_8hpp_source.html#l00399">399</a> of file <a class="el" href="pcgnrilu_8hpp_source.html">pcgnrilu.hpp</a>.</p>

</div>
</div>
<a id="ae33ab411b2c94368a1dfebe969503387" name="ae33ab411b2c94368a1dfebe969503387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33ab411b2c94368a1dfebe969503387">&#9670;&#160;</a></span>new_pcr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_r.html">PCR</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_pcr </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_r.html" title="(Preconditioned) Conjugate-Residual solver implementation">PCR</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_r.html" title="(Preconditioned) Conjugate-Residual solver implementation">PCR</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000025">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="pcr_8hpp_source.html#l00317">317</a> of file <a class="el" href="pcr_8hpp_source.html">pcr.hpp</a>.</p>

</div>
</div>
<a id="a2ea26b9a47c2c5b3503743ad71f083c8" name="a2ea26b9a47c2c5b3503743ad71f083c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea26b9a47c2c5b3503743ad71f083c8">&#9670;&#160;</a></span>new_pcr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_r.html">PCR</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_pcr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_r.html" title="(Preconditioned) Conjugate-Residual solver implementation">PCR</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_c_r.html" title="(Preconditioned) Conjugate-Residual solver implementation">PCR</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000026">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="pcr_8hpp_source.html#l00366">366</a> of file <a class="el" href="pcr_8hpp_source.html">pcr.hpp</a>.</p>

</div>
</div>
<a id="afd5a6866b18ce17013639fb9f4647c80" name="afd5a6866b18ce17013639fb9f4647c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5a6866b18ce17013639fb9f4647c80">&#9670;&#160;</a></span>new_pipepcg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_pipe_p_c_g.html">PipePCG</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_pipepcg </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_pipe_p_c_g.html" title="(Preconditioned) pipelined Conjugate-Gradient solver implementation from Ghysels and Vnaroose">PipePCG</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_pipe_p_c_g.html" title="(Preconditioned) pipelined Conjugate-Gradient solver implementation from Ghysels and Vnaroose">PipePCG</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000027">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="pipepcg_8hpp_source.html#l00335">335</a> of file <a class="el" href="pipepcg_8hpp_source.html">pipepcg.hpp</a>.</p>

</div>
</div>
<a id="a5efb59a44612597a86e127427644f4ab" name="a5efb59a44612597a86e127427644f4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5efb59a44612597a86e127427644f4ab">&#9670;&#160;</a></span>new_pipepcg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_pipe_p_c_g.html">PipePCG</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_pipepcg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_pipe_p_c_g.html" title="(Preconditioned) pipelined Conjugate-Gradient solver implementation from Ghysels and Vnaroose">PipePCG</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_pipe_p_c_g.html" title="(Preconditioned) pipelined Conjugate-Gradient solver implementation from Ghysels and Vnaroose">PipePCG</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000028">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="pipepcg_8hpp_source.html#l00383">383</a> of file <a class="el" href="pipepcg_8hpp_source.html">pipepcg.hpp</a>.</p>

</div>
</div>
<a id="a940b86c64e3f0422ea0c7c573bcda71a" name="a940b86c64e3f0422ea0c7c573bcda71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940b86c64e3f0422ea0c7c573bcda71a">&#9670;&#160;</a></span>new_pmr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_m_r.html">PMR</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_pmr </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_m_r.html" title="(Preconditioned) Minimal-Residual-Iteration solver implementation">PMR</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_m_r.html" title="(Preconditioned) Minimal-Residual-Iteration solver implementation">PMR</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000029">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="pmr_8hpp_source.html#l00286">286</a> of file <a class="el" href="pmr_8hpp_source.html">pmr.hpp</a>.</p>

</div>
</div>
<a id="ad8fdbca4c863c6705484e2d4d34ecf64" name="ad8fdbca4c863c6705484e2d4d34ecf64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8fdbca4c863c6705484e2d4d34ecf64">&#9670;&#160;</a></span>new_pmr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_m_r.html">PMR</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_pmr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_m_r.html" title="(Preconditioned) Minimal-Residual-Iteration solver implementation">PMR</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_m_r.html" title="(Preconditioned) Minimal-Residual-Iteration solver implementation">PMR</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000030">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="pmr_8hpp_source.html#l00335">335</a> of file <a class="el" href="pmr_8hpp_source.html">pmr.hpp</a>.</p>

</div>
</div>
<a id="aca8bd0716ea4730474e9b391d97819c0" name="aca8bd0716ea4730474e9b391d97819c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8bd0716ea4730474e9b391d97819c0">&#9670;&#160;</a></span>new_polynomial_precond() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_polynomial_precond.html">PolynomialPrecond</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_polynomial_precond </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1">Index</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Matrix_::DataType&#160;</td>
          <td class="paramname"><em>omega</em> = <code>typename&#160;Matrix_::DataType(1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new PoynomialPrecond solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The order of the polynom</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">omega</td><td>The damping parameter for the internal jacobi preconditioner.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_polynomial_precond.html" title="Polynomial preconditioner implementation.">PolynomialPrecond</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="polynomial__precond_8hpp_source.html#l00242">242</a> of file <a class="el" href="polynomial__precond_8hpp_source.html">polynomial_precond.hpp</a>.</p>

</div>
</div>
<a id="a8f0d224e33f8ddbde5a0b02ead13f68f" name="a8f0d224e33f8ddbde5a0b02ead13f68f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0d224e33f8ddbde5a0b02ead13f68f">&#9670;&#160;</a></span>new_polynomial_precond() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_polynomial_precond.html">PolynomialPrecond</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_polynomial_precond </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_polynomial_precond.html" title="Polynomial preconditioner implementation.">PolynomialPrecond</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_polynomial_precond.html" title="Polynomial preconditioner implementation.">PolynomialPrecond</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="polynomial__precond_8hpp_source.html#l00268">268</a> of file <a class="el" href="polynomial__precond_8hpp_source.html">polynomial_precond.hpp</a>.</p>

</div>
</div>
<a id="ac6a1659b386401b23df34866c47bb406" name="ac6a1659b386401b23df34866c47bb406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a1659b386401b23df34866c47bb406">&#9670;&#160;</a></span>new_psd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_s_d.html">PSD</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_psd </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_s_d.html" title="(Preconditioned) Steepest-Descent solver implementation">PSD</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_s_d.html" title="(Preconditioned) Steepest-Descent solver implementation">PSD</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000031">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="psd_8hpp_source.html#l00260">260</a> of file <a class="el" href="psd_8hpp_source.html">psd.hpp</a>.</p>

</div>
</div>
<a id="a8e5ed5890cd42fc9234f198327a99f3d" name="a8e5ed5890cd42fc9234f198327a99f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5ed5890cd42fc9234f198327a99f3d">&#9670;&#160;</a></span>new_psd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_s_d.html">PSD</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_psd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_s_d.html" title="(Preconditioned) Steepest-Descent solver implementation">PSD</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_p_s_d.html" title="(Preconditioned) Steepest-Descent solver implementation">PSD</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000032">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="psd_8hpp_source.html#l00309">309</a> of file <a class="el" href="psd_8hpp_source.html">psd.hpp</a>.</p>

</div>
</div>
<a id="a02d281041763d4c4de818a91d7fdf412" name="a02d281041763d4c4de818a91d7fdf412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d281041763d4c4de818a91d7fdf412">&#9670;&#160;</a></span>new_qpenalty() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functional_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_q_penalty.html">QPenalty</a>&lt; Functional_ &gt; &gt; FEAT::Solver::new_qpenalty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functional_ &amp;&#160;</td>
          <td class="paramname"><em>functional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_iterative_solver.html">IterativeSolver</a>&lt; typename Functional_::VectorTypeR &gt; &gt;&#160;</td>
          <td class="paramname"><em>inner_solver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_q_penalty.html" title="Quadratic penalty iteration.">QPenalty</a> object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Functional_</td><td>The type of the quadratic penalty function \( Q \).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">functional</td><td>The quadratic penalty function \( Q \).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inner_solver</td><td>The inner solver for solving the penalized unconstrained optimization problem.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An std::shared_ptr to the new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_q_penalty.html" title="Quadratic penalty iteration.">QPenalty</a> solver object </dd></dl>

<p class="definition">Definition at line <a class="el" href="qpenalty_8hpp_source.html#l00423">423</a> of file <a class="el" href="qpenalty_8hpp_source.html">qpenalty.hpp</a>.</p>

</div>
</div>
<a id="aac3f570b9eaa19a46246d64ce281ccde" name="aac3f570b9eaa19a46246d64ce281ccde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3f570b9eaa19a46246d64ce281ccde">&#9670;&#160;</a></span>new_qpenalty() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functional_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_q_penalty.html">QPenalty</a>&lt; Functional_ &gt; &gt; FEAT::Solver::new_qpenalty </td>
          <td>(</td>
          <td class="paramtype">Functional_ &amp;&#160;</td>
          <td class="paramname"><em>functional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_iterative_solver.html">IterativeSolver</a>&lt; typename Functional_::VectorTypeR &gt; &gt;&#160;</td>
          <td class="paramname"><em>inner_solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Functional_::VectorTypeR::DataType&#160;</td>
          <td class="paramname"><em>initial_penalty_param</em> = <code>typename&#160;Functional_::VectorTypeR::DataType(1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_q_penalty.html" title="Quadratic penalty iteration.">QPenalty</a> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Functional_</td><td>The type of the quadratic penalty function \( Q \).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">functional</td><td>The quadratic penalty function \( Q \).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inner_solver</td><td>The inner solver for solving the penalized unconstrained optimization problem.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An std::shared_ptr to the new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_q_penalty.html" title="Quadratic penalty iteration.">QPenalty</a> solver object </dd></dl>

<p class="definition">Definition at line <a class="el" href="qpenalty_8hpp_source.html#l00394">394</a> of file <a class="el" href="qpenalty_8hpp_source.html">qpenalty.hpp</a>.</p>

</div>
</div>
<a id="a80f4ae780a90a2bc1625273739d48334" name="a80f4ae780a90a2bc1625273739d48334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f4ae780a90a2bc1625273739d48334">&#9670;&#160;</a></span>new_rbicgstab() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_r_bi_c_g_stab.html">RBiCGStab</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_rbicgstab </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_r_bi_c_g_stab.html" title="(Preconditioned) reordered BiCGStab solver implementation">RBiCGStab</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_r_bi_c_g_stab.html" title="(Preconditioned) reordered BiCGStab solver implementation">RBiCGStab</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000033">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="rbicgstab_8hpp_source.html#l00401">401</a> of file <a class="el" href="rbicgstab_8hpp_source.html">rbicgstab.hpp</a>.</p>

</div>
</div>
<a id="abeeccd126d8070a5e02655f8d7aae30d" name="abeeccd126d8070a5e02655f8d7aae30d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeeccd126d8070a5e02655f8d7aae30d">&#9670;&#160;</a></span>new_rbicgstab() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_r_bi_c_g_stab.html">RBiCGStab</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_rbicgstab </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_r_bi_c_g_stab.html" title="(Preconditioned) reordered BiCGStab solver implementation">RBiCGStab</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_r_bi_c_g_stab.html" title="(Preconditioned) reordered BiCGStab solver implementation">RBiCGStab</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000034">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="rbicgstab_8hpp_source.html#l00449">449</a> of file <a class="el" href="rbicgstab_8hpp_source.html">rbicgstab.hpp</a>.</p>

</div>
</div>
<a id="a4deeeb38f10e01f5a98d1c7ab69ade53" name="a4deeeb38f10e01f5a98d1c7ab69ade53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4deeeb38f10e01f5a98d1c7ab69ade53">&#9670;&#160;</a></span>new_rgcr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_r_g_c_r.html">RGCR</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_rgcr </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_r_g_c_r.html" title="(Preconditioned) Recycling Generalized Conjugate Residual solver implementation">RGCR</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_r_g_c_r.html" title="(Preconditioned) Recycling Generalized Conjugate Residual solver implementation">RGCR</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000035">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="rgcr_8hpp_source.html#l00277">277</a> of file <a class="el" href="rgcr_8hpp_source.html">rgcr.hpp</a>.</p>

</div>
</div>
<a id="afdd239092529b6d23b1d983b5c16751e" name="afdd239092529b6d23b1d983b5c16751e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd239092529b6d23b1d983b5c16751e">&#9670;&#160;</a></span>new_rgcr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_r_g_c_r.html">RGCR</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_rgcr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_r_g_c_r.html" title="(Preconditioned) Recycling Generalized Conjugate Residual solver implementation">RGCR</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_r_g_c_r.html" title="(Preconditioned) Recycling Generalized Conjugate Residual solver implementation">RGCR</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000036">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="rgcr_8hpp_source.html#l00325">325</a> of file <a class="el" href="rgcr_8hpp_source.html">rgcr.hpp</a>.</p>

</div>
</div>
<a id="a949a4a927b774626fd9dd5313d7afc9c" name="a949a4a927b774626fd9dd5313d7afc9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949a4a927b774626fd9dd5313d7afc9c">&#9670;&#160;</a></span>new_richardson() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_richardson.html">Richardson</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_richardson </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Matrix_::DataType&#160;</td>
          <td class="paramname"><em>omega</em> = <code>typename&#160;Matrix_::DataType(1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_richardson.html" title="(Preconditioned) Richardson solver implementation">Richardson</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">omega</td><td>The damping parameter for the solver.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_richardson.html" title="(Preconditioned) Richardson solver implementation">Richardson</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000037">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="richardson_8hpp_source.html#l00270">270</a> of file <a class="el" href="richardson_8hpp_source.html">richardson.hpp</a>.</p>

</div>
</div>
<a id="a3a84a5de15933f3bd77b8260dae38798" name="a3a84a5de15933f3bd77b8260dae38798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a84a5de15933f3bd77b8260dae38798">&#9670;&#160;</a></span>new_richardson() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_richardson.html">Richardson</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_richardson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename Matrix_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>precond</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_richardson.html" title="(Preconditioned) Richardson solver implementation">Richardson</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">precond</td><td>The preconditioner. May be <code>nullptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_richardson.html" title="(Preconditioned) Richardson solver implementation">Richardson</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000038">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="richardson_8hpp_source.html#l00319">319</a> of file <a class="el" href="richardson_8hpp_source.html">richardson.hpp</a>.</p>

</div>
</div>
<a id="aa9e61383fb1073b657cf006e1ab09abd" name="aa9e61383fb1073b657cf006e1ab09abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e61383fb1073b657cf006e1ab09abd">&#9670;&#160;</a></span>new_saddle_umfpack_mean() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DT_ , typename IT_ , int dim_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_saddle_umfpack_mean.html">SaddleUmfpackMean</a>&lt; DT_, IT_, dim_ &gt; &gt; FEAT::Solver::new_saddle_umfpack_mean </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_saddle_point_matrix.html">LAFEM::SaddlePointMatrix</a>&lt; <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_sparse_matrix_b_c_s_r.html">LAFEM::SparseMatrixBCSR</a>&lt; DT_, IT_, dim_, dim_ &gt;, <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_sparse_matrix_b_c_s_r.html">LAFEM::SparseMatrixBCSR</a>&lt; DT_, IT_, dim_, 1 &gt;, <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_sparse_matrix_b_c_s_r.html">LAFEM::SparseMatrixBCSR</a>&lt; DT_, IT_, 1, dim_ &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_dense_vector.html">LAFEM::DenseVector</a>&lt; DT_, IT_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>weight_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_umfpack_mean.html" title="UMFPACK Mean solver class.">UmfpackMean</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight_vector</td><td>The weight vector to be used as a Lagrange multiplier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_umfpack_mean.html" title="UMFPACK Mean solver class.">UmfpackMean</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="umfpack_8hpp_source.html#l00604">604</a> of file <a class="el" href="umfpack_8hpp_source.html">umfpack.hpp</a>.</p>

</div>
</div>
<a id="aaee97d79e9e16ab8e1a6b5aae8cfd14a" name="aaee97d79e9e16ab8e1a6b5aae8cfd14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee97d79e9e16ab8e1a6b5aae8cfd14a">&#9670;&#160;</a></span>new_saddle_umfpack_mean() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DT_ , typename IT_ , int dim_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_saddle_umfpack_mean.html">SaddleUmfpackMean</a>&lt; DT_, IT_, dim_ &gt; &gt; FEAT::Solver::new_saddle_umfpack_mean </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_saddle_point_matrix.html">LAFEM::SaddlePointMatrix</a>&lt; <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_sparse_matrix_b_c_s_r.html">LAFEM::SparseMatrixBCSR</a>&lt; DT_, IT_, dim_, dim_ &gt;, <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_sparse_matrix_b_c_s_r.html">LAFEM::SparseMatrixBCSR</a>&lt; DT_, IT_, dim_, 1 &gt;, <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_sparse_matrix_b_c_s_r.html">LAFEM::SparseMatrixBCSR</a>&lt; DT_, IT_, 1, dim_ &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_mean_filter.html">LAFEM::MeanFilter</a>&lt; DT_, IT_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_umfpack_mean.html" title="UMFPACK Mean solver class.">UmfpackMean</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>A reference to the mean filter containing the weight vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_umfpack_mean.html" title="UMFPACK Mean solver class.">UmfpackMean</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="umfpack_8hpp_source.html#l00627">627</a> of file <a class="el" href="umfpack_8hpp_source.html">umfpack.hpp</a>.</p>

</div>
</div>
<a id="a22dceb57a3ddbe2a357db7bf197e3747" name="a22dceb57a3ddbe2a357db7bf197e3747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22dceb57a3ddbe2a357db7bf197e3747">&#9670;&#160;</a></span>new_scale_precond() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Filter_ , typename DataType_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_scale_precond.html">ScalePrecond</a>&lt; typename Filter_::VectorType, Filter_ &gt; &gt; FEAT::Solver::new_scale_precond </td>
          <td>(</td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataType_&#160;</td>
          <td class="paramname"><em>omega</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_scale_precond.html" title="Scaling preconditioner class template.">ScalePrecond</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">omega</td><td>The scaling parameter for the preconditioner.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_scale_precond.html" title="Scaling preconditioner class template.">ScalePrecond</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scale__precond_8hpp_source.html#l00124">124</a> of file <a class="el" href="scale__precond_8hpp_source.html">scale_precond.hpp</a>.</p>

</div>
</div>
<a id="a2d4a46c17802ad01d5aa3a257c73255a" name="a2d4a46c17802ad01d5aa3a257c73255a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d4a46c17802ad01d5aa3a257c73255a">&#9670;&#160;</a></span>new_scale_precond() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_scale_precond.html">ScalePrecond</a>&lt; typename Filter_::VectorType, Filter_ &gt; &gt; FEAT::Solver::new_scale_precond </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_scale_precond.html" title="Scaling preconditioner class template.">ScalePrecond</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_scale_precond.html" title="Scaling preconditioner class template.">ScalePrecond</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="scale__precond_8hpp_source.html#l00146">146</a> of file <a class="el" href="scale__precond_8hpp_source.html">scale_precond.hpp</a>.</p>

</div>
</div>
<a id="ae43a39577b0cf19d470f15bc48393954" name="ae43a39577b0cf19d470f15bc48393954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43a39577b0cf19d470f15bc48393954">&#9670;&#160;</a></span>new_schwarz_precond() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LocalFilter_ , typename Mirror_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_schwarz_precond.html">SchwarzPrecond</a>&lt; <a class="el" href="class_f_e_a_t_1_1_global_1_1_vector.html">Global::Vector</a>&lt; typename LocalFilter_::VectorType, Mirror_ &gt;, <a class="el" href="class_f_e_a_t_1_1_global_1_1_filter.html">Global::Filter</a>&lt; LocalFilter_, Mirror_ &gt; &gt; &gt; FEAT::Solver::new_schwarz_precond </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename LocalFilter_::VectorType &gt; &gt;&#160;</td>
          <td class="paramname"><em>local_solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_global_1_1_filter.html">Global::Filter</a>&lt; LocalFilter_, Mirror_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_schwarz_precond.html" title="Schwarz preconditioner class template declaration.">SchwarzPrecond</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">local_solver</td><td>The local solver object.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The global system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_schwarz_precond.html" title="Schwarz preconditioner class template declaration.">SchwarzPrecond</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000040">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="schwarz__precond_8hpp_source.html#l00248">248</a> of file <a class="el" href="schwarz__precond_8hpp_source.html">schwarz_precond.hpp</a>.</p>

</div>
</div>
<a id="aec39e5544cf879ec05d525baa29c3d2e" name="aec39e5544cf879ec05d525baa29c3d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec39e5544cf879ec05d525baa29c3d2e">&#9670;&#160;</a></span>new_schwarz_precond() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LocalFilter_ , typename Mirror_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_schwarz_precond.html">SchwarzPrecond</a>&lt; <a class="el" href="class_f_e_a_t_1_1_global_1_1_vector.html">Global::Vector</a>&lt; typename LocalFilter_::VectorType, Mirror_ &gt;, <a class="el" href="class_f_e_a_t_1_1_global_1_1_filter.html">Global::Filter</a>&lt; LocalFilter_, Mirror_ &gt; &gt; &gt; FEAT::Solver::new_schwarz_precond </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename LocalFilter_::VectorType &gt; &gt;&#160;</td>
          <td class="paramname"><em>local_solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_global_1_1_filter.html">Global::Filter</a>&lt; LocalFilter_, Mirror_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_schwarz_precond.html" title="Schwarz preconditioner class template declaration.">SchwarzPrecond</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">local_solver</td><td>The local solver object.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The global system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_schwarz_precond.html" title="Schwarz preconditioner class template declaration.">SchwarzPrecond</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000039">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="schwarz__precond_8hpp_source.html#l00192">192</a> of file <a class="el" href="schwarz__precond_8hpp_source.html">schwarz_precond.hpp</a>.</p>

</div>
</div>
<a id="a0b1c4d327721b5ac5842ab97e39a4caf" name="a0b1c4d327721b5ac5842ab97e39a4caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b1c4d327721b5ac5842ab97e39a4caf">&#9670;&#160;</a></span>new_secant_linesearch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functional_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_secant_linesearch.html">SecantLinesearch</a>&lt; Functional_, Filter_ &gt; &gt; FEAT::Solver::new_secant_linesearch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functional_ &amp;&#160;</td>
          <td class="paramname"><em>functional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_secant_linesearch.html" title="Secant linesearch.">SecantLinesearch</a> object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">functional</td><td>The functional</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_secant_linesearch.html" title="Secant linesearch.">SecantLinesearch</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="secant__linesearch_8hpp_source.html#l00341">341</a> of file <a class="el" href="secant__linesearch_8hpp_source.html">secant_linesearch.hpp</a>.</p>

</div>
</div>
<a id="a57f2926c35bfaded84ec7bd8aa30c4cd" name="a57f2926c35bfaded84ec7bd8aa30c4cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f2926c35bfaded84ec7bd8aa30c4cd">&#9670;&#160;</a></span>new_secant_linesearch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functional_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_secant_linesearch.html">SecantLinesearch</a>&lt; Functional_, Filter_ &gt; &gt; FEAT::Solver::new_secant_linesearch </td>
          <td>(</td>
          <td class="paramtype">Functional_ &amp;&#160;</td>
          <td class="paramname"><em>functional</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Functional_::DataType&#160;</td>
          <td class="paramname"><em>secant_step</em> = <code><a class="el" href="class_f_e_a_t_1_1_solver_1_1_secant_linesearch.html">SecantLinesearch</a>&lt;Functional_,&#160;Filter_&gt;::secant_step_default</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keep_iterates</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_secant_linesearch.html" title="Secant linesearch.">SecantLinesearch</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">functional</td><td>The functional.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secant_step</td><td>Length for first secant step.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep_iterates</td><td>Flag for keeping the iterates, defaults to false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_secant_linesearch.html" title="Secant linesearch.">SecantLinesearch</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="secant__linesearch_8hpp_source.html#l00313">313</a> of file <a class="el" href="secant__linesearch_8hpp_source.html">secant_linesearch.hpp</a>.</p>

</div>
</div>
<a id="a82dc55f7293235eaed4281f8168361af" name="a82dc55f7293235eaed4281f8168361af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82dc55f7293235eaed4281f8168361af">&#9670;&#160;</a></span>new_sor_precond() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_o_r_precond.html">SORPrecond</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_sor_precond </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_e_a_t.html#a050b7378896da037a96211e8db059029">PreferredBackend</a>&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_o_r_precond.html" title="SOR preconditioner implementation.">SORPrecond</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">backend</td><td>The backend to be preferred. This implementation works with generic and cuda.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_o_r_precond.html" title="SOR preconditioner implementation.">SORPrecond</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sor__precond_8hpp_source.html#l00916">916</a> of file <a class="el" href="sor__precond_8hpp_source.html">sor_precond.hpp</a>.</p>

</div>
</div>
<a id="af10946359e692cbc960308376ef8badd" name="af10946359e692cbc960308376ef8badd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10946359e692cbc960308376ef8badd">&#9670;&#160;</a></span>new_sor_precond() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_o_r_precond.html">SORPrecond</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_sor_precond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_f_e_a_t.html#a050b7378896da037a96211e8db059029">PreferredBackend</a>&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Matrix_::DataType&#160;</td>
          <td class="paramname"><em>omega</em> = <code>typename&#160;Matrix_::DataType(1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_o_r_precond.html" title="SOR preconditioner implementation.">SORPrecond</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">backend</td><td>The backend to be preferred. This implementation works with generic and cuda.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">omega</td><td>The damping value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_o_r_precond.html" title="SOR preconditioner implementation.">SORPrecond</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sor__precond_8hpp_source.html#l00887">887</a> of file <a class="el" href="sor__precond_8hpp_source.html">sor_precond.hpp</a>.</p>

</div>
</div>
<a id="a6df4054f8fde42d2a87893cf9ef1c865" name="a6df4054f8fde42d2a87893cf9ef1c865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df4054f8fde42d2a87893cf9ef1c865">&#9670;&#160;</a></span>new_ssor_precond() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_s_o_r_precond.html">SSORPrecond</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_ssor_precond </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_f_e_a_t.html#a050b7378896da037a96211e8db059029">PreferredBackend</a>&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Matrix_::DataType&#160;</td>
          <td class="paramname"><em>omega</em> = <code>typename&#160;Matrix_::DataType(1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_s_o_r_precond.html" title="SSOR preconditioner implementation.">SSORPrecond</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">backend</td><td>The backend to be preferred. This implementation works with generic and cuda.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">omega</td><td>The damping value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_s_o_r_precond.html" title="SSOR preconditioner implementation.">SSORPrecond</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ssor__precond_8hpp_source.html#l00859">859</a> of file <a class="el" href="ssor__precond_8hpp_source.html">ssor_precond.hpp</a>.</p>

</div>
</div>
<a id="aace7dd0b283bfeac3bba4392e013ed09" name="aace7dd0b283bfeac3bba4392e013ed09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace7dd0b283bfeac3bba4392e013ed09">&#9670;&#160;</a></span>new_ssor_precond() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_s_o_r_precond.html">SSORPrecond</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_ssor_precond </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>section_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_property_map.html">PropertyMap</a> *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_e_a_t.html#a050b7378896da037a96211e8db059029">PreferredBackend</a>&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_s_o_r_precond.html" title="SSOR preconditioner implementation.">SSORPrecond</a> solver object using a <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section_name</td><td>The name of the config section, which it does not know by itself</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>A pointer to the <a class="el" href="class_f_e_a_t_1_1_property_map.html" title="A class organizing a tree of key-value pairs.">PropertyMap</a> section configuring this solver</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">backend</td><td>The backend to be preferred. This implementation works with generic and cuda.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_s_s_o_r_precond.html" title="SSOR preconditioner implementation.">SSORPrecond</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ssor__precond_8hpp_source.html#l00889">889</a> of file <a class="el" href="ssor__precond_8hpp_source.html">ssor_precond.hpp</a>.</p>

</div>
</div>
<a id="ae46fd1bc80db37277acac65c223799ad" name="ae46fd1bc80db37277acac65c223799ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46fd1bc80db37277acac65c223799ad">&#9670;&#160;</a></span>new_superlu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix_ , typename Filter_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_super_l_u.html">SuperLU</a>&lt; Matrix_, Filter_ &gt; &gt; FEAT::Solver::new_superlu </td>
          <td>(</td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_super_l_u.html" title="(distributed) SuperLU direct sparse solver">SuperLU</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_super_l_u.html" title="(distributed) SuperLU direct sparse solver">SuperLU</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="superlu_8hpp_source.html#l00204">204</a> of file <a class="el" href="superlu_8hpp_source.html">superlu.hpp</a>.</p>

</div>
</div>
<a id="ad814c30df2abc2e0151dfa9792eabc75" name="ad814c30df2abc2e0151dfa9792eabc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad814c30df2abc2e0151dfa9792eabc75">&#9670;&#160;</a></span>new_umfpack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_umfpack.html">Umfpack</a> &gt; FEAT::Solver::new_umfpack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_sparse_matrix_c_s_r.html">LAFEM::SparseMatrixCSR</a>&lt; double, <a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_umfpack.html" title="UMFPACK solver class.">Umfpack</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_umfpack.html" title="UMFPACK solver class.">Umfpack</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="umfpack_8hpp_source.html#l00118">118</a> of file <a class="el" href="umfpack_8hpp_source.html">umfpack.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="direct__stokes__solver_8hpp_source.html#l01029">FEAT::Solver::DirectStokesSolver&lt; LAFEM::SaddlePointMatrix&lt; MatrixA_, MatrixB_, MatrixD_ &gt;, LAFEM::TupleFilter&lt; FilterV_, FilterP_ &gt; &gt;::DirectStokesSolver()</a>.</p>

</div>
</div>
<a id="a764bfc8e9007d466dea48527b04a8b4d" name="a764bfc8e9007d466dea48527b04a8b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764bfc8e9007d466dea48527b04a8b4d">&#9670;&#160;</a></span>new_umfpack_mean() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_umfpack_mean.html">UmfpackMean</a> &gt; FEAT::Solver::new_umfpack_mean </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_sparse_matrix_c_s_r.html">LAFEM::SparseMatrixCSR</a>&lt; double, <a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_dense_vector.html">LAFEM::DenseVector</a>&lt; double, <a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weight_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_umfpack_mean.html" title="UMFPACK Mean solver class.">UmfpackMean</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight_vector</td><td>The weight vector to be used as a Lagrange multiplier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_umfpack_mean.html" title="UMFPACK Mean solver class.">UmfpackMean</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="umfpack_8hpp_source.html#l00230">230</a> of file <a class="el" href="umfpack_8hpp_source.html">umfpack.hpp</a>.</p>

</div>
</div>
<a id="aa452c9e3a871162b9d112beaa4bcfb09" name="aa452c9e3a871162b9d112beaa4bcfb09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa452c9e3a871162b9d112beaa4bcfb09">&#9670;&#160;</a></span>new_umfpack_mean() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_umfpack_mean.html">UmfpackMean</a> &gt; FEAT::Solver::new_umfpack_mean </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_sparse_matrix_c_s_r.html">LAFEM::SparseMatrixCSR</a>&lt; double, <a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_mean_filter.html">LAFEM::MeanFilter</a>&lt; double, <a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_umfpack_mean.html" title="UMFPACK Mean solver class.">UmfpackMean</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>A reference to the mean filter containing the weight vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_umfpack_mean.html" title="UMFPACK Mean solver class.">UmfpackMean</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="umfpack_8hpp_source.html#l00249">249</a> of file <a class="el" href="umfpack_8hpp_source.html">umfpack.hpp</a>.</p>

</div>
</div>
<a id="a2958bd09bea2573890967fceb38cb8ae" name="a2958bd09bea2573890967fceb38cb8ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2958bd09bea2573890967fceb38cb8ae">&#9670;&#160;</a></span>new_uzawa_precond()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixA_ , typename MatrixB_ , typename MatrixD_ , typename FilterV_ , typename FilterP_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_uzawa_precond.html">UzawaPrecond</a>&lt; MatrixA_, MatrixB_, MatrixD_, FilterV_, FilterP_ &gt; &gt; FEAT::Solver::new_uzawa_precond </td>
          <td>(</td>
          <td class="paramtype">const MatrixA_ &amp;&#160;</td>
          <td class="paramname"><em>matrix_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixB_ &amp;&#160;</td>
          <td class="paramname"><em>matrix_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixD_ &amp;&#160;</td>
          <td class="paramname"><em>matrix_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterV_ &amp;&#160;</td>
          <td class="paramname"><em>filter_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterP_ &amp;&#160;</td>
          <td class="paramname"><em>filter_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename MatrixB_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>solver_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; typename MatrixD_::VectorTypeL &gt; &gt;&#160;</td>
          <td class="paramname"><em>solver_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a8c9301b94ea72379786a83666a86c4ff">UzawaType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a8c9301b94ea72379786a83666a86c4ffaa0e17e2709a0404ae3d7de03b8ea9093">UzawaType::diagonal</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>auto_init_s</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_uzawa_precond.html" title="Uzawa preconditioner.">UzawaPrecond</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix_a,matrix_b,matrix_d</td><td>The three sub-matrices of the saddle-point system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter_v,filter_p</td><td>The two sub-filters of the system.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solver_a</td><td>The solver object for the A-matrix block.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solver_s</td><td>The solver object for the S-matrix block.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Specifies the type of the preconditioner.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">auto_init_s</td><td>Specifies whether to automatically initialize the S-matrix solver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_uzawa_precond.html" title="Uzawa preconditioner.">UzawaPrecond</a> object. </dd></dl>
<dl class="compilerhacks"><dt><b><a class="el" href="compilerhacks.html#_compilerhacks000041">Compiler Hack:</a></b></dt><dd>GCC &lt; 4.9 fails to deduct shared_ptr </dd></dl>

<p class="definition">Definition at line <a class="el" href="uzawa__precond_8hpp_source.html#l00703">703</a> of file <a class="el" href="uzawa__precond_8hpp_source.html">uzawa_precond.hpp</a>.</p>

</div>
</div>
<a id="ab0d16cb5da09d09a13d1680c576ccf22" name="ab0d16cb5da09d09a13d1680c576ccf22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0d16cb5da09d09a13d1680c576ccf22">&#9670;&#160;</a></span>new_vanka()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixA_ , typename MatrixB_ , typename MatrixD_ , typename Filter_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="class_f_e_a_t_1_1_solver_1_1_vanka.html">Vanka</a>&lt; <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_saddle_point_matrix.html">LAFEM::SaddlePointMatrix</a>&lt; MatrixA_, MatrixB_, MatrixD_ &gt;, Filter_ &gt; &gt; FEAT::Solver::new_vanka </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_e_a_t_1_1_l_a_f_e_m_1_1_saddle_point_matrix.html">LAFEM::SaddlePointMatrix</a>&lt; MatrixA_, MatrixB_, MatrixD_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#a56a1737a447bf0816faf68de552c2064">VankaType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename MatrixA_::DataType&#160;</td>
          <td class="paramname"><em>omega</em> = <code>typename&#160;MatrixA_::DataType(1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1">Index</a>&#160;</td>
          <td class="paramname"><em>num_iter</em> = <code><a class="el" href="namespace_f_e_a_t.html#aea15318a59381180ea8b771242a3bbe1">Index</a>(1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_vanka.html" title="Vanka preconditioner/smoother class template.">Vanka</a> solver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The saddle-point system matrix.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The system filter</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Specifies the <a class="el" href="class_f_e_a_t_1_1_solver_1_1_vanka.html" title="Vanka preconditioner/smoother class template.">Vanka</a> type.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">omega</td><td>The relaxation parameter.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_iter</td><td>The number of <a class="el" href="class_f_e_a_t_1_1_solver_1_1_vanka.html" title="Vanka preconditioner/smoother class template.">Vanka</a> iterations to be performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a new <a class="el" href="class_f_e_a_t_1_1_solver_1_1_vanka.html" title="Vanka preconditioner/smoother class template.">Vanka</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="vanka_8hpp_source.html#l01997">1997</a> of file <a class="el" href="vanka_8hpp_source.html">vanka.hpp</a>.</p>

</div>
</div>
<a id="a8e6b79b11fc66593e4336d1259a158b7" name="a8e6b79b11fc66593e4336d1259a158b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6b79b11fc66593e4336d1259a158b7">&#9670;&#160;</a></span>solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector_ , typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab1c941bc4fb3a678ef08e84cd3fa35ed">Status</a> FEAT::Solver::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_iterative_solver.html">IterativeSolver</a>&lt; Vector_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector_ &amp;&#160;</td>
          <td class="paramname"><em>vec_sol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_ &amp;&#160;</td>
          <td class="paramname"><em>vec_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override of <a class="el" href="namespace_f_e_a_t_1_1_solver.html#afaf7fb5797216195651b6d22eaadc8d2" title="Solve linear system with initial solution guess.">solve()</a> for <a class="el" href="class_f_e_a_t_1_1_solver_1_1_iterative_solver.html" title="Abstract base-class for iterative solvers.">IterativeSolver</a> solvers. </p>

<p class="definition">Definition at line <a class="el" href="iterative_8hpp_source.html#l00930">930</a> of file <a class="el" href="iterative_8hpp_source.html">iterative.hpp</a>.</p>

<p class="reference">References <a class="el" href="class_f_e_a_t_1_1_solver_1_1_iterative_solver.html#a1feb792955098cf117423f18dfd0db8f">FEAT::Solver::IterativeSolver&lt; Vector_ &gt;::correct()</a>.</p>

</div>
</div>
<a id="afaf7fb5797216195651b6d22eaadc8d2" name="afaf7fb5797216195651b6d22eaadc8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf7fb5797216195651b6d22eaadc8d2">&#9670;&#160;</a></span>solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector_ , typename Matrix_ , typename Filter_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab1c941bc4fb3a678ef08e84cd3fa35ed">Status</a> FEAT::Solver::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html">SolverBase</a>&lt; Vector_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector_ &amp;&#160;</td>
          <td class="paramname"><em>vec_sol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_ &amp;&#160;</td>
          <td class="paramname"><em>vec_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix_ &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Filter_ &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solve linear system with initial solution guess. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>The solver object that is to be used for solving the system.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vec_sol</td><td>The solution vector containing an initial guess.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vec_rhs</td><td>The right-hand-side vector of the linear system.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>The matrix of the linear system.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>The filter of the linear system.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>vec_sol and vec_rhs must <b>not</b> refer to the same vector object!</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A status code representing the status of the solving step. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kernel_2solver_2base_8hpp_source.html#l00349">349</a> of file <a class="el" href="kernel_2solver_2base_8hpp_source.html">base.hpp</a>.</p>

<p class="reference">References <a class="el" href="class_f_e_a_t_1_1_solver_1_1_solver_base.html#ae162070c491d897ae6f91d263200af40">FEAT::Solver::SolverBase&lt; Vector_ &gt;::apply()</a>, <a class="el" href="namespace_f_e_a_t_1_1_l_a_f_e_m.html#ad372dae2e320ef82768327bb8342786faebd9bec4d70abc789d439c1f136b0538">FEAT::LAFEM::Layout</a>, and <a class="el" href="kernel_2solver_2base_8hpp_source.html#l00110">status_success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="dudv__functional__control_8hpp_source.html#l00467">FEAT::Control::Meshopt::DuDvFunctionalControl&lt; DT_, IT_, DomainControl_ &gt;::apply()</a>.</p>

</div>
</div>
<a id="a06d657f3235d3857164ec176b6958d87" name="a06d657f3235d3857164ec176b6958d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d657f3235d3857164ec176b6958d87">&#9670;&#160;</a></span>status_success()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FEAT::Solver::status_success </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab1c941bc4fb3a678ef08e84cd3fa35ed">Status</a>&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Status success check function. </p>
<p >This function takes a Status value as input and checks whether it represents a 'successful' run. A solving run is interpreted as successful, if one of the following status codes was returned:</p>
<ul>
<li><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab1c941bc4fb3a678ef08e84cd3fa35eda260ca9dd8a4577fc00b7bd5810298076" title="solving successful (convergence criterion fulfilled)">Status::success</a></li>
<li><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab1c941bc4fb3a678ef08e84cd3fa35edaa520882cd714abbd1bf9f72d23990f0e" title="solver reached maximum iterations">Status::max_iter</a></li>
<li><a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab1c941bc4fb3a678ef08e84cd3fa35edaa3d1e0a7dd736bc430ba471d9dfdf3a2" title="solver stagnated (stagnation criterion fulfilled)">Status::stagnated</a></li>
</ul>
<p >For any other status code, the solving run is interpreted as unsuccessful.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>A status code returned by a solver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code>, if the run was successful, otherwise <code>false</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="kernel_2solver_2base_8hpp_source.html#l00110">110</a> of file <a class="el" href="kernel_2solver_2base_8hpp_source.html">base.hpp</a>.</p>

<p class="reference">References <a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab1c941bc4fb3a678ef08e84cd3fa35edaa520882cd714abbd1bf9f72d23990f0e">max_iter</a>, <a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab1c941bc4fb3a678ef08e84cd3fa35edaa3d1e0a7dd736bc430ba471d9dfdf3a2">stagnated</a>, and <a class="el" href="namespace_f_e_a_t_1_1_solver.html#ab1c941bc4fb3a678ef08e84cd3fa35eda260ca9dd8a4577fc00b7bd5810298076">success</a>.</p>

<p class="reference">Referenced by <a class="el" href="multigrid_8hpp_source.html#l01526">FEAT::Solver::MultiGrid&lt; SystemMatrix_, SystemFilter_, TransferOperator_ &gt;::_apply_coarse()</a>, <a class="el" href="iterative_8hpp_source.html#l01067">FEAT::Solver::PreconditionedIterativeSolver&lt; Vector_ &gt;::_apply_precond()</a>, <a class="el" href="schwarz__precond_8hpp_source.html#l00125">FEAT::Solver::SchwarzPrecond&lt; Global::Vector&lt; LocalVector_, Mirror_ &gt;, Global::Filter&lt; LocalFilter_, Mirror_ &gt; &gt;::apply()</a>, <a class="el" href="convert__precond_8hpp_source.html#l00100">FEAT::Solver::ConvertPrecond&lt; VectorOuter_, VectorInner_ &gt;::apply()</a>, <a class="el" href="convert__precond_8hpp_source.html#l00204">FEAT::Solver::ConvertPrecond&lt; Global::Vector&lt; LocalVectorOuter_, MirrorOuter_ &gt;, Global::Vector&lt; LocalVectorInner_, MirrorInner_ &gt; &gt;::apply()</a>, and <a class="el" href="kernel_2solver_2base_8hpp_source.html#l00349">solve()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_f_e_a_t.html">FEAT</a></li><li class="navelem"><a class="el" href="namespace_f_e_a_t_1_1_solver.html">Solver</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
