<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FEAT: FEAT Voxel Map File Format</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FEAT<span id="projectnumber">&#160;3</span>
   </div>
   <div id="projectbrief">Finite Element Analysis Toolbox</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('voxel_map_file_format.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title"><a class="el" href="namespace_f_e_a_t.html" title="FEAT namespace.">FEAT</a> Voxel Map File Format </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#voxel_map_file_basic">Basic Information about Voxel Maps</a><ul><li class="level2"><a href="#voxel_map_strides">Voxel Map Strides</a></li>
<li class="level2"><a href="#voxel_map_file_indices">Voxel Map Indices</a></li>
<li class="level2"><a href="#voxel_map_file_coords">Voxel Coordinates</a></li>
</ul>
</li>
<li class="level1"><a href="#voxel_map_file_overview">Voxel Map File Overview</a><ul><li class="level2"><a href="#voxel_map_file_header">Voxel Map File Header</a></li>
<li class="level2"><a href="#voxel_map_file_compression_blocks">Voxel Map File Compression Blocks</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p >This page describes the structure of the <a class="el" href="namespace_f_e_a_t.html" title="FEAT namespace.">FEAT</a> VoxelMap file format, which is used to store voxel maps that can be created by using the voxel-map-gen tool and read in as <a class="el" href="class_f_e_a_t_1_1_geometry_1_1_voxel_map.html" title="VoxelMap class.">FEAT::Geometry::VoxelMap</a> objects. Voxel map files are binary files that store a (possibly zlib-compressed) 3D voxel map; 2D voxel maps are stored as voxel maps with Z-dimension equal to 0.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_f_e_a_t_1_1_geometry_1_1_voxel_map.html" title="VoxelMap class.">FEAT::Geometry::VoxelMap</a></dd></dl>
<h1><a class="anchor" id="voxel_map_file_basic"></a>
Basic Information about Voxel Maps</h1>
<p >The entries in a 3D voxel map are stored in XYZ-order as byte arrays, i.e. the voxel map is stored as a sequence of XY-planes, where each plane has the same Z-coordinate, in order of ascending Z-coordinates. Each XY-plane is stored as a sequence of X-lines, where each line has the same YZ-coordinates, in order of ascending Y-coordinates. Each X-line is stores as a sequence of bytes, where each byte contains the bits of eight consecutive voxels, in order of ascending X-coordinates. 2D voxel maps consist only of a singe XY-plane.</p>
<h2><a class="anchor" id="voxel_map_strides"></a>
Voxel Map Strides</h2>
<p >The line stride specifies the length of a single X-line of voxels in bytes. By convention, the line stride must always be a multiple of 16, so typically an X-line of voxels has some padding attached at the end.</p>
<p >Let <b>num_x</b> denote the X-dimension of a voxel map, then the smallest legal line stride is given by the formula</p>
<ul>
<li><b>stride_line := (((num_x + 7) / 8 + 15) / 16) * 16</b></li>
</ul>
<p >where the division operator is assumed to be an integer division. The above formula consists basically of two steps: firstly, divide num_x by 8 and round up to the nearest integer and, secondly, round up to the nearest multiple of 16. The above formula can also be slightly rewritten by using bit-wise operators (yay!):</p>
<ul>
<li><b>stride_line := (((num_x + 7) &gt;&gt; 3) + 15) &amp; ~15)</b></li>
</ul>
<p >The plane stride specifies the length of a single XY-plane of voxels in bytes. Let <b>num_y</b> denote the Y-dimension of a voxel map, then the smallest legal plane stride is given by</p>
<ul>
<li><b>stride_plane := num_y * stride_line</b></li>
</ul>
<p >The volume stide specifies the total size of the XYZ-volume of voxels in bytes. Let <b>num_z</b> denote the Z-dimension of a voxel map, then the smallest legal volume stride is given by</p>
<ul>
<li><b>stride_volume := num_z * stride_plane</b></li>
</ul>
<h2><a class="anchor" id="voxel_map_file_indices"></a>
Voxel Map Indices</h2>
<p >Let (i,j,k) denote the XYZ-indices of a voxel in a 3D voxel map with 0 &lt;= i &lt; num_x, 0 &lt;= j &lt; num_y, 0 &lt;= k &lt; num_z, then the bit of the corresponding voxel can be extracted by the following formula:</p>
<ul>
<li><b>(voxel_map[k*plane_stride + j*line_stride + i/8] &gt;&gt; (i%8)) &amp; 1</b></li>
</ul>
<p >The above formula can also be slightly rewritten by using bit-wise operators (yay!):</p>
<ul>
<li><b>(voxel_map[k*plane_stride + j*line_stride + (i&gt;&gt;3)] &gt;&gt; (i &amp; 7)) &amp; 1</b></li>
</ul>
<h2><a class="anchor" id="voxel_map_file_coords"></a>
Voxel Coordinates</h2>
<p >To avoid storing floating point values in the voxel map file, the choice was made to convert the coordinates to signed integer values by first multiplying the floating point values by 1E+9 and then casting the resulting value to the signed 64-bit integer type.</p>
<p >Furthermore, the domain discretized by the voxel map with a given resolution is represented by the minimum and maximum X/Y/Z coordinates of the domain's bounding box stored as 64-bit signed integer values, so to obtain the floating point values one has to cast the integer values to the floating point format and then multiply these values by 1E-9.</p>
<p >Voxels are represented as point values, so if <b>x_min</b> and <b>x_max</b> are the minimum and maximum X-coordinates (in floating point format) of the bounding box and the voxel map has <b>num_x</b> voxels in X-dimension, then the X-coordinate of the i-th voxel is given by the formula</p>
<ul>
<li><b>x_i := x_min + (x_max - x_min) * Real(i) / Real(num_x - 1)</b></li>
</ul>
<p >where DT_ represents the floating point format, e.g. double. The Y- and Z-coordinates are computed analogously.</p>
<h1><a class="anchor" id="voxel_map_file_overview"></a>
Voxel Map File Overview</h1>
<p >A voxel map file consist of three sections:</p>
<ul>
<li>136-byte file header</li>
<li>compression block size array (only if compressed)</li>
<li>(compressed) voxel map data</li>
</ul>
<p >In the following, let <b>u64</b> denote the 64-bit unsigned integer (i.e. <code>std::uint64_t</code> ) and let <b>i64</b> denote the 64-bit signed integer (i.e. <code>std::int64_t</code> ) stored in little-endian (Intel) byte order.</p>
<h2><a class="anchor" id="voxel_map_file_header"></a>
Voxel Map File Header</h2>
<p >The 136-byte file header is defined in <a class="el" href="struct_f_e_a_t_1_1_geometry_1_1_voxel_map_1_1_file_header.html" title="header structure of voxel map file header">FEAT::Geometry::VoxelMap::FileHeader</a> and its entries look like follows:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">Offset   </th><th class="markdownTableHeadRight">Type   </th><th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Entry    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">0   </td><td class="markdownTableBodyRight">u64   </td><td class="markdownTableBodyNone">magic_number   </td><td class="markdownTableBodyNone">must be equal to 0x70614D6C65786F56 = "VoxelMap"    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">8   </td><td class="markdownTableBodyRight">u64   </td><td class="markdownTableBodyNone">header_size   </td><td class="markdownTableBodyNone">must be equal to 136    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">16   </td><td class="markdownTableBodyRight">i64   </td><td class="markdownTableBodyNone">min_x   </td><td class="markdownTableBodyNone">minimum X-coordinate of bounding box    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">24   </td><td class="markdownTableBodyRight">i64   </td><td class="markdownTableBodyNone">max_x   </td><td class="markdownTableBodyNone">maximum X-coordinate of bounding box    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">32   </td><td class="markdownTableBodyRight">u64   </td><td class="markdownTableBodyNone">num_x   </td><td class="markdownTableBodyNone">number of points in X-dimension    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">40   </td><td class="markdownTableBodyRight">u64   </td><td class="markdownTableBodyNone">stride_line   </td><td class="markdownTableBodyNone">X-line stride: see <a class="el" href="voxel_map_file_format.html#voxel_map_strides">Voxel Map Strides</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">48   </td><td class="markdownTableBodyRight">i64   </td><td class="markdownTableBodyNone">min_y   </td><td class="markdownTableBodyNone">minimum Y-coordinate of bounding box    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">56   </td><td class="markdownTableBodyRight">i64   </td><td class="markdownTableBodyNone">max_y   </td><td class="markdownTableBodyNone">maximum Y-coordinate of bounding box    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">64   </td><td class="markdownTableBodyRight">u64   </td><td class="markdownTableBodyNone">num_y   </td><td class="markdownTableBodyNone">number of points in Y-dimension    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">72   </td><td class="markdownTableBodyRight">u64   </td><td class="markdownTableBodyNone">stride_plane   </td><td class="markdownTableBodyNone">XY-plane stride: see <a class="el" href="voxel_map_file_format.html#voxel_map_strides">Voxel Map Strides</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">80   </td><td class="markdownTableBodyRight">i64   </td><td class="markdownTableBodyNone">min_z   </td><td class="markdownTableBodyNone">minimum Z-coordinate of bounding box    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">88   </td><td class="markdownTableBodyRight">i64   </td><td class="markdownTableBodyNone">max_z   </td><td class="markdownTableBodyNone">maximum Z-coordinate of bounding box    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">96   </td><td class="markdownTableBodyRight">u64   </td><td class="markdownTableBodyNone">num_z   </td><td class="markdownTableBodyNone">number of points in Z-dimension (0 for a 2D voxel map)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">104   </td><td class="markdownTableBodyRight">u64   </td><td class="markdownTableBodyNone">stride_volume   </td><td class="markdownTableBodyNone">XYZ-volume stride: see <a class="el" href="voxel_map_file_format.html#voxel_map_strides">Voxel Map Strides</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">112   </td><td class="markdownTableBodyRight">u64   </td><td class="markdownTableBodyNone">coverage   </td><td class="markdownTableBodyNone">domain coverage multiplied by 1E+9    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">120   </td><td class="markdownTableBodyRight">u64   </td><td class="markdownTableBodyNone">planes_per_block   </td><td class="markdownTableBodyNone">number of planes per compression block (0 if uncompressed)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">128   </td><td class="markdownTableBodyRight">u64   </td><td class="markdownTableBodyNone">num_blocks   </td><td class="markdownTableBodyNone">total number of compression blocks (0 if uncompressed)   </td></tr>
</table>
<h2><a class="anchor" id="voxel_map_file_compression_blocks"></a>
Voxel Map File Compression Blocks</h2>
<p >Voxel maps may (and actually <em>should</em>) be compressed by utilizing the ZLIB compression algorithms, which may easily reduce the overall file size of a voxel map file by over 95%. Since compression can be a quite resource-hungry task, the voxel map file format offers the possibility to compress the voxel map in disjoint plane blocks rather than requiring that the entire voxel map, which may be sereval GB in size, has to be compressed as a single block. The drawback is that the file has to contain an array of sizes of the indiviual compressed blocks, which is a small price to pay.</p>
<p >To reduce code complexity, a compression block can only contain entire XY-planes, i.e. a XY-plane must be contained in its entirety in a single compression block and so in consequence, the size of a compression block is given as the number of planes that it contains rather than the number of bytes, which can be computed by multiplying the number of planes in the block by the plane stride, see <a class="el" href="voxel_map_file_format.html#voxel_map_strides">Voxel Map Strides</a>. Note that 2D voxel maps can only be compressed into a single block.</p>
<p >If a voxel map file is compressed, then the <b>planes_per_block</b> entry of the file header stores the number of planes contained in a single compression block, however, the last compression block will typically contain less planes (unless the total number of planes is a multiple of planes_per_block, of course), i.e. the last compression block is not padded. The total number of compression blocks is stored in the <b>num_blocks</b> entry of the file header, which can be be computed by using the following formula:</p>
<ul>
<li><b>num_blocks = (num_x * num_y + planes_per_block - 1) / planes_per_block</b></li>
</ul>
<p >The sizes of the individual compression blocks are stored in an u64 array of length <b>num_blocks</b> directly after the file header, followed by the individual zlib-compressed voxel map block buffers without any sort of padding.</p>
<p >If the voxel map is not compressed, i.e. header.num_blocks is 0, then the raw voxel map is written directly after the file header without any sort of additional processing.</p>
<dl class="section author"><dt>Author</dt><dd>Peter Zajac </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
