<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FEAT: FEAT for Visual Studio Code on Unix and Windows Systems</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FEAT<span id="projectnumber">&#160;3</span>
   </div>
   <div id="projectbrief">Finite Element Analysis Toolbox</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('feat_for_vscode.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title"><a class="el" href="namespace_f_e_a_t.html" title="FEAT namespace.">FEAT</a> for Visual Studio Code on Unix and Windows Systems </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#vscode_prereques">Prerequisites for using FEAT with VScode</a><ul><li class="level2"><a href="#unix_vscode_prereques">Prerequisites under unix</a><ul><li class="level3"><a href="#unix_vscode_greenhouse">Special case: Module based enviroment</a></li>
</ul>
</li>
<li class="level2"><a href="#win_vscode_prereques">Prerequisites under Windows</a><ul><li class="level3"><a href="#win_vscode_prereqs_mpi">Microsoft MPI</a></li>
<li class="level3"><a href="#win_vscode_prereqs_cuda">Nvidia CUDA</a></li>
<li class="level3"><a href="#win_vscode_prereqs_imkl">Intel MKL</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#vscode_setup">VScode setup</a></li>
<li class="level1"><a href="#vscode_configuration_setup">Configuration Setup</a></li>
<li class="level1"><a href="#vscode_cmake_tools">Working with CMake Tools</a><ul><li class="level2"><a href="#vscode_cmake_configure">Configuring FEAT</a></li>
<li class="level2"><a href="#vscode_cmake_build">Building FEAT</a></li>
</ul>
</li>
<li class="level1"><a href="#vscode_cmake_run">Running FEAT</a></li>
<li class="level1"><a href="#vscode_editor">Working with VScode</a><ul><li class="level2"><a href="#intellisense_filediscovery">Problems with file discovery</a></li>
</ul>
</li>
<li class="level1"><a href="#clangd">Using clangd as Language Server</a><ul><li class="level2"><a href="#clangd_setup">Setup of clangd</a></li>
<li class="level2"><a href="#clangd_config">Configuring clangd</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p >This page describes the setup and use of <a class="el" href="namespace_f_e_a_t.html" title="FEAT namespace.">FEAT</a> with the Visual Studio Code editor.</p>
<h1><a class="anchor" id="vscode_prereques"></a>
Prerequisites for using FEAT with VScode</h1>
<h2><a class="anchor" id="unix_vscode_prereques"></a>
Prerequisites under unix</h2>
<p >In addition to a working build toolchain, i.e. a compiler toolchain, e.g. gcc or LLVM/clang, and a generator, e.g. make or ninja, in your path, you need at least a version of CMake 3.28 or higher and a version of python(3) installed, both of which should also be in your path. Of course you will also need <code>VScode</code> installed. To also use MPI, etc., see the configure script, but basically certain packages, such as MPI or CUDA, need to be pre-installed and findable on your system, i.e. in your path or you are able to pass the location, others like UMFPACK, Zoltan, ... will be automatically installed in a <a class="el" href="namespace_f_e_a_t.html" title="FEAT namespace.">FEAT</a> subdirectory if you pass the flag to the configure system, more on this later.</p>
<h3><a class="anchor" id="unix_vscode_greenhouse"></a>
Special case: Module based enviroment</h3>
<p >In the case of a module-based software distribution, first load the modules you need, then open <code>VScode</code> from the terminal by changing the current directory to the <a class="el" href="namespace_f_e_a_t.html" title="FEAT namespace.">FEAT</a> source folder and run </p><pre class="fragment">  code .
</pre><p >You should also consider running <code>VScode</code> from a compute server so that the building and IntelliSense shenanigans are performed on the server's resources.</p>
<h2><a class="anchor" id="win_vscode_prereques"></a>
Prerequisites under Windows</h2>
<p >For a number of reasons, <a class="el" href="namespace_f_e_a_t.html" title="FEAT namespace.">FEAT</a> in <code>VScode</code> can only be fully compiled (i.e. with (all) third party libraries) using the <code>Visual Studio 2022 clang/llvm</code> toolchain, which has the side-effect that, due to a bug in the <code>VS22</code> implementation, no address sanitiser can be used for the time being. Hopefully this will be fixed in the next major release. You will also need at least a <code>CMake 3.9</code> version, preferably at least a <code>CMake 3.15</code> version, and a <code>python3</code> version. While <code>VS22</code> provides ninja as a build generator, you can of course provide your own (e.g. <code>MinGW</code>'s <code>make</code>). All of these need to be included in your path, see standard Windows documentation on how to do this.</p>
<dl class="section attention"><dt>Attention</dt><dd>A few notes on installing <code>VS22</code>: To use clang with GNU-style command-line arguments (which is currently the only supported compilation toolchain), you need to add the corresponding option in your <code>VS22</code> installation. You will also need a relatively new Windows SDK that your compiler can find. An easy way to archive this is to also select the option to install the latest Windows SDK in your <code>VS22</code> installation. If <code>VS22</code> is in your path, you should then be able to find the GNU style Clang toolchain.</dd></dl>
<h3><a class="anchor" id="win_vscode_prereqs_mpi"></a>
Microsoft MPI</h3>
<p >If you want to make use of <a class="el" href="namespace_f_e_a_t.html" title="FEAT namespace.">FEAT</a>'s parallel computing capabilities, you will also need to install the <b>Microsoft MPI</b> library as well as the corresponding SDK. Note that installing MPI is <b>not</b> mandatory, however, without this library, <a class="el" href="namespace_f_e_a_t.html" title="FEAT namespace.">FEAT</a> is limited to its "single-process" functionality.</p>
<dl class="section note"><dt>Note</dt><dd>Previous attempts to support other MPI implementations such as <code>MPICH</code> or <code>OpenMPI</code> in combination with Visual Studio have not been successful, so these (and other) implementations are officially unsupported by the <a class="el" href="namespace_f_e_a_t.html" title="FEAT namespace.">FEAT</a> Visual Studio build-system. Sorry for the inconvenience.</dd></dl>
<p>You can download the latest version of the MS-MPI library here:</p><ul>
<li><a href="https://learn.microsoft.com/en-us/message-passing-interface/microsoft-mpi">https://learn.microsoft.com/en-us/message-passing-interface/microsoft-mpi</a></li>
<li><b>Important:</b> You need to download and install <b>both</b> <code>MSMpiSetup.exe</code> and <code>msmpisdk.msi</code>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>From MS-MPI Version 7 on, you will need to enable the <em>MS-MPI Launch Service</em> to <em>start automatically</em> on your windows machine, as otherwise MPI-based applications may not start. The easiest way to do so is to execute the following command in a console (with administrator rights): <pre class="fragment">sc config MsMpiLaunchSvc start= auto
</pre></dd></dl>
<p>Once you have installed MS-MPI and setup the launch service, there is nothing more to do, as the build-system will automatically detect that an MPI implementation is available.</p>
<h3><a class="anchor" id="win_vscode_prereqs_cuda"></a>
Nvidia CUDA</h3>
<p >Nvidia CUDA is not currently supported by the <a class="el" href="namespace_f_e_a_t.html" title="FEAT namespace.">FEAT</a> Visual Studio build system. This will be enabled at a later date.</p>
<h3><a class="anchor" id="win_vscode_prereqs_imkl"></a>
Intel MKL</h3>
<p >Intel MKL is not currently supported by the <a class="el" href="namespace_f_e_a_t.html" title="FEAT namespace.">FEAT</a> Visual Studio build system. This will be enabled at a later date.</p>
<h1><a class="anchor" id="vscode_setup"></a>
VScode setup</h1>
<p >Before configuring <a class="el" href="namespace_f_e_a_t.html" title="FEAT namespace.">FEAT</a> with <code>VScode</code> for the first time, we need to set up a few things in <code>VScode</code>. First of all, you need to install (by Microsoft recommended) the <code>C/C++</code> toolset extension , which consists of <code>C/C++</code> language support, in particular debugger, <code>AutoComplete</code> and <code>IntelliSense</code> support, <code>CMake</code> language support and, very importantly, the <code>CMake Tools</code> extension, which handles the configuration of <code>CMake</code> projects as well as building and project support for <code>IntelliSense</code>.</p>
<p >After starting <code>VScode</code> it will prompt you to select a compiler kit. Select any kit for now. We will give <code>VScode</code> more specific instructions on how to configure and build <a class="el" href="namespace_f_e_a_t.html" title="FEAT namespace.">FEAT</a> later.</p>
<dl class="section note"><dt>Note</dt><dd>A few things to keep in mind: <a class="el" href="namespace_f_e_a_t.html" title="FEAT namespace.">FEAT</a>'s ctesting does not work with multiple threads. For this reason, with <pre class="fragment"> CTRL + Shift + P   -&gt; Preferences: Open Settings(UI)</pre> set <pre class="fragment"> Extensions -&gt;  CMake Tools -&gt; Ctest: Parallel Jobs</pre> 0 to 1.</dd></dl>
<p>You can also change some parameters here, such as the name and path of your build directory and so on. Just use the defaults for now.</p>
<dl class="section note"><dt>Note</dt><dd>For now, ignore any recommandation prompts <code>VScode</code> gives.</dd></dl>
<h1><a class="anchor" id="vscode_configuration_setup"></a>
Configuration Setup</h1>
<p >The CMake Toolse extension uses CMake <a href="https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html">presets</a> to determine how to configure and build <a class="el" href="namespace_f_e_a_t.html" title="FEAT namespace.">FEAT</a>. Whenever you execute the configure script the generated configuration gets appended to the CMakeUserPresets.json file in the root of your <a class="el" href="namespace_f_e_a_t.html" title="FEAT namespace.">FEAT</a> repository. If a configuration with the same build-id already exists, it will be overwritten. Whenever you run the configure script, <code>VScode</code> should automatically pick up any new or changed presets. You can select the preset you want to use in the CMake tab of the sidebar or via</p>
<pre class="fragment"> CTRL + Shift + P   -&gt; CMake: Select Configure Preset</pre><p ><code>VScode</code> will then create its own independent build directory in <code>out/${presetName}</code> and configure <a class="el" href="namespace_f_e_a_t.html" title="FEAT namespace.">FEAT</a>.</p>
<dl class="section note"><dt>Note</dt><dd>If you do not want your own build directory and only want to use the one managed by <code>VScode</code> you can run the configure script with the <code>&ndash;preset-only</code> flag.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>If a third-party library is not found in your third-party folder, it will be downloaded automatically. For this reason (and others) you should place your <a class="el" href="namespace_f_e_a_t.html" title="FEAT namespace.">FEAT</a> source directory somewhere where you do not need root or admin rights to write/modify files.</dd></dl>
<h1><a class="anchor" id="vscode_cmake_tools"></a>
Working with CMake Tools</h1>
<h2><a class="anchor" id="vscode_cmake_configure"></a>
Configuring FEAT</h2>
<p >After choosing your preset, VScode will automatically start a (shallow) <code>CMake</code> configuration and you should be able to build your first programs.</p>
<dl class="section attention"><dt>Attention</dt><dd>If something does not work, or you get a configuration warning, you should do a clean configuration using <pre class="fragment"> CTRL + Shift + P -&gt; Cmake delete cache and reconfigure</pre></dd></dl>
<h2><a class="anchor" id="vscode_cmake_build"></a>
Building FEAT</h2>
<p >You could now navigate to the build directory in <code>out/${presetName}</code> and build executables from the command line, but you can also use <code>CMake Tools</code> to build executables in <a class="el" href="namespace_f_e_a_t.html" title="FEAT namespace.">FEAT</a>. As an example, let us build the first tutorial. With </p><pre class="fragment"> CTRL + Shift + P -&gt; Build target -&gt; tutorial-01</pre><p> you can compile the first tutorial executable. Of course, this will take a moment as <a class="el" href="namespace_f_e_a_t.html" title="FEAT namespace.">FEAT</a> has to be built from scratch. Once this is done (successfully), we can run our tutorial.</p>
<dl class="section note"><dt>Note</dt><dd>After the first configuration, you can run ctest with <pre class="fragment"> CTRL + Shift + P -&gt; CMake: Run Tests</pre> to verify that everything is working. Note that you need to set the number of ctest threads to 1 as described above.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Ctest in combination with MPI is currently broken with the WINMPI implementation.</dd></dl>
<h1><a class="anchor" id="vscode_cmake_run"></a>
Running FEAT</h1>
<p >You can either run from the command line in your build directory, or via <code>CMake run</code>. If you want to provide command line arguments, you need to edit the <b>settings.json </b> file with </p><pre class="fragment"> "cmake.debugConfig": {
        "args": [
            "MyArgument"
        ]
    }</pre><h1><a class="anchor" id="vscode_editor"></a>
Working with VScode</h1>
<p >For a good introduction, refer to <a href="https://github.com/microsoft/vscode-cmake-tools/blob/main/docs/README.md"><code>CMake Tools'</code> Github page</a>. </p>
<h2><a class="anchor" id="intellisense_filediscovery"></a>
Problems with file discovery</h2>
<p >The file detection process and subsequent file parsing can be a bit temperamental, especially if the files are not local to the running process (e.g. a shared file system). While there are still a few things to optimise, it helps to wait until the parsing process has finished before opening any <code>C/C++</code> files, to avoid the IntelliSense process from trying to parse the current file, as this seems to interact with the detection/parsing process. You can see if file detection/parsing is currently running by hovering over the "container" icon, which is aligned to the left of the right status icons of the blue CMake tools status bar, see the image. </p><div class="image">
<img src="vs_code_statusbar.png" alt=""/>
</div>
<p >If there is no change or it reports as halted, reload your window and do a clean reconfigure. </p><dl class="section note"><dt>Note</dt><dd>IntelliSense parses every folder in the <code>PATH</code> variable, so it is advisable not to allow discovery of large folders that are not needed to compile <a class="el" href="namespace_f_e_a_t.html" title="FEAT namespace.">FEAT</a>. If detection is slow, it may help to exclude the <code>/usr/include</code> folder (especially on a shared file system). To do this, open the VScode <code>settings</code> menu, select the workspace settings and search for <pre class="fragment"> C_cpp files: exclude</pre> Click on the <code>Edit in settings.json</code> option and add to the list in <code>"C_Cpp.files.exclude"</code> <pre class="fragment"> "/usr/include": true</pre> The entry in the <code>json</code> file should be as follows <pre class="fragment"> "C_Cpp.files.exclude": {
        "/usr/include": true,
        "**/.vscode": true,
        "**/.vs": true
    }</pre> If you want to see, which folders are included in your <code>PATH</code>, check <pre class="fragment"> C/Cpp: Log Diagnostics</pre></dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>If you create a new <code>header file</code> which is not included anywhere in the project, you will see an include error generated by IntelliSense for any <code>header file</code>. To fix this, simply add the new <code>header file</code>, i.e. the file where you see the error, not the include target, to any source list of an executable. While this does not change the build process, it fixes the bug.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>You should also add <code> ms-vscode.cmake-tools </code> to the default <code>configuration provider</code> setting of IntelliSense.</dd></dl>
<h1><a class="anchor" id="clangd"></a>
Using clangd as Language Server</h1>
<p >Instead of using the C/C++ extension of Microsoft, using clangd as language server can improve performance espacially on the side of file disovery. While there are a few disadvanteges, mainly the missing parsing of doxygen comments (which is a feature request momentarily under <a href="https://github.com/clangd/clangd/issues/529">review</a> ), it should be considered if you are running into problems with the IntelliSense setup.</p>
<h2><a class="anchor" id="clangd_setup"></a>
Setup of clangd</h2>
<p >First of all, you should have a clangd installed in your system. Since clangd is part of the LLVM project, it should be part of your clang installation. To test this, and get the path to yopu clangd installation, simply type into a terminal </p><pre class="fragment">which clangd
</pre><p >After you have confirmed the location of your clangd installation, search in <code>VScode</code> extentions the clangd plug-in, which handles the configuration of the language server. You will also see a prompt asking which language server should be your default provider, choose clangd. Then, add to your settings file: </p><pre class="fragment">"C_Cpp.intelliSenseEngine": "disabled", //disable intellisense lsp
"cmake.copyCompileCommands": "${workspaceFolder}/compile_commands.json",
"clangd.path": "/usr/bin/clangd",
"clangd.arguments": ["-log=verbose",
                     "-pretty",
                     "--background-index",
                     "--compile-commands-dir=${workspaceFolder}"]
</pre><p >which disables IntelliSense, adds a few options to the clangd language server, and instructs the CMake extension to copy the current compile_commands.json file to the project root for clangd to find. The compile_commands.json file provides the building information clangd needs to correctly parse your project. It is automatically generated by CMake each time you (re-)configure <a class="el" href="namespace_f_e_a_t.html" title="FEAT namespace.">FEAT</a>.</p>
<p >To reduce the load IntelliSense has on the system, you can also add to your settings file </p><pre class="fragment">"C_Cpp.intelliSenseCacheSize": 0,
"C_Cpp.intelliSenseMemoryLimit": 256,
"C_Cpp.autocomplete": "disabled",
"C_Cpp.hover": "disabled"
</pre><dl class="section note"><dt>Note</dt><dd>If you do not require debugging capabilities, for which we still need IntelliSense, you can deactivate the C/C++ extension complettly, since everything else should be handled by clangd.</dd></dl>
<h2><a class="anchor" id="clangd_config"></a>
Configuring clangd</h2>
<p >It can be very helpful to provide clangd with extra information in you sourcefiles (for example extra include or typedefs), which are unecessary or even wrong in the actual build process. This can very well happen, if for example a header file depends on a prior include of another header, which is done on application level (as for example done in the new ccnd applications). To differentiate between clangd compilation and any other, we add an additional compile flag to our clangd setup. For this create a file under the local config directory <code>~/.config/clangd</code>(if it does not exist, create it) named <code>config.yaml</code>. Here simply add </p><pre class="fragment">CompileFlags:
  Add: [-D_CLANGD=1]
</pre><p >Which adds a compiler definition <code>_CLANGD</code> which can be checked with a <code>#ifdef</code> pre-compiler call.</p>
<p >/TODO: Add additional configuration options and information regarding cland-tidy .</p>
<dl class="section author"><dt>Author</dt><dd>Maximilian Esser </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
