<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FEAT: Analytic Lambda Expression Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FEAT<span id="projectnumber">&#160;3</span>
   </div>
   <div id="projectbrief">Finite Element Analysis Toolbox</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('analytic_lambda_function.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Analytic Lambda Expression Functions </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ana_lambda_general">General Information</a></li>
<li class="level1"><a href="#ana_lambda_format">Lambda Expression Interface</a><ul><li class="level2"><a href="#ana_lambda_params">Additional Parameters in Lambda Expressions</a></li>
<li class="level2"><a href="#ana_lambda_threads">Lambda Expression Thread Safety</a></li>
</ul>
</li>
<li class="level1"><a href="#ana_lambda_create">Lambda Function Object Creation</a><ul><li class="level2"><a href="#ana_lambda_derive_extrapol">Richardson Extrapolation of Derivatives</a></li>
<li class="level2"><a href="#ana_lambda_examples_scalar">Scalar Examples</a></li>
<li class="level2"><a href="#ana_lambda_examples_vector">Vector-Valued Examples</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p >The main purpose of this page is to outsource and concentrate most of the vital documentation from all the classes and helper functions related to analytical lambda function to avoid large amounts of copy-&amp;-pasted documentation, because the classes are syntactically mostly identical, but outsourcing the code is not possible of feasible due to technical limitation and/or to obey the <a href="https://en.wikipedia.org/wiki/KISS_principle">KISS principle</a>.</p>
<h1><a class="anchor" id="ana_lambda_general"></a>
General Information</h1>
<p >This page describes the basic principles as well as the interface and usage recommendations of the lambda function class templates defined in the <a class="el" href="lambda__function_8hpp_source.html">kernel/analytic/lambda_function.hpp</a> header file, which allow the user to easily create objects that implement the <a class="el" href="class_f_e_a_t_1_1_analytic_1_1_function.html" title="Analytic Function interface.">FEAT::Analytic::Function</a> interface by supplying formulae as C++ standard conforming lambda expressions, thus providing an easy-to-use and little-to-write way of implementing simple functions for the assembly of right-hand-sides, boundary condition functions, initial value functions, etc.</p>
<dl class="section see"><dt>See also</dt><dd>For more information about C++ lambda expressions and the can of worms associated with them, please refer to e.g.:<ul>
<li><a href="https://en.cppreference.com/w/cpp/language/lambda">https://en.cppreference.com/w/cpp/language/lambda</a></li>
<li><a href="https://www.cprogramming.com/c++11/c++11-lambda-closures.html">https://www.cprogramming.com/c++11/c++11-lambda-closures.html</a></li>
</ul>
</dd></dl>
<p>The documentation on this page refers to the five class templates</p><ul>
<li><a class="el" href="class_f_e_a_t_1_1_analytic_1_1_lambda_scalar_function1_d.html" title="Analytic 1D scalar lambda expression function implementation.">FEAT::Analytic::LambdaScalarFunction1D</a> : R<sup>1</sup> -&gt; R</li>
<li><a class="el" href="class_f_e_a_t_1_1_analytic_1_1_lambda_scalar_function2_d.html" title="Analytic scalar 2D lambda expression function implementation.">FEAT::Analytic::LambdaScalarFunction2D</a> : R<sup>2</sup> -&gt; R</li>
<li><a class="el" href="class_f_e_a_t_1_1_analytic_1_1_lambda_scalar_function3_d.html" title="Analytic 3D scalar lambda expression function implementation.">FEAT::Analytic::LambdaScalarFunction3D</a> : R<sup>3</sup> -&gt; R</li>
<li><a class="el" href="class_f_e_a_t_1_1_analytic_1_1_lambda_vector_function2_d.html" title="Analytic 2D vector-valued lambda expression function implementation.">FEAT::Analytic::LambdaVectorFunction2D</a> : R<sup>2</sup> -&gt; R<sup>2</sup></li>
<li><a class="el" href="class_f_e_a_t_1_1_analytic_1_1_lambda_vector_function3_d.html" title="Analytic 3D vector-valued lambda expression function implementation.">FEAT::Analytic::LambdaVectorFunction3D</a> : R<sup>3</sup> -&gt; R<sup>3</sup></li>
</ul>
<p >as well as their corresponding construction helper function overloads</p><ul>
<li><a class="el" href="namespace_f_e_a_t_1_1_analytic.html#a1f6bcb57051dc254b174dde0fbb2d1dd" title="Creates a scalar 1D lambda function from function values only.">FEAT::Analytic::create_lambda_function_scalar_1d</a> : R<sup>1</sup> -&gt; R</li>
<li><a class="el" href="namespace_f_e_a_t_1_1_analytic.html#a6e4ae076ad0886f63f9a84b1ad6c935c" title="Creates a scalar 2D lambda function from function values only.">FEAT::Analytic::create_lambda_function_scalar_2d</a> : R<sup>2</sup> -&gt; R</li>
<li><a class="el" href="namespace_f_e_a_t_1_1_analytic.html#acbd9a080745ac1a6577ae1d181bf2e81" title="Creates a scalar 3D lambda function from function values only.">FEAT::Analytic::create_lambda_function_scalar_3d</a> : R<sup>3</sup> -&gt; R</li>
<li><a class="el" href="namespace_f_e_a_t_1_1_analytic.html#a7d3c4212ae4adbb38fad9e50bb807862" title="Creates a vector-valued 2D lambda function from function values only.">FEAT::Analytic::create_lambda_function_vector_2d</a> : R<sup>2</sup> -&gt; R<sup>2</sup></li>
<li><a class="el" href="namespace_f_e_a_t_1_1_analytic.html#a43371fff77a522e94fcdb63ea9c97c78" title="Creates a vector-valued 3D lambda function from function values only.">FEAT::Analytic::create_lambda_function_vector_3d</a> : R<sup>3</sup> -&gt; R<sup>3</sup></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>There is no support for vector-valued lambda functions for R<sup>m</sup> -&gt; R<sup>n</sup> with m != n for three reasons: Firstly, this case is a bit more exotic than the case m=n and therefore implementing it is kind of a waste of time and, secondly, supporting this case would require a more complicated = more confusing = more error-prone implementation of all the (helper) classes involved and, thirdly, it would lead to ambiguities in the meaning of the parameters supplied to the create_lambda_function_vector_nd functions. Therefore, the m != n case has been deliberately ignored; if you are in need for a function class for this case, implement it directly as a custom class deriving from the <a class="el" href="class_f_e_a_t_1_1_analytic_1_1_function.html" title="Analytic Function interface.">FEAT::Analytic::Function</a> interface &ndash; I swear, it's really not that hard ^_^</dd></dl>
<h1><a class="anchor" id="ana_lambda_format"></a>
Lambda Expression Interface</h1>
<p >All lambda expressions, which are to be used by any of the classes and functions mentioned on this page, are expected to conform to the following format, where <code>DT_</code> denotes the datatype (typically <code>double</code>) that is used for the assembly: </p><div class="fragment"><div class="line">[](DT_ x              ) -&gt; DT_ {<span class="keywordflow">return</span> ...;} <span class="comment">// for 1D</span></div>
<div class="line">[](DT_ x, DT_ y       ) -&gt; DT_ {<span class="keywordflow">return</span> ...;} <span class="comment">// for 2D</span></div>
<div class="line">[](DT_ x, DT_ y, DT_ z) -&gt; DT_ {<span class="keywordflow">return</span> ...;} <span class="comment">// for 3D</span></div>
</div><!-- fragment --><p> Obviously, the <code>x</code>, <code>y</code> and <code>z</code> parameters represent the (real element) space coordinates in which the analytic function is being evaluated.</p>
<p >Furthermore, one may also make use of generic lambda expressions to let the compiler deduct the datatype automatically: </p><div class="fragment"><div class="line">[](<span class="keyword">auto</span> x                ) {<span class="keywordflow">return</span> ...;} <span class="comment">// for 1D</span></div>
<div class="line">[](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y        ) {<span class="keywordflow">return</span> ...;} <span class="comment">// for 2D</span></div>
<div class="line">[](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {<span class="keywordflow">return</span> ...;} <span class="comment">// for 3D</span></div>
</div><!-- fragment --><p> However, the use of generic lambda expressions may lead to floating point conversion warnings if the literals used in the return expression do not match the datatype of the coordinate parameters.</p>
<h2><a class="anchor" id="ana_lambda_params"></a>
Additional Parameters in Lambda Expressions</h2>
<p >It is possible to supply additional constants and variables to lambda expressions by capturing local variables (see lambda captures in online sources), either by value or by reference. For example, the sine-bubble function, which is implemented in <a class="el" href="namespace_f_e_a_t_1_1_analytic_1_1_common.html#ac0ebe2e9afdaa6243fd67dea4b6fa09a" title="Sine-Bubble Analytic function.">FEAT::Analytic::Common::SineBubbleFunction</a>, can be written as a lambda expression conforming to the above mentioned interace as follows: </p><div class="fragment"><div class="line"><span class="keyword">const</span> DT_ pi = Math::pi&lt;DT_&gt;();</div>
<div class="line"><span class="keyword">auto</span> lambda_sine = [pi](DT_ x, DT_ y) -&gt; DT_ {<span class="keywordflow">return</span> Math::sin(pi*x)*Math::sin(pi*y);};</div>
</div><!-- fragment --><p >As a more complex example, the pressure function of the Taylor-Green-Vortex, which is implemented in <a class="el" href="class_f_e_a_t_1_1_analytic_1_1_common_1_1_taylor_green_vortex_pres2_d.html" title="Taylor-Green Vortex pressure function.">FEAT::Analytic::Common::TaylorGreenVortexPres2D</a>, can be written as a lambda expression as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> DT_ pi = Math::pi&lt;DT_&gt;();</div>
<div class="line">DT_ nu = ...; <span class="comment">// viscosity parameter &#39;nu&#39;</span></div>
<div class="line">DT_ t = ...;  <span class="comment">// current simulation time &#39;t&#39;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// all-in-one lambda expression</span></div>
<div class="line"><span class="keyword">auto</span> lambda_tg1 = [pi,&amp;nu,&amp;t](DT_ x, DT_ y) -&gt; DT_ {<span class="keywordflow">return</span> Math::exp(-DT_(4)*pi*pi*nu*t) * DT_(0.5) * (Math::sqr(Math::cos(pi*x)) + Math::sqr(Math::cos(pi*y)) - DT_(1));};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// alternatively: oursource exp-factor:</span></div>
<div class="line">DT_ ef = Math::exp(-DT_(4)*pi*pi*nu*t) * DT_(0.5);</div>
<div class="line"><span class="keyword">auto</span> lambda_tg2 = [pi,&amp;ef](DT_ x, DT_ y) -&gt; DT_ {<span class="keywordflow">return</span> ef * (Math::sqr(Math::cos(pi*x)) + Math::sqr(Math::cos(pi*y)) - DT_(1));};</div>
</div><!-- fragment --><h2><a class="anchor" id="ana_lambda_threads"></a>
Lambda Expression Thread Safety</h2>
<p >Generally, you are free to use all the various types of variable capturing (by copy, by reference) that is offered by the C++ standard, however, you should keep a few things in mind, especially when referencing more complex data structures than simple local variables of some fundamental types such as <code>double</code> or <code>int</code>.</p>
<dl class="section attention"><dt>Attention</dt><dd>Firstly, the functor objects, which are created from the lambda expressions, must be <b>copyable</b>, because the Evaluator sub-classes of the actual lambda function implementation will explicitly create a an independent copy of the lambda functor for each Evaluator object. Noncopyable lambda expression will lead to compiler errors during the instantiation of the Evaluator classes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Fortunately, it is actually somewhat challenging to create a non-copyable lambda expression, so it is unlikely that you'll run into this problem by accident, because it requires to capture a non-copyable-but-moveable object by actually moving it into a local object by value. Simply don't do this.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Secondly, assembly classes (such as the <a class="el" href="class_f_e_a_t_1_1_assembly_1_1_domain_assembler.html" title="Domain Integral Assembler class template.">FEAT::Assembly::DomainAssembler</a>) are explicitly allowed to create multiple instances of the Evaluator classes &ndash; and therefore the lambda functor objects embedded in these Evaluator objects &ndash; simultaneously side by side, especially in the context of a multi-threaded assembly. In consequence, the lambda expressions must <b>not</b> modify any local variables that they capture by reference, because this would inevitably lead to race conditions between the various instances of the lambda functor objects.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In fact, you should generally assume that several copies of you lambda expressions will exist side-by-side and that these copies might be used simultaneously by different threads. However, it is safe to assume that no single lambda functor object will be used by multiple threads simultaneously, because each thread owns his own exclusive set of lambda functor object copies.</dd></dl>
<h1><a class="anchor" id="ana_lambda_create"></a>
Lambda Function Object Creation</h1>
<p >It is highly recommended to use the <code>create_lambda_function_scalar_nd</code> / <code>create_lambda_function_vector_nd</code> helper functions to create new instances of the <code>LambdaScalarFunctionND</code> / <code>LambdaVectorFunctionND</code> class templates and receiving the returned objects in an <code>auto-declared</code> object instead of trying to create the class template instances directly by hand, because the latter approach would result in an incomprehensible lambda-template type nesting mumbo- jumbo that is extremely prone to typing errors.</p>
<dl class="section note"><dt>Note</dt><dd>All instances of the <code>LambdaScalarFunctionND</code> / <code>LambdaVectorFunctionND</code> class templates are by default both copyable and moveable, and therefore there is usually no need to create these objects on the heap.</dd></dl>
<p>To create a lambda function object, choose the create helper function that corresponds to the type of function that you want to define from the list below:</p>
<p >as well as their corresponding construction helper function overloads</p><ul>
<li><a class="el" href="namespace_f_e_a_t_1_1_analytic.html#a1f6bcb57051dc254b174dde0fbb2d1dd" title="Creates a scalar 1D lambda function from function values only.">FEAT::Analytic::create_lambda_function_scalar_1d</a> creates a <a class="el" href="class_f_e_a_t_1_1_analytic_1_1_lambda_scalar_function1_d.html" title="Analytic 1D scalar lambda expression function implementation.">FEAT::Analytic::LambdaScalarFunction1D</a> for f: R<sup>1</sup> -&gt; R</li>
<li><a class="el" href="namespace_f_e_a_t_1_1_analytic.html#a6e4ae076ad0886f63f9a84b1ad6c935c" title="Creates a scalar 2D lambda function from function values only.">FEAT::Analytic::create_lambda_function_scalar_2d</a> creates a <a class="el" href="class_f_e_a_t_1_1_analytic_1_1_lambda_scalar_function2_d.html" title="Analytic scalar 2D lambda expression function implementation.">FEAT::Analytic::LambdaScalarFunction2D</a> for f: R<sup>2</sup> -&gt; R</li>
<li><a class="el" href="namespace_f_e_a_t_1_1_analytic.html#acbd9a080745ac1a6577ae1d181bf2e81" title="Creates a scalar 3D lambda function from function values only.">FEAT::Analytic::create_lambda_function_scalar_3d</a> creates a <a class="el" href="class_f_e_a_t_1_1_analytic_1_1_lambda_scalar_function3_d.html" title="Analytic 3D scalar lambda expression function implementation.">FEAT::Analytic::LambdaScalarFunction3D</a> for f: R<sup>3</sup> -&gt; R</li>
<li><a class="el" href="namespace_f_e_a_t_1_1_analytic.html#a7d3c4212ae4adbb38fad9e50bb807862" title="Creates a vector-valued 2D lambda function from function values only.">FEAT::Analytic::create_lambda_function_vector_2d</a> creates a <a class="el" href="class_f_e_a_t_1_1_analytic_1_1_lambda_vector_function2_d.html" title="Analytic 2D vector-valued lambda expression function implementation.">FEAT::Analytic::LambdaVectorFunction2D</a> for f: R<sup>2</sup> -&gt; R<sup>2</sup></li>
<li><a class="el" href="namespace_f_e_a_t_1_1_analytic.html#a43371fff77a522e94fcdb63ea9c97c78" title="Creates a vector-valued 3D lambda function from function values only.">FEAT::Analytic::create_lambda_function_vector_3d</a> creates a <a class="el" href="class_f_e_a_t_1_1_analytic_1_1_lambda_vector_function3_d.html" title="Analytic 3D vector-valued lambda expression function implementation.">FEAT::Analytic::LambdaVectorFunction3D</a> for f: R<sup>3</sup> -&gt; R<sup>3</sup></li>
</ul>
<p >Each of the create functions offers a total of 3 overloads:</p><ul>
<li>an overload that accepts lambda expression for the function values only</li>
<li>an overload that accepts lambda expressions for up to first-order partial derivatives</li>
<li>an overload that accepts lambda expressions for up to second-order partial derivatives</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The lambda expression(s) for the function value(s) are mandatory and therefore cannot be omitted, whereas the lambda expressions for the derivatives are optional and thus the first and second overloads can be used to omit the specification of second and even first order derivatives. For the sake of convenience, these overloads will then utilize a Richardson extrapolation scheme based on second-order central difference quotients, which also allows the user/assembler to evaluate both the gradients and hessians of lambda functions even if these have not been explicitly supplied by the user as lambda expressions. In consequence, it is unnecessary (and therefore also pointless) to wrap a lambda function object in an <a class="el" href="class_f_e_a_t_1_1_analytic_1_1_auto_derive.html" title="Auto-Derive function wrapper class template.">FEAT::Analytic::AutoDerive</a> wrapper under any circumstances.</dd></dl>
<p>In the case of the create_lambda_function_scalar_nd functions, the lambda expressions are specified in the following order:</p><ul>
<li>function value (1 expression)</li>
<li>first-order partial derivatives (dx, dy [2D/3D], dz [3D])</li>
<li>second-order partial derivatives (dxx, dyy [2D/3D], dzz [3D])</li>
<li>second-order mixed partial derivatives (dxy [2D/3d], dyz [3D], dzx [3D])</li>
</ul>
<p >In the case of the create_lambda_function_vector_nd functions, the order of the lambda expressions is the same as for scalar functions, however, each scalar component is now replaced by lambda expressions for each indiviual component of the vector field:</p><ul>
<li>function values:<ul>
<li>value1, value2 [2D/3D], value3 [3D]</li>
</ul>
</li>
<li>first-order partial derivatives:<ul>
<li>dx1, dx2 [2D/3D], dx3 [3D]</li>
<li>dy1 [2D], dy2 [2D/3D], dy3 [3D]</li>
<li>dz1 [3D], dz2 [3D], dz3 [3D]</li>
</ul>
</li>
<li>second-order partial derivatives (dxx, dyy [2D/3D], dzz [3D])<ul>
<li>analoguous to first-order derivatives</li>
</ul>
</li>
<li>second-order mixed partial derivatives (dxy [2D/3d], dyz [3D], dzx [3D])<ul>
<li>analoguous to first-order derivatives</li>
</ul>
</li>
</ul>
<p >It is possible, but not necessary to create local objects for the lambda expression functors before passing them as arguments to the create_lambda_function_scalar/vector_nd functions &ndash; it is usually more convenient to pass the lambda expressions directly as arguments to the create_lambda_function_scalar/vector_nd functions.</p>
<h2><a class="anchor" id="ana_lambda_derive_extrapol"></a>
Richardson Extrapolation of Derivatives</h2>
<p >As said before, if you do not specify the formulae for the first and/or second order derivatives explicitly, then the Lambda function classes will automatically enable a Richardson extrapolation scheme based on second-order central difference quotients. The Richardson extrapolation scheme can be configured up to a certain extend by specifying an initial h for the extrapolation scheme as well as the maximum number of Richardson iterations by setting the <code>initial_h_grad</code> / <code>initial_h_hess</code> and <code>max_steps_grad</code> / <code>max_steps_hess</code> attributes of the Lambda function classes. The default initial for both gradient and hessian extrapolation is set to 0.01 and the default maximum number of extrapolation steps is set to 10. There are currently no getter/setter functions for these two attributes, but they are public, so you can access them directly, although there is little reason to change them unless in very specific scenarios.</p>
<h2><a class="anchor" id="ana_lambda_examples_scalar"></a>
Scalar Examples</h2>
<p >A simple example to create an analytic Lambda function object for the scalar 2D function \(x^2-y^2\) (without specifying any partial derivatives explicitly) by using generic lambdas is given here: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> saddle_func = create_lambda_function_scalar_2d( [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y){<span class="keywordflow">return</span> x*x - y*y;} );</div>
</div><!-- fragment --><p >One may also provide the first and second partial derivatives: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> saddle_func = create_lambda_function_scalar_2d(</div>
<div class="line">  [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {<span class="keywordflow">return</span>  x*x - y*y;}, <span class="comment">// function value</span></div>
<div class="line">  [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {<span class="keywordflow">return</span>  2.0*x;},     <span class="comment">// X-derivative</span></div>
<div class="line">  [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {<span class="keywordflow">return</span> -2.0*y;},     <span class="comment">// Y-derivative</span></div>
<div class="line">  [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {<span class="keywordflow">return</span>  2.0;},       <span class="comment">// XX-derivative</span></div>
<div class="line">  [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {<span class="keywordflow">return</span> -2.0;},       <span class="comment">// YY-derivative</span></div>
<div class="line">  [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {<span class="keywordflow">return</span>  0.0;}        <span class="comment">// XY-derivative</span></div>
<div class="line">);</div>
</div><!-- fragment --><p> Please note that the compiler may emit floating point conversion warnings in the above example if the function is used in an assembly method that uses <code>float</code> as the datatype because the literals 2.0 and 0.0 are both of type <code>double</code>.</p>
<p >The following example creates a local variable for pi and captures by copy it to implement the sine-bubble function in 3D including all first and second order partial derivatives: </p><div class="fragment"><div class="line"><span class="keyword">const</span> DataType pi = Math::pi&lt;DataType&gt;();</div>
<div class="line"><span class="keyword">auto</span> sine_bubble = create_lambda_function_scalar_3d(</div>
<div class="line">  [pi](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {<span class="keywordflow">return</span>        Math::sin(pi*x)*Math::sin(pi*y)*Math::sin(pi*z);}, <span class="comment">// function value</span></div>
<div class="line">  [pi](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {<span class="keywordflow">return</span>     pi*Math::cos(pi*x)*Math::sin(pi*y)*Math::sin(pi*z);}, <span class="comment">// X-derivative</span></div>
<div class="line">  [<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {<span class="keywordflow">return</span>     <a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>*Math::sin(pi*x)*Math::cos(pi*y)*Math::sin(pi*z);}, <span class="comment">// Y-derivative</span></div>
<div class="line">  [<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {<span class="keywordflow">return</span>     <a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>*Math::sin(pi*x)*Math::sin(pi*y)*Math::cos(pi*z);}, <span class="comment">// Z-derivative</span></div>
<div class="line">  [<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {<span class="keywordflow">return</span> -<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>*<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>*Math::sin(pi*x)*Math::sin(pi*y)*Math::sin(pi*z);}, <span class="comment">// XX-derivative</span></div>
<div class="line">  [<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {<span class="keywordflow">return</span> -<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>*<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>*Math::sin(pi*x)*Math::sin(pi*y)*Math::sin(pi*z);}, <span class="comment">// YY-derivative</span></div>
<div class="line">  [<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {<span class="keywordflow">return</span> -<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>*<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>*Math::sin(pi*x)*Math::sin(pi*y)*Math::sin(pi*z);}, <span class="comment">// ZZ-derivative</span></div>
<div class="line">  [<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {<span class="keywordflow">return</span>  <a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>*<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>*Math::cos(pi*x)*Math::cos(pi*y)*Math::sin(pi*z);}, <span class="comment">// XY-derivative</span></div>
<div class="line">  [<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {<span class="keywordflow">return</span>  <a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>*<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>*Math::sin(pi*x)*Math::cos(pi*y)*Math::cos(pi*z);}, <span class="comment">// YZ-derivative</span></div>
<div class="line">  [<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {<span class="keywordflow">return</span>  <a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>*<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>*Math::cos(pi*x)*Math::sin(pi*y)*Math::cos(pi*z);}  <span class="comment">// ZX-derivative</span></div>
<div class="line">);</div>
<div class="ttc" id="anamespace_f_e_a_t_1_1_math_html_a1d707c23de398006f44a1cd0ec8f2a5e"><div class="ttname"><a href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">FEAT::Math::pi</a></div><div class="ttdeci">T_ pi()</div><div class="ttdoc">Returns the mathematical constant pi = 3.1415...</div><div class="ttdef"><b>Definition:</b> <a href="math_8hpp_source.html#l00726">math.hpp:726</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="ana_lambda_examples_vector"></a>
Vector-Valued Examples</h2>
<p >Here comes a vector-valued example, which implements the Taylor-Green-Vortex velocity field, which is also implemented by the class <a class="el" href="namespace_f_e_a_t_1_1_analytic_1_1_common.html" title="Analytic Common namespace.">FEAT::Analytic::Common</a>:TaylorGreenVortexVelo2D. This example outsources the exponential forefactor that contains the current simulation time into a local variable named <code>factor</code>, which is then captured by reference, so that the lambda function object will always use the up-to-date factor, even when it changes during the simulation: </p><div class="fragment"><div class="line"><span class="keyword">const</span> DataType pi = Math::pi&lt;DataType&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// exponential factor containing the time variable</span></div>
<div class="line">DataType factor = Math::exp(-2.0*pi*pi*nu*t));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// create Taylor-Green velocity field</span></div>
<div class="line"><span class="keyword">auto</span> taylor_green_velocity = create_lambda_vector_2d(</div>
<div class="line">  [pi,&amp;factor](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {<span class="keywordflow">return</span>  factor *         Math::sin(pi*x) * Math::cos(pi*y);}, <span class="comment">// u1 value</span></div>
<div class="line">  [pi,&amp;factor](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {<span class="keywordflow">return</span> -factor *         Math::cos(pi*x) * Math::sin(pi*y);}, <span class="comment">// u2 value</span></div>
<div class="line">  [<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>,&amp;factor](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {<span class="keywordflow">return</span>  factor *    <a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a> * Math::cos(pi*x) * Math::cos(pi*y);}, <span class="comment">// u1 X-derivative</span></div>
<div class="line">  [<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>,&amp;factor](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {<span class="keywordflow">return</span>  factor *    <a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a> * Math::sin(pi*x) * Math::sin(pi*y);}, <span class="comment">// u2 X-derivative</span></div>
<div class="line">  [<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>,&amp;factor](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {<span class="keywordflow">return</span> -factor *    <a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a> * Math::sin(pi*x) * Math::sin(pi*y);}, <span class="comment">// u1 Y-derivative</span></div>
<div class="line">  [<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>,&amp;factor](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {<span class="keywordflow">return</span> -factor *    <a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a> * Math::cos(pi*x) * Math::cos(pi*y);}, <span class="comment">// u2 Y-derivative</span></div>
<div class="line">  [<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>,&amp;factor](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {<span class="keywordflow">return</span> -factor * <a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>*<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a> * Math::sin(pi*x) * Math::cos(pi*y);}, <span class="comment">// u1 XX-derivative</span></div>
<div class="line">  [<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>,&amp;factor](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {<span class="keywordflow">return</span>  factor * <a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>*<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a> * Math::cos(pi*x) * Math::sin(pi*y);}, <span class="comment">// u2 XX-derivative</span></div>
<div class="line">  [<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>,&amp;factor](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {<span class="keywordflow">return</span> -factor * <a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>*<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a> * Math::sin(pi*x) * Math::cos(pi*y);}, <span class="comment">// u1 YY-derivative</span></div>
<div class="line">  [<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>,&amp;factor](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {<span class="keywordflow">return</span>  factor * <a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>*<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a> * Math::cos(pi*x) * Math::sin(pi*y);}, <span class="comment">// u2 YY-derivative</span></div>
<div class="line">  [<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>,&amp;factor](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {<span class="keywordflow">return</span> -factor * <a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>*<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a> * Math::cos(pi*x) * Math::sin(pi*y);}, <span class="comment">// u1 XY-derivative</span></div>
<div class="line">  [<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>,&amp;factor](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {<span class="keywordflow">return</span>  factor * <a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a>*<a class="code hl_function" href="namespace_f_e_a_t_1_1_math.html#a1d707c23de398006f44a1cd0ec8f2a5e">pi</a> * Math::sin(pi*x) * Math::cos(pi*y);}  <span class="comment">// u2 XY-derivative</span></div>
<div class="line">);</div>
</div><!-- fragment --> <dl class="section author"><dt>Author</dt><dd>Peter Zajac </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
