#!/usr/bin/env python3
# FEAT3: Finite Element Analysis Toolbox, Version 3
# Copyright (C) 2010 - 2023 by Stefan Turek & the FEAT group
# FEAT3 is released under the GNU General Public License version 3,
# see the file 'copyright.txt' in the top level directory for details.
########################################################################################################################
# FEAT 1.x 3D TRI to 2D PRM/TRI mesh format converter
# ---------------------------------------------------
# This script converts a single-layered 3D mesh in FEAT 1.x TRI file format to a 2D FEAT 1.x PRM/TRI file format pair,
# so that this 2D mesh can be imported into DeViSoR Grid 3 and then be processed further to generate and export a
# FEAT 3 compatible XML mesh file containing the 2D mesh.
#
# If you don't know what DeViSoR Grid 3 is, you can stop reading now and spend your time elsewhere.
#
# USAGE: tri3d_to_2d.py <input-tri-file> <out-prefix>
#
# This script always creates a pair of output files: a PRM file and a TRI file, which must reside in the same directory,
# select the PRM file in DeViSoR to read in the mesh file.
#
# \author Peter Zajac
########################################################################################################################
import re
import sys

if len(sys.argv) < 3:
  print("USAGE: tri3d_to_2d.py <input-tri-file> <out-prefix>\n")
  sys.exit(0)

# open input file
fi = open(sys.argv[1], "rt")

# skip first two comment lines
fi.readline()
fi.readline()

# read counts and split
headline = fi.readline().strip()
header = headline.split()
if len(header) < 7:
  print("ERROR: expected header in line 3 but got '%s'" % headline)
  sys.exit(1)

# ensure that this is a hex mesh
if int(header[3]) != 8:
  print("ERROR: expected a hexa mesh, but NVE is " + header[4])
  sys.exit(1)

# parse vertex and element counts
nel = int(header[0])
nvt = int(header[1])

# next line should be 'DCORVG'
if fi.readline().strip() != "DCORVG":
  print("ERROR: expected 'DCORVG' in line 4")
  sys.exit(1)

# parse vertices
print("Parsing %i vertices..." % nvt)
line = 5
vtx = []
while len(vtx) < nvt:
  line += 1
  ls = fi.readline().strip()
  vl = ls.split()
  if len(vl) != 3:
    print("ERROR: expected 3 coordinates in line %i, but found '%s'" % (line, ls))
    sys.exit(1)
  vtx += [vl]

# allocate vertex mask
msk = [0]*nvt

# next line should be 'KVERT'
line += 1
if fi.readline().strip() != "KVERT":
  print("ERROR: expected 'KVERT' in line %i" % line)
  sys.exit(1)

# parse elements
print("Parsing %i elements..." % nel)
idx = []
while len(idx) < nel:
  line += 1
  ls = fi.readline().strip()
  xl = ls.split()
  if len(xl) != 8:
    print("ERROR: expected 8 indices in line %i, but found '%s'" % (line, ls))
    sys.exit(1)
  ix = [0]*4
  # mask first four vertices (bottom plane)
  for i in range(0, 4):
    ix[i] = int(xl[i])-1
    msk[ix[i]] = 1
  idx += [ix]

fi.close()

# compute masked vertex table
tbl = [0]*nvt
for i in range(1, nvt):
  tbl[i] = tbl[i-1] + msk[i-1]
nvc = tbl[-1]

print("Masked %i vertices in bottom plane" % nvc)

# write PRM file
print("Writing '%s.prm'..." % sys.argv[2])
fo = open(sys.argv[2] + ".prm", "wt")
fo.write("NBCT\n0\nPARAMETERS\n")
fo.close()

# write TRI file
print("Writing '%s.tri'..." % sys.argv[2])
fo = open(sys.argv[2] + ".tri", "wt")
fo.write("Generated by 'tri3d_to_2d.py' mesh flattener skript\nSteamrolling Otto's meshes since 2024 ^_^\n")
fo.write(" %i %i 0 4 0 NEL NVT NMT NVE NBCT\n" % (nel, nvc))
fo.write("DCORVG\n")
for i in range(0, nvt):
  if msk[i] != 0:
    fo.write("%s %s\n" % (vtx[i][0],vtx[i][1]))
fo.write("KVERT\n")
for i in range(0, nel):
  fo.write("%i %i %i %i\n" % (tbl[idx[i][0]]+1,tbl[idx[i][1]]+1,tbl[idx[i][2]]+1,tbl[idx[i][3]]+1))
fo.write("KNPR\n")
for i in range(0, nvc):
  fo.write("0\n")
fo.close()

print("Done!")
