#!/usr/bin/env python3
# vim: set filetype=python sw=2 sts=2 et nofoldenable :

# FEAT3: Finite Element Analysis Toolbox, Version 3
# Copyright (C) 2010 by Stefan Turek & the FEAT group
# FEAT3 is released under the GNU General Public License version 3,
# see the file 'copyright.txt' in the top level directory for details.

import argparse
import copy
import os
import platform
import shlex
import shutil
import subprocess
import sys

sys.dont_write_bytecode = True
from build_system.detect_cpu import detect_cpu
from build_system.detect_cuda_arch import detect_cuda_arch
from build_system.configure_gcc import configure_gcc
from build_system.configure_icc import configure_icc
from build_system.configure_icx import configure_icx
from build_system.configure_clang import configure_clang
from build_system.configure_cray import configure_cray
from build_system.configure_msvc import configure_msvc
from build_system.feat_util import is_found
from build_system.feat_util import find_exe
from build_system.feat_util import get_output
from build_system.feat_util import error
from build_system.feat_util import header
from build_system.feat_util import warning
from build_system.feat_util import append_preset_to_file
from build_system.is_subdirectory import *

class FeatConfig:
  """Class representing a possible FEAT3 configuration.

  Stores compilers, cmake/compiler/linker flags, and other miscellaneous data
  """
  def __init__(self):
    # Build id for this configuration
    self.buildid = []
    # Set of cmake cache variables
    self.cmake_cache = {}
    # List of C compiler flags
    self.c_flags = []
    # List of C++ compiler flags
    self.cxx_flags = []
    # List of linker flags
    self.ld_flags = []
    # Set of environment variables
    self.env = {}
    # Chosen C++ compiler
    self.compiler_cxx = ""
    # Chosen C compiler
    self.compiler_cc = ""
    # Chosen compiler wrapper, if any
    self.compiler_wrapper = ""
    # Chosen system host compiler
    self.system_host_compiler = ""
    # Chosen CMake generator
    self.generator = "Unix Makefiles"
    # Chosen (or determined) cpu type
    self.cputype = ""
    # Cuda architecture
    self.cuda_arch = ""
    self.cuda_arch_int = 0

  def set_compiler_cxx(self, compiler):
    """Set CXX compiler. Will abort if a different compiler is already set."""
    if self.compiler_cxx and self.compiler_cxx != compiler:
      error("Trying to configure with multiple different C++ compilers")
    self.compiler_cxx = compiler

  def set_compiler_cc(self, compiler):
    """Set CC compiler. Will abort if a different compiler is already set."""
    if self.compiler_cc and self.compiler_cc != compiler:
      error("Trying to configure with multiple different C compilers")
    self.compiler_cc = compiler

  def set_compiler_wrapper(self, wrapper):
    """Set the compiler wrapper. Errors if a different wrapper was already set"""
    if self.compiler_wrapper and self.compiler_wrapper != wrapper:
      error("Trying to configure with multiple different compiler wrapper")
    self.compiler_wrapper = wrapper

  def cache_entry(self, var, value, kind="STRING"):
    """Add a CMake cache entry. Warns if the entry already exists and either the value or type changed"""
    if var in self.cmake_cache and self.cmake_cache[var]["value"] != value:
      error("Duplicate CMake cache entry for", var, "with different value")
    if var in self.cmake_cache and self.cmake_cache[var]["type"] != kind:
      error("Duplicate CMake cache entry for", var, "with different type")

    self.cmake_cache[var] = {
      "value": value,
      "type": kind
    }

  def append_entry(self, var, value, kind="STRING"):
    """Adds or appends a CMake cache entry. Warns if the type changed"""
    if var in self.cmake_cache and self.cmake_cache[var]["type"] != kind:
      error("Duplicate CMake cache entry for", var, "with different type")
    if var in self.cmake_cache:
      self.cmake_cache[var]["value"] += ";" + value
    else:
      self.cmake_cache[var] = {
        "value": value,
        "type": kind
      }

  def add_c_flags(self, *args):
    """Add CC compiler flags. Warns on duplicate flags"""
    for flag in args:
      if flag in self.c_flags:
        warning("C flag", flag, "is set twice")
      else:
        self.c_flags.append(flag)

  def add_cxx_flags(self, *args):
    """Add CXX compiler flags. Warns on duplicate flags"""
    for flag in args:
      if flag in self.cxx_flags:
        warning("CXX flag", flag, "is set twice")
      else:
        self.cxx_flags.append(flag)

  def add_ld_flags(self, *args):
    """Add linker flags. Warns on duplicate flags"""
    for flag in args:
      if flag in self.ld_flags:
        warning("Linker flag", flag, "is set twice")
      else:
        self.ld_flags.append(flag)

  def cmake_flags(self):
    """Return the CMake flags as a list"""
    flags = []

    for var, entry in self.cmake_cache.items():
      if entry["type"]:
        flags.append(f"-D{var}:{entry['type']}={entry['value']}")
      else:
        flags.append(f"-D{var}={entry['value']}")

    return flags


  def cmake_flags_str(self):
    """Return the CMake flags as a string that can be passed to cmake."""
    return " ".join(self.cmake_flags())

  def cxx_flags_str(self):
    """Return the CXX flags as a string that can be passed to the compiler."""
    return " ".join(self.cxx_flags)

  def c_flags_str(self):
    """Return the CC flags as a string that can be passed to the compiler."""
    return " ".join(self.c_flags)

  def ld_flags_str(self):
    """Return the linker flags as a string that can be passed to the compiler."""
    return " ".join(self.ld_flags)

  def get_compiler_cxx(self):
    """Return the CXX compiler for this configuration. Handles compiler wrappers."""
    if self.compiler_wrapper:
      return self.compiler_wrapper + " " + self.compiler_cxx
    else:
      return self.compiler_cxx

  def get_compiler_c(self):
    """Return the CC compiler for this configuration. Handles compiler wrappers."""
    if self.compiler_wrapper:
      return self.compiler_wrapper + " " + self.compiler_cc
    else:
      return self.compiler_cc

  def get_linker(self):
    """Return the linker for this configuration."""
    return self.compiler_cxx

  def as_configure_preset(self):
    """Returns a dictionary that can be written as a JSON CMake configure preset"""
    environment = {}

    for key, value in self.env.items():
      environment[key] = value

    environment["CXXFLAGS"] = self.cxx_flags_str()
    environment["CXX"] = self.get_compiler_cxx()
    environment["LD"] = self.get_linker()
    environment["CC"] = self.get_compiler_c()
    environment["LDFLAGS"] = self.ld_flags_str()
    environment["CFLAGS"] = self.c_flags_str()

    return {
      "name": "-".join(self.buildid),
      "generator": self.generator,
      "binaryDir": "./build",
      "cacheVariables": self.cmake_cache,
      "environment": environment,
    }

# get path to feat source trunk
trunk_dirname = os.path.abspath(os.path.dirname(sys.argv[0]))
#get current path to build directory
build_dirname = os.getcwd()

description = (
  "Configures FEAT3 and sets up all necessary environment variables.\n"
  "\n"
  "The build system of FEAT3 is intended to be configured in a separate build directory, which shall\n"
  "not be a sub-directory of the source directory. This way, your source directory will remain clean\n"
  "of any object files and compiled binaries. Please create a build directory at a location of your\n"
  "choice and call this configure script from within that folder and supply either the tag 'guess'\n"
  "or a valid 'build-id' (see below) to configure your FEAT3 compilation.\n"
  "\n"
  "============= REQUIREMENTS ==================\n"
  "Needs CMake (at least version 3.28.0) to run properly.\n"
  "\n"
  "============= BUILD-ID ======================\n"
  "The FEAT3 build-id is a string of various keyword tokens, delimited by hyphens,\n"
  "which are used to select a compiler, configure the build mode and enable additional functionality.\n"
  "A valid build-id requires at least a compiler tag and a build mode tag, all other tags are optional.\n"
  "\n"
  "The following build-id tags, grouped by category, are currently supported by this script:\n"
  "\n"
  "* Compiler suite (mutually exclusive):\n"
  "  - 'gcc':   use the GNU C++ compiler, version 7.0 or newer (binaries 'gcc' and 'g++')\n"
  "  - 'icc':   use the Intel C/C++ compiler, version 19.0 or newer (binaries 'icc' and 'icpc')\n"
  "  - 'icx':   use the oneAPI DPC++/C++ compiler, version 2021 or newer (binaries 'icx' and 'icpx')\n"
  "  - 'clang': use the Clang LLVM compiler, version 19.0 or newer (binaries 'clang' and 'clang++')\n"
  "  - 'cray':  use the Cray C/C++ compiler\n"
  "\n"
  "* Build mode (mutually exclusive):\n"
  "  - 'opt':   compile in optimized mode (recommended)\n"
  "  - 'debug': compile in debug mode and disable all optimizations\n"
  "  - 'nopt':  compile in non-optimized mode\n"
  "\n"
  "* Parallelization backends:\n"
  "  - 'mpi':  enable MPI-based cluster parallelization\n"
  "  - 'cuda': enable Nvidia CUDA-based GPU parallelization\n"
  "  - 'mkl':  enable Intel MKL-based thread parallelization\n"
  "  - 'omp':  enable OpenMP based thread parallelization\n"
  "\n"
  "* CMake generators:\n"
  "  - 'unixmake':  generate GNU make makefiles (default)\n"
  "  - 'ninja':     generate ninja files\n"
  "  - 'xcode':     generate XCode project files\n"
  "  - 'vsproject': generate Visual Studio project files\n"
  "\n"
  "* Build system extensions\n"
  "  - 'ccache': enable ccache\n"
  "  - 'cotire': enable cotire\n"
  "\n"
  "* Instrumentation\n:"
  "  - 'scorep': enable instrumentation by Score-P\n"
  "  - 'likwid': enable instrumentation by LIKWID\n"
  "\n"
  "* Additional debugging features:\n"
  "  - 'valgrind':     set proper suppressions and flags for valgrind\n"
  "  - 'cudamemcheck': enable cuda memcheck (only in combination with CUDA)\n"
  "  - 'sanitizer':    enable sanitize compiler flags\n"
  "\n"
  "* Additional optimization features:\n"
  "  - 'lto': enable link-time optimizations\n"
  "\n"
  "* Additional floating point formats:\n"
  "  - 'quadmath': enable libquadmath __float128 type (GCC only)\n"
  "  - 'half':     enable CUDA half type (requires CUDA)\n"
  "\n"
  "* Additional third-party libraries (TPL):\n"
  "  - 'alglib':       enable ALGLIB library TPL\n"
  "  - 'boost':        enable BOOST TPL\n"
  "  - 'cgal':         enable CGAL TPL, requires BOOST\n"
  "  - 'cudss':        enable CUDSS cuda direct sparse solver TPL\n"
  "  - 'deathhandler': enable deathhandler TPL\n"
  "  - 'fparser':      enable fparser TPL\n"
  "  - 'floatx':       enable floatx TPL\n"
  "  - 'hypre':        enable HYPRE TPL\n"
  "  - 'metis':        enable METIS and ParMETIS TPLs\n"
  "  - 'pmp':          enable PMP TPL\n"
  "  - 'superlu':      enable SuperLU_Dist TPL\n"
  "  - 'triangle':     enable triangle TPL\n"
  "  - 'trilinos':     link against pre-built Trilinos library\n"
  "  - 'umfpack':      enable UMFPACK TPL\n"
  "  - 'zfp':          enable zfp TPL\n"
  "  - 'zlib':         enable ZLIB TPL\n"
  "  - 'zoltan':       enable Zoltan TPL\n"
  "\n"
  "Note that the actual compiler version and mpi implementation is chosen by the\n"
  "'first come, first served' principle corresponding to your $PATH settings.\n"
  "\n"
  "============= Thirdparty Dependencies =======\n"
  "CMake will try to satisfy all thirdparty dependencies you requested in the build-id.\n"
  "It will, in order, try to find locally installed versions of the dependencies, try to find\n"
  "cached versions to add to the build, and finally download any missing dependencies and add them to the build.\n"
  "You can forbid using locally installed versions of the dependencies using the --no-external-libs flag.\n"
  "You can forbid using cached files with the --no-thirdparty-cache flag.\n"
  "You can forbid using downloaded dependencies with the --no-external-downloads flag.\n"
  "\n"
  "============= CMake Presets =================\n"
  "To properly integrate with other tooling (for example the CMake Tools Visual Studio Code extension)\n"
  "this configure script will add a CMake preset to the CMakeUserPresets.json file in the repository this\n"
  "this script is located in. This allows other tooling to easily build FEAT with the same configuration\n"
  "you use for your own build directory. In a module-based environment, make sure you load the same modules\n"
  "when running VSCode as you did when running the configure script for your preset.\n"
  "\n"
  "The presets are named by their build-id. If a preset for a build-id already exists, it will be overwritten.\n"
  "\n"
  "If you only want to generate a preset, without configuring a build directory, you can use the --preset-only flag.\n"
  "If you do not want to generate a preset, for example because you do not have write-access to the repository, use\n"
  "the --no-preset flag."
)

epilog = (
  "Note that the first gcc(g++) in $PATH is chosen as the cuda host compiler, if no other one is provided.\n"
  "Note that these options might not be applicable in guess mode."
)

parser = argparse.ArgumentParser(description=description, epilog=epilog, formatter_class=argparse.RawDescriptionHelpFormatter)

parser.add_argument("buildid", default="guess", nargs="?", help="build-id for this configuration. Will be guessed if not given")

parser.add_argument("--allow-unsupported-compiler", "--allow_unsupported_compiler", action="store_true", help=
"allow an unsupported host compiler for nvcc")

parser.add_argument("--cc", help=
"override default C compiler binary with absolute path to binary. This option does not replace the compiler tag in the build-id")

parser.add_argument("--cpu", help=
"override cpu auto detection with provided string. See build_system/detect_cpu.py for a list")

parser.add_argument("--cuda-arch", "--cuda_arch", help=
"selects the cuda architecture target. (default: check by return value of nvidia-smi, sm_60 if not available)")

parser.add_argument("--cuda-host-compiler", "--cuda_host_compiler", help=
"selects the system compiler (and header files) used by nvcc (default: /usr/bin/gcc")

parser.add_argument("--cuda-verbose", "--cuda_verbose", action="store_true", help=
"enable verbose cuda compilation (default: %(default)s)")

parser.add_argument("--cxx", help=
"override default C++ compiler binary with absolute path to binary. This option does not replace the compiler tag in the build-id")

parser.add_argument("--eickt", action="store_true", help=
"explicitely instantiate common kernel templates")

parser.add_argument("--finalize-resets-device", "--finalize_resets_device", action="store_true", help=(
"controls whether the CUDA device is reset explicitly at the end of the runtime finalize call. "
"This can mitigate false-positives for memory leaks and allow correct profiling, but might cause CUDA context errors in "
"applications linking against FEAT"))

parser.add_argument("--in-home", "--in_home", action="store_true", help=
"allow in-home builds. Not recommended")

parser.add_argument("--initial-cache-file", "--initial_cache_file", help=
"Provide a CMake script to populate the cache. Options set by the script override options set here. Options set by the script are not included in any CMake presets")

parser.add_argument("--in-source", "--in_source", action="store_true", help=
"allow in-source builds. Not recommended")

# TODO: Do what the help says
parser.add_argument("--likwid-explicit-path", "--likwid_explicit_path", help=(
"turns off the internal find_package mechanism of CMake and instead uses "
"the provided prefix path to the install directory of likwid, i.e. .../prefix/include/likwid.h "
"and .../prefix/lib/liblikwid.so must exist and in turn are guranteed to be used. "
"This option will probably be removed in a future release with an internal find script."))

parser.add_argument("--likwid-markers" "--likwid_markers", action="extend", nargs="+", choices = ["kernel", "app", "special", "cuda"], help=
"list of performance markers to activate. Defaults to 'app'")

parser.add_argument("--mkl-sparse-executor", "--mkl_sparse_executor", action="store_true", help=
"use the Intel MKL sparse executor interface")

parser.add_argument("--mpi-c", "--mpi_c", help=
"set MPI C compiler wrapper")

parser.add_argument("--mpi-cxx", "--mpi_cxx", help=
"set MPI C++ compiler wrapper")

parser.add_argument("--mpi-thread-multiple", "--mpi_thread_multiple", action="store_true", help=
"use multiple threads for asynchronous mpi calls")

parser.add_argument("--no-external-downloads", "--no_external_download", action="store_true", default=False, help=
"do not download any thirdparty dependencies in the configure step. Will cause errors if requested dependencies can not be found by CMake (default: %(default)s)")

parser.add_argument("--no-external-libs", "--no_external_libs", action="store_true", default=False, help =
"always download thirdparty dependencies in the configure step (default: %(default)s)")

parser.add_argument("--no-preset", action="store_true", default=False, help=
"do not write a CMake preset to the repositories CMakeUserPresets.json")

parser.add_argument("--no-thirdparty-cache", "--no_thirdparty_cache", action="store_true", default=False, help=
"disable caching for thirdparty dependencies (default: %(default)s)")

parser.add_argument("--override-mpi-ops", "--override_mpi_ops", "--ovr_mpi_ops", action="store_true", help=
"override MPI operations with custom implementations. Automatically enabled if both quadmath and MPI are used")

parser.add_argument("--package-install-dir", "--package_install_dir", help=
"additional directory to search for installed thirdparty dependencies in")

parser.add_argument("--preset-only", "--preset_only", action="store_true", default=False, help=
"generate a CMake preset for the chosen configuration, but do not run CMake (default %(default)s)")

parser.add_argument("--restrict-errors", "--restrict_errors", action="store_true", help=
"abort compilation after an error is encountered")

parser.add_argument("--set-testing-vc", "--set_testing_vc", action="store_true", help=
"suppress debug prompts in Windows testing environment")

parser.add_argument("--system-host-compiler", "--system_host_compiler", help=(
"selects the system compiler (and header files) used by icc, icx and clang. "
"Be aware that icc/icx needs the path to a gcc binary and clang needs the path to the folder "
"containing the whole toolchain"))

parser.add_argument("--thirdparty-cache-dir", "--thirdparty_cache_dir", default="", help=
f"set cache directory for thirdparty dependencies (default: {trunk_dirname}/thirdparty/cache)")

parser.add_argument("--trilinos-path", "--trilinos_path", help=
"path to a FROSch compatible Trilinos installation")

parser.add_argument("--unroll-banded", "--unroll_banded", action="store_true", help=
"unroll SparseMatrixBanded kernels")

args = parser.parse_args()

# Emit warnings for deprecated flags
for arg in sys.argv:
  if arg.startswith("--") and "_" in arg and arg != "--ovr_mpi_ops":
    warning("Flag", arg, "is deprecated. Use", arg.replace("_", "-"), "instead")
  if arg == "--ovr_mpi_ops":
    warning("Flag --ovr_mpi_ops is deprecated. Use --override-mpi-ops instead")
  if arg == "--trilinos_path":
    warning("Flag --trilinos_path is deprecated. Use --package-install-dir instead")


# guess a fitting configuration and search for available compilers
if args.buildid == "guess":
  buildid = ["opt"]
  if is_found("mpic++") or is_found("mpicxx"):
    buildid.append("-mpi")
  if is_found("g++"):
    buildid.append("-gcc")
  elif is_found("icpc"):
    buildid.append("-icc")
  elif is_found("icpx"):
    buildid.append("-icx")
  elif is_found("clang++"):
    buildid.append("-clang")
  else:
    error("No compatible compiler found or provided")
else:
  buildid = args.buildid.strip("-").split("-")


# Validate buildid
# Check for:
# - exactly one compiler tag
# - exactly one build mode tag
# - dependencies among other tags

valid_compiler_tags = [
  "gcc", "gnu", "g++",
  "icc", "intel", "icpc",
  "icx", "icpx", "oneapi",
  "clang", "llvm",
  "cray",
  "msvc",
]

valid_mode_tags = ["debug", "nopt", "opt"]

compiler_tags = [tag for tag in buildid if tag in valid_compiler_tags]
mode_tags = [tag for tag in buildid if tag in valid_mode_tags]

if len(compiler_tags) == 0:
  error("No compiler tag in build-id")

if len(compiler_tags) > 1:
  error("Too many compiler tags in build-id")

if len(mode_tags) == 0:
  error("No build mode tag in build-id")

if len(mode_tags) > 1:
  error("More than one build mode tag in build-id")

if "half" in buildid and not "cuda" in buildid:
  error("Tag 'half' requires tag 'cuda'")

# prevent parmetis without mpi enabled (needed by parmetis)
if "mpi" not in buildid and "metis" in buildid:
  error("Tag 'metis' requires tag 'mpi'")

if "mpi" not in buildid and "parmetis" in buildid:
  error("Tag 'parmetis' requires tag 'mpi'")

# SuperLU needs MPI, because we only use SuperLU_DIST
if ("mpi" not in buildid) and ("superlu" in buildid):
  error("Tag 'superlu' requires tag 'mpi'")

# SuperLU needs MPI, because we only use SuperLU_DIST
if ("mpi" not in buildid) and ("zoltan" in buildid):
  error("Tag 'zoltan' requires tag 'mpi'")

if "lto" in buildid and not "opt" in buildid:
  error("LTO is only usable in opt mode")

if "cudamemcheck" in buildid and not "cuda" in buildid:
  error("Tag 'cudamemcheck' requires tag 'cuda'")

if "cudss" in buildid and not "cuda" in buildid:
  error("Tag 'cudss' requires tag 'cuda'")

if "ccache" in buildid and "scorep" in buildid:
  error("Tags 'ccache' and 'scorep' cannot be used together")

config = FeatConfig()

# print a warning that half/quadmath + mpi requires overriding of MPI operations to function properly if not given
if (("half" in buildid) or ("quadmath" in buildid)) and ("mpi" in buildid) and not (args.override_mpi_ops):
  warning(("'half' or 'quadmath' and 'mpi' are specified in build-id, but MPI operations were not overridden;\n"
           "automatically enabling MPI operations overrides because MPI applications would crash otherwise.\n"
           "Please manually add the '--override-mpi-ops' option to this configure script call when configuring with\n"
           "'half' or 'quadmath' support enabled to suppress this warning message."))
  config.cache_entry("FEAT_OVERRIDE_MPI_OPS", "ON", "BOOL")

# Defaults we always want to set
config.buildid = buildid
config.cache_entry("BUILD_ID", "-".join(buildid), "STRING")
config.cache_entry("CMAKE_EXPORT_COMPILE_COMMANDS", "ON", "BOOL")
config.cputype = args.cpu or detect_cpu()
config.cache_entry("FEAT_CPU_TYPE", config.cputype, "STRING")
config.add_c_flags("-O3")

# Handle command line arguments

if args.allow_unsupported_compiler:
  config.cache_entry("FEAT_ALLOW_UNSUPPORTED_COMPILER", "ON", "BOOL")

if args.cc:
  if not os.path.exists(args.compiler_cc):
    error("Could not find specified C compiler", args.compiler_cc)
  config.set_compiler_cc(args.compiler_cc)

if args.cuda_host_compiler:
  if not os.path.exists(args.cuda_host_compiler):
    error("Could not find specified cuda host compiler", args.cuda_host_compiler)

if args.cxx:
  if not os.path.exists(args.compiler_cxx):
    error("Could not find specified C++ compiler", args.compiler_cxx)
  config.set_compiler_cxx(args.compiler_cxx)

if args.eickt:
  config.cache_entry("FEAT_EICKT", "ON", "BOOL")

if args.finalize_resets_device:
  config.cache_entry("FEAT_FINALIZE_RESETS_DEVICE", "ON", "BOOL")

if args.likwid_explicit_path:
  if not os.path.exists(args.likwid_explicit_path):
    error("Likwid path", args.likwid_explicit_path, "does not exist")
  config.cache_entry("FEAT_EXPLICIT_LIKWID_PATH", args.likwid_explicit_path, "FILEPATH")

if args.mkl_sparse_executor:
  config.cache_entry("FEAT_USE_MKL_SPARSE_EXECUTOR", "ON", "BOOL")

if args.mpi_c:
  if not os.path.exists(args.mpi_c):
    error("Could not find specified MPI c compiler wrapper", args.mpi_c)
  config.cache_entry("FEAT_MPI_C", args.mpi_c, "STRING")

if args.mpi_cxx:
  if not os.path.exists(args.mpi_cxx):
    error("Could not find specified MPI C++ compiler wrapper", args.mpi_cxx)
  config.cache_entry("FEAT_MPI_CXX", args.mpi_cxx, "STRING")

if args.mpi_thread_multiple:
  config.cache_entry("FEAT_MPI_THREAD_MULTIPLE", "ON", "BOOL")

if args.no_external_downloads:
  config.cache_entry("FEAT_NO_EXTERNAL_DOWNLOAD", "ON", "BOOL")

if args.no_external_libs:
  config.cache_entry("FEAT_PREFER_EXTERNAL_TPL", "OFF", "BOOL")

if args.no_thirdparty_cache:
  config.cache_entry("FEAT_TPL_CACHE_DIRECTORY", "", "STRING")

if args.override_mpi_ops:
  config.cache_entry("FEAT_OVERRIDE_MPI_OPS", "ON", "BOOL")

if args.package_install_dir:
  for path in args.package_install_dir.split(";"):
    if not os.path.exists(path):
      error("Package install directory", path, "does not exist")
  config.append_entry("CMAKE_PREFIX_PATH", args.package_install_dir, "FILEPATH")

if args.set_testing_vc:
  config.cache_entry("FEAT_TESTING_VC", "ON", "BOOL")

if args.system_host_compiler:
  if not os.path.exists(args.system_host_compiler):
    error("Could not find specified system host compiler", args.system_host_compiler)
  config.system_host_compiler = args.system_host_compiler
  config.cache_entry("FEAT_SYSTEM_HOST_COMPILER", args.system_host_compiler, "STRING")

if args.thirdparty_cache_dir:
  if not os.path.exists(args.thirdparty_cache_dir):
    error("Thirdparty cache directory", args.thirdparty_cache_dir, "does not exist")
  config.cache_entry("FEAT_TPL_CACHE_DIRECTORY", args.thirdparty_cache_dir, "FILEPATH")

if args.trilinos_path:
  if not os.path.exists(args.trilinos_path):
    error("Trilinos path", args.trilinos_path, "does not exist")
  if not "trilinos" in buildid:
    warning("You have specified a trilinos path, but there is no trilinos tag in the build-id")
  config.append_entry("CMAKE_PREFIX_PATH", args.trilinos_path, "FILEPATH")

if args.unroll_banded:
  config.cache_entry("FEAT_UNROLL_BANDED", "ON", "BOOL")

# Now that we have handled all optional arguments and overrides,
# we can parse the actual build id and complete the configuration data

for token in buildid:
  if token == "ninja":
    config.generator = "Ninja"
  elif token == "xcode":
    config.generator = "Xcode"
  elif token == "unixmake":
    config.generator = "Unix Makefiles"
  elif token == "vsproject":
    config.generator = "Visual Studio 17 2022"
  elif token == "debug":
    config.cache_entry("FEAT_DEBUG_MODE", "ON", "BOOL")
    config.cache_entry("CMAKE_BUILD_TYPE", "Debug", "STRING")
  elif token == "nopt":
    config.cache_entry("FEAT_DEBUG_MODE", "ON", "BOOL")
    config.cache_entry("CMAKE_BUILD_TYPE", "RelWithDebInfo", "STRING")
  elif token == "opt":
    config.cache_entry("FEAT_DEBUG_MODE", "OFF", "BOOL")
    config.cache_entry("CMAKE_BUILD_TYPE", "Release", "STRING")
  elif token == "gcc" or token == "gnu" or token == "g++":
    config.set_compiler_cxx("g++")
    config.set_compiler_cc("gcc")

    cxxflags_tmp = configure_gcc(config.cputype, config.buildid, "g++", args.restrict_errors)
    if cxxflags_tmp:
      config.add_cxx_flags(*cxxflags_tmp.split(" "))

    if "coverage" in config.buildid:
      config.add_ld_flags("-fprofile-arcs", "-ftest-coverage")

    if "lto" in config.buildid:
      #use gcc provided binutils for lto
      config.cache_entry("CMAKE_RANLIB", find_exe("gcc-ranlib"), "PATH")
      config.cache_entry("CMAKE_AR", find_exe("gcc-ar"), "PATH")

    config.cache_entry("FEAT_COMPILER_ID", "gcc", "STRING")
  elif token == "icc" or token == "intel" or token == "icpc":
    config.set_compiler_cxx("icpc")
    config.set_compiler_cc("icc")

    config.cache_entry("FEAT_COMPILER_ID", "icc", "STRING")

    cxxflags_tmp = configure_icc(
      config.cputype,
      config.buildid,
      "icpc",
      config.system_host_compiler,
      args.restrict_errors
    )

    if cxxflags_tmp:
      config.add_cxx_flags(*cxxflags_tmp.split(" "))
  elif token == "icx" or token == "icpx" or token == "oneapi":
    config.set_compiler_cxx("icpx")
    config.set_compiler_cc("icx")

    config.cache_entry("FEAT_COMPILER_ID", "icx", "STRING")

    cxxflags_tmp = configure_icx(
      config.cputype,
      config.buildid,
      "icpx",
      config.system_host_compiler,
      args.restrict_errors
    )
    if cxxflags_tmp:
      config.add_cxx_flags(*cxxflags_tmp.split(" "))
  elif token == "clang" or token == "llvm":
    config.set_compiler_cxx("clang++")
    config.set_compiler_cc("clang")

    config.cache_entry("FEAT_COMPILER_ID", "clang", "STRING")

    cxxflags_tmp = configure_clang(
      config.cputype,
      config.buildid,
      "clang",
      config.system_host_compiler,
      args.restrict_errors
    )
    if cxxflags_tmp:
      config.add_cxx_flags(*cxxflags_tmp.split(" "))
  elif token == "cray":
    config.set_compiler_cxx("CC")
    config.set_compiler_cc("cc")

    config.cache_entry("FEAT_COMPILER_ID", "cray", "STRING")

    cxxflags_tmp = configure_cray(
      config.cputype,
      config.buildid,
      "CC",
      args.restrict_errors
    )
    if cxxflags_tmp:
      config.add_cxx_flags(*cxxflags_tmp.split(" "))
  elif token == "msvc":
    config.set_compiler_cxx("cl")
    config.set_compiler_cc("cl")

    config.cache_entry("FEAT_COMPILER_ID", "msvc", "STRING")

    cxxflags_tmp = configure_msvc(
      config.cputype,
      config.buildid,
      "cl",
      args.restrict_errors
    )
    if cxxflags_tmp:
      config.add_cxx_flags(*cxxflags_tmp.split(" "))
  elif token == "mpi":
    config.cache_entry("FEAT_HAVE_MPI", "ON", "BOOL")
  elif token == "ccache":
    config.set_compiler_wrapper("ccache")
    config.cache_entry("FEAT_USE_COMPILER_WRAPPER", "ON", "BOOL")
  elif token == "scorep":
    config.set_compiler_wrapper("scorep")
    config.cache_entry("FEAT_USE_COMPILER_WRAPPER", "ON", "BOOL")
  elif token == "likwid":
    config.cache_entry("FEAT_USE_LIKWID", "ON", "BOOL")
    config.cache_entry("LIKWID_PERFMON", "ON", "BOOL")
    if args.likwid_markers:
      if "app" in args.likwid_markers:
        config.cache_entry("FEAT_APPLICATION_MARKER_ACTIVATED", "ON", "BOOL")
      if "kernel" in args.likwid_markers:
        config.cache_entry("FEAT_KERNEL_MARKER_ACTIVATED", "ON", "BOOL")
      if "special" in args.likwid_markers:
        config.cache_entry("FEAT_SPECIAL_MARKER_ACTIVATED", "ON", "BOOL")
      if "cuda" in args.likwid_markers:
        config.cache_entry("LIKWID_NVMON", "ON", "BOOL")
    else:
      config.cache_entry("FEAT_APPLICATION_MARKER_ACTIVATED", "ON", "BOOL")
  elif token == "sanitizer":
    config.cache_entry("FEAT_SANITIZER", "ON", "BOOL")
  elif token == "cuda":
    config.cache_entry("FEAT_HAVE_CUDA", "ON", "BOOL")

    if args.cuda_host_compiler:
      cuda_host_compiler = args.cuda_host_compiler
    else:
      cuda_host_compiler = find_exe(config.get_compiler_cxx())
    config.cache_entry("FEAT_CUDA_HOST_COMPILER", cuda_host_compiler, "FILEPATH")

    if not args.cuda_arch:
      cuda_arch, cuda_arch_int = detect_cuda_arch()
    else:
      cuda_arch = args.cuda_arch
      cuda_arch_int = int(cuda_arch.split("sm_")[-1])

    config.cache_entry("FEAT_CUDA_ARCH", cuda_arch, "STRING")
    config.cache_entry("CMAKE_CUDA_ARCHITECTURES", str(cuda_arch_int), "STRING")
    config.cuda_arch = cuda_arch
    config.cuda_arch_int = cuda_arch_int

    if args.cuda_verbose:
      config.cache_entry("FEAT_CUDA_VERBOSE", "ON", "BOOL")
  elif token == "cudamemcheck":
    config.cache_entry("FEAT_CUDAMEMCHECK", "ON", "BOOL")
  elif token == "cudss":
    config.cache_entry("FEAT_HAVE_CUDSS", "ON", "BOOL")
  elif token == "mkl":
    config.cache_entry("FEAT_HAVE_MKL", "ON", "BOOL")
    config.cxx_flags.append("-DMKL_ILP64")
  elif token == "omp":
    config.cache_entry("FEAT_HAVE_OMP", "ON", "BOOL")
  elif token == "valgrind":
    config.cache_entry("FEAT_VALGRIND", "ON", "BOOL")
  elif token == "quadmath":
    config.cache_entry("FEAT_HAVE_QUADMATH", "ON", "BOOL")
    config.cache_entry("FEAT_OVERRIDE_MPI_OPS", "ON", "BOOL")
  elif token == "half":
    if (config.cuda_arch != "native") and (config.cuda_arch_int < 60):
      warning("cuda arch " + config.cuda_arch + " is too low for half, which needs at least sm_60")
    else:
      config.cache_entry("FEAT_HAVE_HALFMATH", "ON", "BOOL")
      config.cache_entry("FEAT_OVERRIDE_MPI_OPS", "ON", "BOOL")
  elif token == "cotire":
    config.cache_entry("FEAT_COTIRE", "ON", "BOOL")
  elif token == "trilinos":
    config.cache_entry("FEAT_HAVE_TRILINOS", "ON", "BOOL")
  elif token == "lto":
    # Valid token, but handled specially later
    pass
  elif token == "alglib":
    config.cache_entry("FEAT_HAVE_ALGLIB", "ON", "BOOL")
  elif token == "boost":
    config.cache_entry("FEAT_HAVE_BOOST", "ON", "BOOL")
  elif token == "cgal":
    config.cache_entry("FEAT_HAVE_CGAL", "ON", "BOOL")
  elif token == "cudss":
    config.cache_entry("FEAT_HAVE_CUDSS", "ON", "BOOL")
  elif token == "deathhandler":
    config.cache_entry("FEAT_HAVE_DEATH_HANDLER", "ON", "BOOL")
  elif token == "floatx":
    config.cache_entry("FEAT_HAVE_FLOATX", "ON", "BOOL")
  elif token == "fparser":
    config.cache_entry("FEAT_HAVE_FPARSER", "ON", "BOOL")
  elif token == "hypre":
    config.cache_entry("FEAT_HAVE_HYPRE", "ON", "BOOL")
  elif token == "metis":
    config.cache_entry("FEAT_HAVE_PARMETIS", "ON", "BOOL")
  elif token == "pmp":
    config.cache_entry("FEAT_HAVE_PMP", "ON", "BOOL")
  elif token == "superlu":
    config.cache_entry("FEAT_HAVE_SUPERLU_DIST", "ON", "BOOL")
  elif token == "triangle":
    config.cache_entry("FEAT_HAVE_TRIANGLE", "ON", "BOOL")
  elif token == "umfpack":
    config.cache_entry("FEAT_HAVE_UMFPACK", "ON", "BOOL")
  elif token == "zfp":
    config.cache_entry("FEAT_HAVE_ZFP", "ON", "BOOL")
  elif token == "zlib":
    config.cache_entry("FEAT_HAVE_ZLIB", "ON", "BOOL")
  elif token == "zoltan":
    config.cache_entry("FEAT_HAVE_ZOLTAN", "ON", "BOOL")
  else:
    warning("Unknown build-id token", token)

# always set build flags offline
config.env["CMAKE_CXX_FLAGS_DEBUG"] = ""
config.env["CMAKE_CXX_FLAGS_RELEASE"] = ""
config.env["CMAKE_CXX_FLAGS_MINSIZEREL"] = ""
config.env["CMAKE_CXX_FLAGS_RELWITHDEBINFO"] = ""
config.env["CMAKE_C_FLAGS_DEBUG"] = ""
config.env["CMAKE_C_FLAGS_RELEASE"] = ""
config.env["CMAKE_C_FLAGS_MINSIZEREL"] = ""
config.env["CMAKE_C_FLAGS_RELWITHDEBINFO"] = ""

# give cmake on macOS a hint to the openmp lib
if (platform.system() == "Darwin") and ("omp" in buildid):
  config.add_ld_flags("-L/usr/opt/local/opt/libomp/lib")
  config.add_cxx_flags("-I/usr/opt/local/opt/libomp/include")

if "lto" in buildid and "opt" in buildid:
  config.add_ld_flags(*config.cxx_flags)

# set system host compiler in cflags to pass cmake's c compiler check
if "icc" in buildid or "intel" in buildid or "icpc" in buildid:
  if config.system_host_compiler:
    config.add_c_flags("-gcc-name=" + config.system_host_compiler)

# print out choosen configuration
header("============== configure_feat ===========")
print("Build-ID: " + "-".join(config.buildid))
print("")
print("CPU Type: " + config.cputype)
print("")
print("cxx: " + config.get_compiler_cxx())
print("")
print("cxxflags: " + config.cxx_flags_str())
print("")
print("ldflags: " + config.ld_flags_str())
print("")
if (config.cuda_arch != ""):
  print("cuda_arch: " + config.cuda_arch)
  print("")
print("Generator: " + config.generator)

if not args.no_preset:
  print("")
  print("Adding CMake preset to", trunk_dirname + "/CMakeUserPresets.json")
  try:
    append_preset_to_file(trunk_dirname + "/CMakeUserPresets.json", config.as_configure_preset())
  except OSError as e:
    error(e)

# Exit if we do not actually need to configure a build directory
if args.preset_only:
  sys.exit(0)

# check for in-source configure
# [:-9] strips the /configure from sys.argv[0]
if is_subdirectory(os.getcwd(), sys.argv[0][:-9]):
  if not args.in_source:
    error(("You are trying to configure for an in-source build, which is a really bad idea.\n"
          "It is recommended that you call this configure script from a separate build directory.\n"
          "If you really insist on an in-source build, you need to specify the '--in-source' option."))

# check for in-home configure
if os.path.realpath(os.getcwd()) == os.path.realpath(os.path.expanduser("~")):
  if not args.in_home:
    error(("You are trying to configure for a build in your home directory, which is a really bad idea.\n"
          "It is recommended that you call this configure script from a separate build directory.\n"
          "If you really insist on a build in your home directory, you need to specify the '--in-home' option."))


# check for cmake binary
if not is_found ("cmake"):
  error("Could not find cmake binary")

if not is_found(config.compiler_cxx):
  error("Could not find chosen cxx binary", config.compiler_cxx)

if not is_found(config.compiler_cc):
  error("Could not find chosen cc binary", config.compiler_cc)

if "valgrind" in buildid:
  if not is_found("valgrind"):
    error("Could not find valgrind")
  print("valgrind version: " + get_output("valgrind --version")[0])

if config.compiler_wrapper:
  if not is_found(config.compiler_wrapper):
    error("Could not find chosen compiler wrapper", config.compiler_wrapper)

# clean up previous configurations
clean = [ "CMakeCache.txt", trunk_dirname+os.sep+"CMakeCache.txt" ]
for i in clean:
  if os.path.exists(i):
    os.unlink(i)
clean = [ "feat_config.hpp", trunk_dirname+os.sep+"feat_config.hpp" ]
for i in clean:
  if os.path.exists(i):
    os.unlink(i)
clean = [ "rules.ninja", trunk_dirname+os.sep+"rules.ninja" ]
for i in clean:
  if os.path.exists(i):
    os.unlink(i)
clean = [ "build.ninja", trunk_dirname+os.sep+"build.ninja" ]
for i in clean:
  if os.path.exists(i):
    os.unlink(i)
clean = [ "CMakeFiles", trunk_dirname+os.sep+"CMakeFiles" ]
for i in clean:
  if os.path.exists(i):
    shutil.rmtree(i)

# clear all related
os.environ["CXXFLAGS"] = ""
os.environ["CXX"] = ""
os.environ["LD"] = ""
os.environ["CC"] = ""
os.environ["LDFLAGS"] = ""
os.environ["OMP_CXX"] = ""
os.environ["OMP_CC"] = ""
os.environ["MPICH_CXX"] = ""
os.environ["MPICH_CC"] = ""

# export compiler/linker flags
os.environ["CXXFLAGS"] = config.cxx_flags_str()
os.environ["CXX"] = config.get_compiler_cxx()
os.environ["LD"] = config.get_linker()
os.environ["CC"] = config.get_compiler_c()
os.environ["LDFLAGS"] = config.ld_flags_str()
os.environ["CFLAGS"] = config.c_flags_str()

# Construct cmake call
cmake_args = ["cmake", "--log-level=VERBOSE"]
cmake_args += config.cmake_flags()
cmake_args += ["-G", config.generator]
cmake_args += ["-C", args.initial_cache_file] if args.initial_cache_file else []
cmake_args += [trunk_dirname]

# print out cmake call
print("")
print(" ".join(map(shlex.quote, cmake_args)))
print("")
# start actual configuration
header("============== CMAKE =====================")
sys.stdout.flush()
sys.stderr.flush()
subprocess.run(cmake_args)
