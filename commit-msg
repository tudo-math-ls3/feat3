#!/bin/sh
#
# vim: set filetype=sh tabstop=8 softtabstop=8 shiftwidth=8 expandtab :
#
# Copy or link this file as ".git/hooks/pre-commit".

# Set GIT_DIR either from the working directory, or from the environment
# variable.
GIT_DIR=$(git rev-parse --git-dir 2>/dev/null)
if [ -z "$GIT_DIR" ]; then
        echo >&2 "fatal: commit-msg: GIT_DIR not set"
        exit 1
fi

# Prepare a copy of the message:
#  - strip comment lines
#  - stop at "diff --git" (git commit -v)
commit_msg="$GIT_DIR/COMMIT_MSG"
sed -n -e '/^#/d' -e '/^diff --git/q' -e 'p;d' "$1" > "$commit_msg"

die() {
        echo 'commit-msg hook failure' 1>&2
        echo '-----------------------' 1>&2
        echo '' 1>&2
        echo "$@" 1>&2
        echo 'To continue editing, identify the location of your .git directory to locate and
re-use the previously typed message by running the command

  git commit -e -F `git rev-parse --git-dir`/COMMIT_MSG

You may want to additionally specify any commit option you used previously,
e.g. --amend or --signoff.

' 1>&2
        exit 1
}

#-----------------------------------------------------------------------------
# Check the commit message layout with a simple state machine.

msg_is_merge() {
        test -f "$GIT_DIR/MERGE_HEAD" &&
        echo "$line" | grep "^Merge " >/dev/null 2>&1
}

msg_is_revert() {
        echo "$line" | grep "^Revert " >/dev/null 2>&1
}

msg_first() {
        len=$(echo -n "$line" | wc -c)
        if test $len -eq 0; then
                # not yet first line
                return
        elif test $len -lt 8; then
                die 'The first line must be at least 8 characters:
--------
'"$line"'
--------
'
        elif test $len -gt 78 && ! msg_is_merge && ! msg_is_revert; then
                die 'The first line may be at most 78 characters:
------------------------------------------------------------------------------
'"$line"'
------------------------------------------------------------------------------
'
        elif echo "$line" | grep "^[	 ]\|[	 ]$" >/dev/null 2>&1; then
                die 'The first line may not have leading or trailing space:
['"$line"']
'
        else
                # first line okay
                state=second
        fi
}

msg_second() {
        if test "x$line" != "x"; then
                die 'The second line must be empty:
'"$line"
        else
                state=rest
        fi
}

msg_rest() {
        false
}

# Pipe commit message into the state machine.
state=first
cat "$commit_msg" |
while IFS='' read line; do
        msg_$state || break
done &&
rm -f "$commit_msg"
